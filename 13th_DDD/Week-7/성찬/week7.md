# 13 실무에서의 도메인 주도 설계 
현실에서 마주하는 레거시 프로젝트에 도메인 주도 설계 도구와 패턴을 적용하기 위한 전략

## 전략적 분석
조직의 비즈니스 전략과 시스템 아키텍처의 현 상황을 이해하는 데에 시간을 투자하는 것이 좋은 시작점이다.  
* 조직의 비즈니스 도메인은 무엇인가?
* 고객은 누구인가?
* 조직이 고객에게 제공하는 서비스 또는 가치는 무엇인가?
* 경쟁 회사 또는 그들의 제품은 무엇인가?

하위 도메인을 달성하기 위해 사용하는 비즈니스 구성요소를 찾는다.  
비즈니스 도메인에서 경쟁하기 위해서 조직 단위들이 어떻게 협력하는지 조사  

### 핵심 하위 도메인
우리 회사의 핵심 하위 도메인이 경쟁업체와 차별화되는 점을 찾아라

### 일반 하위 도메인
상용 솔루션, 구독 서비스, 오픈소스 소프트웨어를 찾아서 대체하자

### 지원 하위 도메인
상용 솔루션으로 대체할 수 없지만 경쟁 우위를 제공하지 않는 소프트웨어를 찾자  
스파게티여도 변경되지 않는다.  

### 현재 설계 탐색
코드 베이스에서 컴포넌트 단위로 분리해내서 독립적으로 개선되고 테스트되고 배포될 수 있는지 확인하자

### 전술적 설계 평가
비즈니스 로직과 컴포넌트 아키텍처를 정의하는데에 사용한 패턴이 문제해결하는데에 적합한가?  
복잡성은 해결해 주는가? 더 정교한 설계 패턴이 있는가? 하위 도메인으로 대체될 수 있는가?  

### 전략적 설계 평가
컨텍스트 맵을 차트로 표시하자  
* 동일한 상위 수준의 컴포넌트에 대해 작업하는 여러 팀이 있는가?
* 핵심 하위 도메인의 중복 구현이 있는가?
* 하청 회사가 핵심 하위 도메인을 구현하는가?
* 자주 실패하는 연동으로 마찰이 있는가?
* 외부 서비스와 레거시 시스템에서 확산되는 어색한 모델이 있는가?

### 현대화 전략
처음부터 다시 작성해도 어차피 올바르게 설계하고 구현하기 어렵다.  
기존의 시스템을 조금씩 안전하게 개선하는 것이 좋다.  
그거려면 하위 도메인을 BC로 나누고 패키지 구조와 일치하는지 확인한다.

### 전략적 현대화
논리적 경계를 물리적 경계로 바꿔서 가장 많은 가치를 얻는 곳을 찾아라  
* 여러 팀이 동일한 코드베이스에서 작업하고 있는가?
  * 팀에 대한 BC를 정의하여 개발 수명 주기를 분리하라
* 서로 다른 컴포넌트에서 충돌하는 모델을 사용하고 있는가?
  * 충돌하는 모델을 별도의 BC로 재배치하라

BC를 개발할 때 다른 팀과 어떻게 협업하는지 확인하라. 컨텍스트 통합 패턴으로 해결할 수 있는 문제인지 확인해라  

### 전술적 현대화
비즈니스와 구현 전략 중 가장 고통스러운 부조화를 찾아라  
비즈니스가 복잡한데 트랜잭션 스크립트 / 액티브 레코드로 구현되어 잇는 것이 그 예이다.  

### 유비쿼터스 언어 육성
언어를 설계하고 이벤트 스토밍을 반복하자  

### 스트랭글러 패턴
레거시 시스템을 조금씩 개선하여 결국엔 레거시 시스템이 현대적 시슽쳄으로 마이그레이션이 된다.  
파사드 패턴과 함께 사용할 수 있다. 파사드 패턴은 얇은 추상화 게층을 둬서 퍼블릭 인터페이스 역할을 하고, 레거시 or 현대화 BC로 요청을 전달한다.  
마이그레이션이 완료되면 파사드가 필요 없으니 제거한다.  
스트랭글러 패턴에서는 레거시와 현대 시스템은 동일한 DB를 사용하며 동일한 데이터로 동작한다.  

### 전술적 설계 의사결정 리팩터링
작은 것을 개선하는 것부터 시작하자. VO부터 찾자.  

### 실용적인 도매인 주도 설계
* 조직에서 사용하는 언어를 통합하고 일관성을 지키자 -> 유비쿼터스 언어
* 모든걸 분리할때 BC 패턴을 기반으로 하자
* 리팩터링 을 설득할 때 "책에서 그렇게 말하니까" 라고 하지 말자.

# Part4 다른 방법론 및 패턴과의 관계
## MSA
### 서비스
서비스는 미리 정의된 인터페이스를 사용해 하나 이상의 역량에 접근하기 위한 메커니즘  
잘 표현된 인터페이스는 서비스가 하는 일을 명확하게 설명한다.

### MSA란
마이크로 퍼블릭 인터페이스에 의해 정의되는 서비스  
* 퍼블릭 인터페이스가 작아지면 단일 서비스 기능과 서비스에 연동하는 다른 시스템 구성요소를 쉽게 이해할 수 있다
* 서비스 기능응ㄹ 줄이면 변경될 이유가 줄고 개발,관리 확장을 자율적으로 할 수 있다.
* DB를 감출 수 있다.

### 서비스형 메서드
서비스 하나에 메서드 하나만 추가한다면, 8개의 퍼블릭 메서드를 가지는 서비스는 8개의 마이크로 서비스로 분리될 수 있다. (워스트 프랙티스)

### 설계 목표
**단일 컴포넌트 설계에 집중하지말고 유연한 시스템을 만드는데에 집중해라**  
너무 잘게 쪼개면 시스템은 더 복잡해진다. 시스템은 절대 독립적인 컴포넌트로 구축될 수 없다.  
다른 서비스, 디바이스와 상호작용할 수 밖에 없다.

### 시스템의 복잡성
모놀리식 아키텍처 -> 글로벌 복잡성 0, 로컬 복잡성 100  
두 복잡성 균형을 잘 잡자

### 깊은 서비스의 MS
* 깊은 모듈: 인터페이스 메서드가 적은 반면 로직이 많다.
* 얕은 모듈: 인터페이스 메서드가 많은 반면 로직이 적다.

깊은 모듈이 효과적이다.

### 깊은 모듈의 MS
얕은 서비스는 MSA 가 실패하는 원인이다.  
시스템 설계에서 가장 중요한 것은 수정을 쉽게 하는 것이다. 재작성을 쉽게 하는 것이 아니다.  

## DDD와 MSA의 경계
BC, 하위 도메인, AG/VO(트랜잭션 경계) 중 어떤 것이 MSA에 도움을 주는지 확인하자  

### BC
MS와 BC는 공통점이 많아서 혼동하기 쉽다. 
* 공통점
  * 물리적 경계이다.
  * 단일 팀이 소유한다.
  * MS is BC but BC is not MS

### AG
* AG 경계를 최대한 좁게 설정한다
* 내부 비즈니스 규칙과 불변성, 로직의 복잡성을 감싸는 개별적인 비즈니스 기능 단위
* MS는 개별적인 서비스가 아니다. 

### 하위 도메인
* 비즈니스 하위 도메인 경계와 서비스를 일치시키자
* 하위 도메인을 MS로 만드는 것이 대부분의 MSA를 위한 최적의 솔루션을 만드는 휴리스틱이다. <-- 완전 공감
* 하위 도메인의 크기와 "어떻게" 보다는 "무엇을"에 중점을 둔 기능이 하위 도메인을 깊은 모듈로 만든다.
* 하위 도메인을 설명하는 "기능"은 더 복잡한 구현 상세인 "로직"을 캡슐화 한다. <-- 중요해보임
* 하위 도메인에 포함된 유스케이스의 응집력이 인터페이스를 만들고 모듈은 더욱 얕아진다.

### MS 의 퍼블릭 인터페이스 압축하기
오픈 호스트 서비스와 충돌 방지 계층 패턴으로 퍼블릭 인터페이스를 단순화할 수 있다.  

#### 오픈 호스트 서비스
오픈 호스트 서비스는 비즈니스 도메인의 BC 모델을 시스템의 다른 구성요소와 연동하는 데 사용되는 모델과 분리해준다.  
퍼블릭 언어를 도입해서 노출한다. 그럼 글로벌 복잡도가 줄어든다.  
그냥 인터페이스를 잘 설계하라는 뜻인듯

#### 충돌 방지 계층(ACL)
로컬 복잡성과 글로벌 복잡성을 둘 다 줄일 수 있다. BC의 복잡성을 노출하지 않을 수 있다.  

#### 결론
* BC는 모델 전반의 일관성을 보호하고 가장 넓은 유효한 경계를 나타낸다.
* BC 보다 넓은 경계를 정의하면 커다란 진흙 덩어리를 만든다.
* MS는 가장 작은 유효한 경계를 정의한다.
* MS 보다 작은 경계는 분산된 커다란 진흙 덩어리를 만든다. <--- ㄹㅇㅍㅌ
* 
