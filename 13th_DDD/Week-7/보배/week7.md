# 13. 실무에서의 도메인 주도 설계

앞서 나온 도메인 주도 설계를 직접 경험할 기회는 복권에 당첨될 확률과 비슷할 정도로 쉽지 않다고 한다.

- 복권 당첨된 사람?

<br/>

그러므로, 실세계(브라운필드/레거시)에서 적용하는 법을 알아보자.

<br/>

## 전략적 분석

가장 좋은 출발점은 비즈니스 전략 및 시스템의 아키텍처 현 상황을 이해하는 것

<br/>

### 비즈니스 도메인 이해하기

조직의 비즈니스 도메인? 고객이 누구인가? 고객에게 제공하는 가치? 경쟁회사? 그들의 제품?

- 질문에 답하면서 전체적인 조감도를 파악하자.
- 또한, 회사의 조직도를 보면서 조직단위들이 어떻게 협력하는지 파악하자.

<br/>

### 핵심 하위 도메인/일반 하위 도메인/지원 하위 도메인 파악

핵심 하위 도메인 파악하기

- 경쟁업체에 없는 비법소스가 무엇인가? 반드시 기술적인 것 아니여도 된다.
- 강력하지만 유감스럽게 찾아내는 방법
    - 최악으로 설계된 소프트웨어 컴포넌트가 있는지? → 모든 엔지니어가 싫어하지만 회사측에도 비즈니스 위험이 수반되기에 소스코드 다시 작성하는거 꺼리는게 있는지?
    - 즉, 대체할 수 없어 어쩔 수 없이 운용중인 서비스가 있나? (ㅋㅋㅋ머리좋네)

<br/>

### 현재 설계 탐색

상위 수준 컴포넌트부터 분석해나가기

- 수명주기 분리가 되는지 확인하자.
- 컴포넌트 간 독립적으로 개선되고, 테스트되고, 배포될 수 있는지 확인해보자.

<br/>

### 설계 평가

비즈니스 로직을 구현하고 아키텍처 정의하는데 어떤 패턴을 사용했는가?

- 복잡성을 해결하기에 적합한가? 더 정교한 패턴이 필요할까? 기존 솔루션 이용해서 해결이 가능한 하위 도메인이 있는가?

<br/>

현재 설계의 컨텍스트 맵을 차트로 표시하기

- 컨텍스트 연동 패턴 관점에서 컴포넌트 간의 관계를 식별하고 추적하자.
    - 쉽게 말해 상위 수준의 컴포넌트/모듈간에 의존성을 확인해보라는 뜻인듯.
- 이걸 도메인 주도 설계 관점에서 살펴보자.
    - 동일한 상위 수준 컴포넌트에 여러 팀이 작업하나?
    - 핵심 하위 도메인이 중복구현되었나?
    - 하청에서 핵심 하위 도메인을 다루고 있지는 않은가?
    - 외부서비스/레거시 시스템에서 확산되는 어색한 모델이 있는가?
    
<br/>


아무튼 이렇게 분석해보면서 도메인 지식을 넓혀나가자.

- 만약 손실된 도메인이 있다? (아무도 모르는…)
    - 이런건 파악하고 가야 함 → 이벤트스토밍 세션을 이용하자.
- 너무 잦아도 힘들 것 같은데, 주기적으로 손실된 도메인을 메꾸는 이벤트를 실시해도 좋을 듯?
    - 왜 도메인이 손실될까? → 퇴사자, 문서화 안함 등
    - 회사에 오래 계셨던 분들이 잘 참여할까? → 잦으면 귀찮아하지 않을까?
    - 유비쿼터스 언어/사전을 만들어내야 한다는 것이 핵심

<br/>

## 현대화 전략

한번에 바꾸는 ‘빅뱅’은 어렵다.

- 일단 전체 시스템 처음부터 설계하고 구현하는 것은 매우 매우 어려움
    - 테스트 코드가 있어도 어렵다 이건
- 경영진이 이러한 과정을 지원하기도 정말 드물다.

<br/>

결국, **크게 생각하되 작게 시작하는 방식**을 택해야 함.

- 시스템의 하위 도메인을 나누는 경계를 찾자. 하위 도메인을 나누는 경계를 찾는 것.
- 최소한의 논리적 경계가 하위 도메인의 경계와 일치하는지 확인하자.
    - 네임스페이스/모듈/패키지 단위가 확인한 하위 도메인의 경계와 같은가?
- 맞지 않다면, 이를 조정하자 → 재배치 하는 리팩터링. 이건 쉽다.
    - 하지만 동적 로딩/리플렉션 같은 부분은 조심해서 해야 함.

<br/>

### 전략적 현대화

다음으로 논리적 경계를 물리적 경계로 전환하여 가장 많은 가치를 얻을 수 있는 곳을 찾자.

- 여러 팀이 동일한 코드베이스 작업? → 별도의 바운디드 컨텍스트를 이용해 개발 수명주기도 분리해보자.
- 다른 컴포넌트에서 충돌하는 모델을 사용? → 별도의 바운디드 컨텍스트로 분리해보자.

<br/>

최소 바운디드 컨텍스트의 필요를 확인했다면, 컨텍스트 간에 관계/연동 패턴을 조사하자.

- 팀이 어떻게 의사소통하고 협업할 것인가? (현재 어떻게 하고 있는가?)
- 컨텍스트 통합 패턴을 확인하고, 어떻게 분리해서 연동할지 생각하자. (4장)

<br/>

### 전술적 현대화

부조화 찾아내기.

+) 전략/전술 뭔 차이인지 모르겠다. 말 장난하는 것 같음.

- 전략은 목표를 달성하기 위한 실행 계획인 반면 (목표 전체 플랜?)
- 전술은 목표를 달성하기까지의 개별적인 단계와 행동 (각 단계와 행동?)

<br/>

### 유비쿼터스 언어 육성

유비쿼터스 언어 지식을 획득하는 것은 매우 중요

- 이벤트 스토밍을 잊지 말자. 모든 사람을 모아 비즈니스 도메인을 탐색하자.

<br/>

도메인 지식과 모델이 갖췄다면, 기능에 가장 적합한 비즈니스 로직 구현 패턴을 결정하자.

- 여기서도 빅뱅은 안되고, 스트랭글러 패턴을 통해 점진적으로 교체/리팩터링 하자.

<br/>

스트랭글러 패턴?

- 새로운 요구사항을 구현하고 점차적으로 레거시 컨텍스트의 기능을 해당 컨텍스트로 마이그레이션 하는 것.
- 파사드 패턴과 함께 많이 사용됨.
    - 파사드 단에서 기존 레거시 → 조금씩 새로 작성한 코드 비율을 높여가는 것

<br/>

알아둘 것?

1. 작은 점진적인 조치가 대규모 재작성보다 안전함. 경계 찾는 것에 집중할 것.
2. 도메인 모델로의 리팩터링이 한 번에 이루어질 필요 없음. 벨류 오브젝트를 찾는 것부터 시작할 것.

<br/>

### 실용적인 도메인 주도 설계

사실 앞서 말한 도메인 주도 설계에 나오는 도구들을 다 적용할 필요 없음.

<br/>

핵심은

- 비즈니스 도메인과 해당 전략을 분석하고
- 특정 문제를 해결하기 위한 효과적인 모델을 찾고
- 비즈니스 도메인의 요구사항에 따라 설계 의사결정을 내린다면 ‘그것이 바로 도메인 주도 설계’

<br/>

즉, 도메인 주도 설계는 **비즈니스 도메인이 소프트웨어 설계 의사결정을 주도하게 하는 것**

- 이게 말이 쉽지 참 어렵다.

<br/>

## 도메인 주도 설계 확산

계속 나오는 유비쿼터스 언어의 중요성

- 도메인 주도 설계의 초석
- 일치하지 않는 용어가 있다? → 설명 요청하자.
    - 이름이 여러개야? 그 이유가 뭔가?
    - 찾아서 하나의 언어로 통일하자 → 유비쿼터스 언어 추가요.
- 코드/모든 프로젝트 관련 의사소통에 유비쿼터스 언어를 사용하자.

<br/>

바운디드 컨텍스트 / 전술적 설계 의사결정 / 이벤트 소싱 도메인 모델

- 각 단계에서 어떻게 결정할 것인가에 대한 내용
- 책/이론이 그러니 따라하자가 아닌 현재 비즈니스에 대해 질문을 하고 맞는 패턴을 찾아가자.
- 그걸 기반으로 선택한 패턴/방법/모델의 이점들을 어필해라.

<br/>

## 요약

- 처음부터 DDD 하겠다고 기존 프로젝트를 재작성하지말고, 비즈니스 도메인 분석먼저 시작해라.
- 조직 구조, 기존 소프트웨어 설계 의사결정을 이용해 조직 하위 도메인과 해당 유형을 식별해라.
- 이걸 바탕으로 현대화 전략을 계획하자.
- 관련 컴포넌트를 리팩터링하거나 교체해서 레거시 코드를 현대화 해라.
- 이 과정속에서 한번에 수정하지말고 점진적으로 수행하자.

<br/>

# 14. 마이크로서비스

바운디드 컨텍스트와 마이크로 서비스를 혼용하기도 한다.

- 헷갈리긴한다. 컨텍스트 나뉘면, 서비스도 분리해야하는 것 아닐까?

<br/>

## 서비스

미리 정의된 인터페이스를 사용해 하나 이상의 역량에 접근하기 위한 메커니즘

- 미리 정의된 인터페이스? 서비스로부터 데이터 넣고 빼는 모든 메커니즘

<br/>

퍼블릭 인테퍼이스는 서비스 자체 → 잘 표현된 인터페이스는 서비스가 구현된 기능을 설명하기에 충분함.

<br/>

## 마이크로 서비스

마이크로 퍼블릭 인터페이스로 정의되는 서비스

- 말이 겁나게 복잡하다.
- 단일 서비스의 기능과 그 서비스가 연동하는 다른 시스템 구성요소로 이루어짐?

<br/>

자신의 데이터베이스를 내부에 감싸고 있다.

- 연동 지향적인 퍼블릭 인터페이스를 통해 접근할 수 있음.

<br/>

그러면 메서드 하나당 서비스로 만들어버리면 어떻게 될까? 이게 마이크로 서비스일까?

- 마이크로 서비스이긴하겠지? 서비스이니깐?
- 아무튼 근데 서로 연동하면서 엄청나게 복잡해진다.
    - 연동 관련 관심사를 처리하기 위해 인터페이스 확장(스태프만 출입 가능한 수많은 출입구 추가)을 하게 되고, 결국엔 커다란 진흙 덩어리가 될 것.
    - 호출에 호출에 호출에 호출을 거듭하면서?
- 결국, 이렇게 해버리면 각 서비스는 기존보다 훨씬 간단해질지 몰라도, 전체 시스템은 더 복잡해진 것.
    - 적절히 분리된 마이크로 서비스는 서로 잘? 연동하고 통신한다.

<br/>

### 시스템의 복잡성

로컬 복잡성: 각각의 개별 마이크로 서비스 복잡성

- 서비스의 구현에 따라 달라짐

<br/>

글로벌 복잡성: 전체 시스템의 복잡성

- 서비스 간의 상호작용과 의존성으로 정의

![image](https://user-images.githubusercontent.com/37873745/231746591-3884617b-6b8e-4434-8c91-7b176de69ab1.png)

<br/>

위 관계로 구성됨

- 즉, 글로벌 복잡성과 로컬 복잡성 모두 최적화해야지 마이크로 서비스 기반 시스템을 설계할 수 있음.

<br/>

### 깊은 서비스/깊은 모듈

깊은 서비스/모듈

- 간단한 퍼블릭 인터페이스에 복잡한 로직을 내포한 것
- 효과적인 모듈

<br/>

시스템을 고려해 개별 서비스에 집중하자.

- 단순히 서비스에 코드 수 제한을 둔다거나 하지말자.
- 작게만 나눌려고 하지말자. 얕은 서비스로 구성하면 글로벌 복잡성이 증가하는 것.
- 통합이 필요해서 변경 비용은 다시 증가하고, 큰 진흙덩어리가 되버린다.

<br/>

## 도메인 주도 설계와 마이크로 서비스의 경계

도메인 주도 설계패턴의 대부분은 경계

- 바운디드 컨텍스트는 모델의 경계
- 하위 도메인은 비즈니스 역량의 경계
- 애그리게이트와 벨류 오브젝트는 트랜잭션의 경계

<br/>

모든 마이크로 서비스는 바운디드 컨텍스트

- 하지만 바운디드 컨텍스트 자체가 무조건 마이크로 서비스인 것은 아님.

<br/>

왜?

- 마이크로 서비스는 서비스의 가장 작은 유효한 경계를 정의함.
- 바운디드 컨텍스트는 모델의 일관성을 보호하고, 가장 넓은 유효한 경계를 나타냄.
- 즉, 바운디드 컨텍스트 내에서 마이크로 서비스를 나눌 수 있음.
    - 바운디드 컨텍스트보다 넓게 만들면, 커다란 진흙 덩어리!
    - 마이크로서비스보다 작은 경계는, 분산된 진흙 덩어리!

<br/>

에그리게이트?

- 에그리게이트는 내부 비즈니스 규칙과 불변성, 로직의 복잡성을 감사는 개별적인 비즈니스 기능 단위.
- 비즈니스 기능 단위로 마이크로 서비스? → 글로벌 복잡성 증가시킴

<br/>

하위 도메인?

- 하위 도메인은 응집된 유스케이스 집합을 대표함.
- 즉, 같은 비즈니스 도멩니 모델을 사용하거나, 밀접하게 관련된 데이터를 다루고, 강한 기능 관련성을 보임.
- 이렇다보니 비즈니스 하위 도메인 경계와 마이크로 서비스 경계를 일치시키자
    - 최적의 솔루션을 만드는 휴리스틱.

<br/>

뭐 위의 방법들을 작성했지만, 사실 조직구조/비즈니스 전략/환경 등에 따라 적절한 경계를 마이크로 서비스 경계로 설정할 수 있음. 꼭 따를 필요 없음.