# 7 시간 차원의 모델링

## 이벤트 소싱
아래와 같은 테이블을 분석하면 많은 정보를 어등ㄹ 수 있다.

  | lead-id | status    | created-on              | updated-on              |
  |---------|-----------|-------------------------|-------------------------|
  | 1       | CONVERTED | 2023-03-29T10:00:00.00Z | 2023-03-29T10:00:00.00Z |
  | 2       | CLOSED    | 2023-03-29T10:00:00.00Z | 2023-03-29T10:00:00.00Z |
  | 3       | NEW_LEAD  | 2023-03-29T10:00:00.00Z | 2023-03-29T10:00:00.00Z |

lead의 현재 status를 분석하여 잠재 고객의 처리 주기를 가정할 수 있다.

* 판매 흐름은 NEW_LEAD 상태의 잠재 고객과 함께 한다.
* 판매 제안에 관심 없는 사람은 CLOSED
* 결제가 성공하면 고객으로 전환되어 CONVERTED

이 테이블엔 현재 상태는 문서화하지만 현재 상태에 도달하기까지가 누락되어 있다.

* 상태를 변경하기 위해 얼마나 많은 전화를 걸었는지?
* 구매가 바로 이루어졌는지?

등등을 알기 어렵다. 이렇게 누락된 정보를 채우는 방법 중 하나가 이벤트 소싱을 사용하는 것이다.    
이벤트 소싱 패턴은 데이터 모델에 시간 차원을 도입한다. 애그리게이트의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지한다.  

예제를 살펴보자

```json
{
  "lead-id": 12,
  "event-id": 0,
  "event-type": "lead-initialized",
  "timestamp": "..."
},
{
"lead-id": 12,
"event-id": 1,
"event-type": "contacted",
"timestamp": "..."
},
{
"lead-id": 12,
"event-id": 2,
"event-type": "followup-set",
"timestamp": "..."
}
```

이벤트 id를 남겨서 어떤 이벤트인지 확인하자. 그리고 이벤트에는항상 버전을 남겨서 변경의 횟수를 나타낸다.  
이렇게 되면 이벤트의 특정 시점으로 엔티티의 상태를 프로젝션 할 수 있다. 버전 5가 필요하면 처음 5개의 이벤트만 적용하면 된다.  

모든 변경사항은 이벤트로 표현되어야 한다. 이벤트는 Event Store에 저장되어야 한다.

* 이벤트 소싱 도메인 모델 장점
  * 버그가 관찰 됐을 때 시점의 데이터가 모두 있어서 그 떄로 되돌릴 수 있다.
  * 심오한 통찰력?
  * 감사 로그 (시간여행이랑 같은 얘기)
  * 고급 낙관적 동시성 제어
* 단점
  * 학습 곡선
  * 모델의 진화
  * 아키텍처 복잡성
---
* 성능
  * 이벤트의 평균 수명 동안 기록될 것으로 예상되는 이벤트 수와 누적될 이벤트 목록 규모를 비교하여 예측이 필요하다.
  * 측정된 규모의 이벤트 작업의 효과를 벤치마크해야한다.
* 확장
  * id로 관리되기 때문에 샤딩하기 좋다.

# 8 아키텍처 패턴
## 계층형 아키텍처
각 계층은 top-down 으로 소통해야 한다. 상위 계층은 하위 계층에서 일어나는 일은 모르게 한다.
* 프레젠테이션 (사용자와 상호작용)
  * GUI, CLI, REST API(HTTP 가 더 맞지 않나?)
* 비즈니스 로직
  * Entity, Rule, Process
* 데이터 접근 (기술적 관심사)
  * DB, MessageBus, Object Storage 

여기에 확장하여 프레젠테이션 계층과 비즈니스 로직 계층 사이에 서비스 계층을 하나 더 넣을 수 있다.  
서비스 계층은 인터페이스가 되고 비즈니스 로직은 구현체가 된다  

## 포트와 어댑터
의존성 역전 원칙을 적용한다. bottom-up으로 소통한다.
* 비즈니스 로직 계층
  * Entity, Rule, Process
* 애플리케이션 계층
  * 액션
* 인프라스트럭처 계층
  * DB, UI, 외부 API, Meesage Bus

인프라스트럭처에 프레젠테이션과 데이터 접근 계층이 함께 있다. 비즈니스 로직 계층이 가장 깊숙히 있다.  
인프라스트럭처 계층은 어댑터(구현체)를 구현한다. 비즈니스 계층은 포트(인터페이스)를 정의하여 비즈니스 로직과 소통한다.  

## CQRS
여러 영속 모델에 시스템의 데이터를 표현할 수 있다.

### 폴리글랏 모델링
* 폴리그랏 영속성 모델
  * 여러 데이터베이스를 사용한다. 상황에 따라 최적의 DB를 사용

### 구현
* 커맨드 실행 모델
  * 시스템의 원천인 강력한 일관성을 가진 데이터를 표현하는 유일한 모델
  * 갱신 시 낙관적 동시성 지원 필요 
* 읽기 모델(프로젝션)
  * 캐시에서 언제든 다시 추출할 수 있다.
  * 수정할 수 없다. 읽기 전용이다.
* 동기식 vs 비동기식 프로젝션
  * 비동기식은 엔지니어링 난이도가 높으니, 기본적으론 동기로 하고 비동기는 일부 도입하자
* 모델분리
  * 커맨드는 데이터를 반환하도록 한다.

### 범위
전체 바운디드 컨텍스트를 위한 고수준 아키텍처 패턴이 아니다.  
기술 관심사에 따라서 아키텍처를 도입해야 한다.