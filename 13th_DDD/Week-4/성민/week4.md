# 7. 시간 차원의 모델링

이벤트 소싱 도메인 모델 패턴은 도메인 모델 패턴과 동일한 전제를 기반으로 한다. 동일한 전술적 패턴 (밸류 오브젝트, 애그리게이트, 도메인 이벤트)을 사용하고, 두 패턴은 애그리게이트의 상태를 저장하는 방식에 차이가 있다. 이벤트 소싱 도메인 모델은 이벤트 소싱 패턴을 사용해 애그리게이트 상태를 관리한다. 즉, 애그리게이트의 상태를 유지하는 대신 각 변경사항을 설명하는 도메인 이벤트를 생성하고 애그리게이트 데이터에 대한 원천 데이터로 사용한다.

## 이벤트 소싱

- 상태에 기반한 모델링을 할 경우 비즈니스 관점에서 각 리드의 현재 상태만 알 수 있다. 현재 상태가 되기 까지의 어떠한 이력도 추적할 수 없다.

**해결 방안**

- 누락된 정보를 채우는 방법 중 하나가 바로 이벤트 소싱을 사용하는 것이다.
- 이벤트 소싱 패턴은 데이터 모델에 시간 차원을 도입한다.
  - 애그리게이트의 수명 주기의 모든 변경사항을 문서화 하는 이벤트를 유지한다.
  - 각 이벤트를 적용할 때마다 버전이 증가되므로 이력을 확인할 수 있다.

### 검색

- 상태에 기반한 모델링을 하는 경우 과거 정보를 프로젝션할 수 없다. 고객이 개인 정보를 업데이트 했다면, 과거 정보를 프로젝션 할 수 없다.

**해결 방안**

- 변경을 이벤트로 저장하기 때문에 쉽게 프로젝션 할 수 있다.

### 분석

- 다른 부서에서 좀 더 분석하기 편한 리드 데이터를 요청한다고 가정해보자. 다양한 리드 중에서 후속 전화가 예약된 개수를 얻고자 한다.

**해결 방안**

- 후속 전화 이벤트가 리드 이벤트에 나타난 횟수의 카운터를 유지한다.

### 원천 데이터

- 이벤트 소싱 패턴이 작동하려면 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장되어야 한다. 이러한 이벤트는 시스템의 원천 데이터가 된다.
  - 시스템의 이벤트를 저장하는 디비는 유일하고 강력하게 일관된 저장소인 시스템의 원천 데이터이다.
  - 이벤트를 저장하는 데 사용되는 디비를 지칭하는 이름은 이벤트 스토어이다.

### 이벤트 스토어

- 이벤트 스토어는 이벤트를 수정, 삭제가 불가능하고 추가만 가능하다.
- 이벤트 소싱 패턴을 구현하려면 특정 비즈니스 엔티티에 속한 모든 이벤트를 가져오고 이벤트를 추가하는 기능이 제공되어야 한다.
  - 추가 기능에서는 낙관성 동시성 제어가 필요하다.
    - 책에서는 expectedVersion 인수로 구현함.

## 이벤트 소싱 도메인 모델

- 이벤트 소싱 도메인 모델은 애그리게이트의 수명주기를 모델링하기 위해 독점적으로 도메인 이벤트를 사용한다.
- 애그리게이트 상태에 대한 모든 변경사항은 도메인 이벤트로 표현돼야 한다.

### **이벤트 소싱 애그리게이트에 대한 작업 순서**

1. 애그리게이트의 도메인 이벤트를 로드
2. 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성
3. 애그리게이트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 도메인 이벤트를 생성
4. 새 도메인 이벤트를 이벤트 스토어에 커밋

(코드 이해하는 데 꽤 걸림… 왜 변수명을 originalVersion으로 해놨을까?)

### 장점

- 시간 여행
  - 애그리게이트의 모든 과거 상태를 복원할 수 있다. 시스템의 동작을 분석하고, 시스템의 의사결정을 검사하고, 비즈니스 로직을 최적화할 때 필요하다.
  - 소급 디버깅이라는 유스케이스로 애그리게이트에서 버그가 관측됐을 때의 상태로 정확히 되돌릴 수 있다.
- 심오한 통찰력
  - 시스템의 상태와 동작에 대한 깊은 통찰력을 제공한다
- 감사 로그
  - 법률에 따라 일부 비즈니스 도메인에서는 감사 로그가 필수인데 영속적인 도메인 이벤트는 애그리게이트 상태에 대한 강력하게 일관된 감사 로그이다.
- 고급 낙관적 동시성 제어
  - 데이터가 덮여 쓰여질 수 없으며 새로운 이벤트가 시도된 작업과 충돌하는지, 계속 진행하는게 안전할 지에 대한 비즈니스 도메인 주도 의사결정을 내릴 수 있다.

### 단점

- 학습 곡선
  - 기존 기술과 사고 방식에 차이가 있기에 시스템 구현에 학습 곡선을 고려해야 한다
- 모델의 진화
  - 이벤트는 변경할 수 없기 때문에 이벤트 스키마 변경이 어렵다.
- 아키텍처 복잡성
  - 아키텍처의 유동적인 부분이 도입되어 전체 설계가 더 복잡해질 수 있다.

## 자주 묻는 질문

### 성능

**이벤트에서 애그리게이트 상태를 재구성하면 시스템 성능에 부정적 영향을 주고 이벤트가 추가되면서 성능이 저하된다. 어떻게 작동할 수 있을까?**

애그리게이트당 10,000 개 이상의 이벤트를 구현할 경우 성능 저하가 일어나지만 대부분의 시스템에서는 100개 이벤트를 초과하지 않는다.

상태를 프로젝션 하는 것이 성능에 문제가 되는 경우는 드물지만, 스냅숏 패턴같은 다른 패턴을 적용할 수 있다.

- 프로세스는 이벤트 스토어에서 새 이벤트를 지속적으로 순회하고 해당 프로젝션을 생성하고 캐시에 저장한다.
- 애그리게이트에 대한 작업을 실행하려면 메모리 내 프로젝션이 필요하다.
  - 프로세스는 캐시에서 현재 상태의 프로젝션을 가져온다.
  - 프로세스는 이벤트 스토어에서 스냅숏 버전 이후에 발생한 이벤트를 가져온다.
  - 추가 이벤트는 메모리 내 스냅숏에 적용된다.

만 개 이상의 이벤트를 저장하지 않는 경우는 시스템을 복잡하게 만든다. 애그리게이트 경계를 다시 확인하는 것도 필요하다.

**이 모델은 엄청난 양의 데이터를 생성한다. 확장 할 수 있을까?**

모든 애그리게이트 관련 작업은 단일 애그리게이트 컨텍스트에서 수행되므로 이벤트 스토어는 애그리게이트 ID로 분할이 가능하다. 애그리게이트의 인스턴스에 속하는 모든 이벤트는 단일 샤드에 있어야 한다.

### 데이터 삭제

**물리적으로 데이터 삭제가 필요한 경우가 있을 수 있다. 가능한가?**

페이로드 패턴을 사용할 수 있다. 민감 정보를 암호화된 형식으로 이벤트에 포함시킨다. 키는 특정 애그리게이트의 ID고 값은 암호화 키이다. 민감 데이터를 삭제하는 경우 암호화 키를 삭제한다. 결과적으로 이벤트에 포함된 민감 정보에 접근할 수 없다.

### 그 외

**텍스트 파일에 로그를 작성해 감사 로그로 사용할 수 없는 이유는?**

- 실시간 데이터 처리 DB와 텍스트 파일에 동시에 쓰는 경우 오류가 발생하기 쉽다. 일관성을 유지하기 힘들다.

**상태 기반 모델을 계속 사용할 수 없지만 동일한 데이터베이스 트랜잭션에서 로그를 로그 테이블에 추가할 수 없는 이유는?**

- 인프라 관점에서 상태와 로그 레코드 간의 일관된 동기화를 제공할 수 있지만 추후 작업할 엔지니어가 적절한 로그 레코드를 추가하는 것을 잊어 버릴 수 있다.
- 일반적으로 모든 필수 정보가 올바른 형식으로 작성되도록 강제할 방법은 없다.

**상태 기반 모델을 계속 사용할 수 없지만 레코드의 스냅샷을 만들어 전용 이력 테이블에 복사하는 데이터베이스 트리거를 추가할 수 없는 이유는?**

- 수동 작업은 필요로 하지 않지만, 어떤 필드가 변경되었는 지에 대한 사실만 포함된다. 왜 필드가 변경되었는지와 같은 비즈니스 컨텍스트를 잃게 된다.

왜?에 해당하는 필드도 같이 저장하면 안됨?!

# 8. 아키텍처 패턴

## 비즈니스 로직과 아키텍처 패턴

- 비즈니스 로직은 소프트웨어에서 가장 중요한 요소다. 하지만 소프트웨어 시스템에는 다른 요소도 많다.
- 코드베이스가 처리해야 할 다양한 관심사로 인해 비즈니스 로직이 다양한 구성요소에 흩어지기 쉽다.
- 관심사를 구현할 때 엄격하게 구성하지 않으면 코드베이스의 변경이 어려워진다.
  - 유지보수 어려움
- 아키텍처 패턴은 코드베이스의 다양한 측면에 대한 구성 원칙을 도입하고 이들 사이의 명확한 경계를 제시한다.
  - 계층형 아키텍처, 포트와 어댑터, CQRS에 대해 알아본다.

## 계층형 아키텍처

- 코드베이스를 수평 계층으로 조직한다.
- 각 계층은 사용자와 상호작용, 비즈니스 로직의 구현, 데이터의 저장과 같은 기술적 관심사 중 하나를 다룬다.
- 고전적인 형태의 계층형 아키텍처는 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층의 세 가지 계층으로 구성된다.

### 프레젠테이션 계층

- 사용자와 상호작용을 하기 위한 프로그램의 사용자 인터페이스를 구현한다.

1. 그래픽 사용자 인터페이스
2. 커맨드 라인 인터페이스
3. 다른 시스템과 연동하는 프로그래밍 API
4. 메시지 브로커에서 이벤트에 대한 구독
5. 나가는 이벤트를 발행하는 메시지 토픽

이 모든 것은 시스템이 외부 환경으로부터 요청을 받고 결과를 소통하는 수단이다. 엄밀히 말하면 프레젠테이션 계층은 프로그램의 퍼블릭 인터페이스이다.

### 비즈니스 로직 계층

- 프로그램의 비즈니스 로직을 구현하고 묶는 것을 담당하고 비즈니스 의사결정을 구현한다.
  - 액티브 레코드 또는 도메인 모델과 같은 비즈니스 로직 패턴을 이 계층에서 구현한다.

### 데이터 접근 계층

- 영속성 매커니즘에 접근할 수 있게 해준다.
- 원래 패턴에서는 이 계층이 시스템의 디비를 가리키지만, 현대 시스템에서는 좀 더 넓은 범위의 책임을 가진다.
  - 혁신적인 NoSQL이 출현한 이래로 여러 데이터베이스를 사용하는 시스템이 보편화됨
  - 정보 저장용으로 전통적인 디비뿐 아니라 다양한 매체(클라우드 서비스, 메시지 버스)가 있음
  - 프로그램의 기능을 구현하는 데 필요한 다양한 써드파티와 연동하는 것을 포함.

### 계층 간 커뮤니케이션

- 계층은 톱다운 커뮤니케이션 모델에 따라 연동한다. 각 계층은 바로 아래 계층에만 의존한다.
  - 구현 관심사의 결합성을 낮추고 계층 간에 공유할 지식을 줄인다.

### 변종

- 계층형 아키텍처 패턴을 확장해서 서비스 계층을 추가하는 것을 흔히 볼 수 있다.

**서비스 계층**

- 프레젠테이션 계층과 비즈니스 로직 계층 사이의 중간 역할을 한다.
- 프레젠테이션 계층과 하위 비즈니스 로직의 결합을 제거하기 위해 이런 조율 로직들을 서비스 계층으로 이동할 수 있다.
- 서비스 계층은 논리적 경계라는 것이 중요하다.
  - 서비스 계층은 비즈니스 로직 계층으로의 관문 역할을 한다.
  - 하부 계층을 조율하는 데 필요한 것들을 감싸서 퍼블릭 인터페이스의 메서드에 상응하는 인터페이스로 노출한다.
  - 프레젠테이션 계층은 서비스 계층에서 요구하는 입력을 제공하고 결과를 호출자에게 반환하는 것만 책임진다.
- 서비스 계층을 명시적으로 갖추면 장점들이 생긴다.
  1. 동일한 서비스 계층을 여러 퍼블릭 인터페이스에서 재사용할 수 있다.
  2. 모든 관련 메서드를 한곳에 모으면 모듈화가 개선된다.
  3. 프레젠테이션 계층과 비즈니스 로직 계층의 결합도를 낮춘다.
  4. 비즈니스 기능 테스트가 쉬워진다.

### 용어

- 프레젠테이션 계층 = 사용자 인터페이스 계층
- 서비스 계층 = 애플리케이션 계층
- 비즈니스 로직 계층 = 도메인 계층 = 모델 계층
- 데이터 접근 계층 = 인프라스트럭처 계층

### 계층형 아키텍처를 사용하는 경우

- 비즈니스 로직과 데이터 접근 계층 간에는 의존성이 있다. 따라서, 비즈니스 로직이 트랜잭션 스크립트 또는 액티브 레코드 패턴을 사용하여 구현된 시스템에 계층형 아키텍처 패턴이 적합하다.
- 반면, 도메인 모델을 구현하는 데 계층형 아키텍처 패턴을 적용하는 것은 어렵다. 도메인 모델에서는 비즈니스 엔티티가 하부의 인프라스트럭처에 대해 의존성이 없어야 하고 그것을 몰라야 하기 때문이다.

## 포트와 어댑터

- 계층형 아키텍처의 단점을 극복하고 좀 더 복잡한 비즈니스 로직을 구현하는 데 적합하다.

### 용어

- 프레젠테이션 계층과 데이터 접근 계층을 인프라스트럭처 계층으로 통합했다.
  - 외부 구성요소와 연동하는 것들을 표현.

### 의존성 역전 원칙

- 의존성 역전 원칙(DPI: Dependency inversion principle)에서 비즈니스 로직을 구현하는 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다고 말한다.
  - 그러나 전통적인 계층형 아키텍처에서 비즈니스 로직 계층은 인프라스트럭처 계층에 의존한다.

! 화살표는 의존 관계를 나타냄.

- 비즈니스 로직 계층 ← 인프라스트럭처 계층
  - 위와 같은 의존 관계를 한다면 인프라스트럭처 구성요소에 의지하지 않고, 중심적인 역할을 맡는다.
- 시스템의 퍼블릭 인터페이스를 위한 관문으로서 애플리케이션 계층을 추가한다.
  - 비즈니스 로직 계층 ← 애플리케이션 계층 ← 인프라스트럭처 계층
  - 계층형 아키텍처에서의 서비스 계층처럼, 애플리케이션 계층은 시스템이 노출하는 모든 오퍼레이션을 설명하고 이를 실행할 때 시스템의 비즈니스 로직을 조율한다.
- 왜 이러한 패턴을 포트와 어댑터라고 부르는 지를 알기 위해서 인프라스트럭처 구성요소가 어떻게 비즈니스 로직과 연동하는 지 살펴봐야 한다.

### 인프라 구성요소의 연동

- 포트와 어댑터 아키텍처 핵심 목적은 인프라스트럭처 구성요소로부터 시스템의 비즈니스 로직을 분리하는 것이다.
- 인프라스트럭처 구성요소를 직접 참조하고 호출하는 대신 비즈니스 로직 계층은 인프라스트럭처 계층이 구현해야 할 ‘포트’를 정의한다. 인프라스트럭처는 ‘어댑터’를 구현한다.

### 변형

- 포트와 어댑터 아키텍처는 헥사고날, 어니언, 클린 아키텍처로 알려져있다.
- 이 모든 패턴이 비록 동일한 설계 원칙에 기반하고 동일한 구성요소를 가지며 동일한 관계를 가진다 해도 계층형 아키텍처에서와 마찬가지로 용어는 다음과 같이 다를 수 있다.
  - 애플리케이션 계층 = 서비스 계층 = 유스케이스 계층
  - 비즈니스 로직 계층 = 도메인 계층 = 핵심 계층

### 포트와 어댑터를 사용하는 경우

- 모든 기술적 관심사로부터 비즈니스 로직을 분리하는 것이 목적이므로 도메인 모델 패턴을 사용해 구현한 비즈니스 로직에 매우 적합하다.

## CQRS (Command-Query Responsibility Segregation)

- 포트와 어댑터와 동일한 비즈니스 로직과 인프라스트럭처 관심사에 기반한다.
- 하지만 시스템의 데이터 관리하는 방식에 차이가 있다. 이 패턴을 사용하면 여러 영속 모델에 시스템의 데이터를 표현할 수 있다.

### 폴리글랏 모델

- 완벽한 디비는 없다. 각 디비는 고유한 결점이 있다. 따라서, 확장성이나 일관성 또는 지원하는 질의 모델 간에 균형이 필요하다.
- 완전한 디비의 대안으로 폴리글랏 영속성 모델이 있다. 이는 다양한 디비 관련 요구사항을 구현하기 위해 여러 디비를 사용하는 것이다.
- CQRS 패턴은 이벤트 소싱과 밀접하게 관련이 있다.
  - 원래 CQRS는 이벤트 소싱 모델의 질의 한계를 극복하려고 정의됐다.
  - 즉, 한 번에 하나의 애그리게이트 인스턴스에 대한 이벤트를 질의할 수 있다.

### 구현

- CQRS 패턴은 시스템 모델의 책임을 분리시킨다. 커맨드 실행 모델과 읽기 모델 두 유형이 있다.

### 커맨드 실행 모델

- CQRS에는 시스템의 상태를 수정하는 오퍼레이션을 전담으로 수행하는 단일 모델이 있다.
  - 이 모델은 비즈니스 로직을 구현하고 규칙을 검사하며 불변성을 강화하는 데 사용된다.
- 시스템의 원천인 강력한 일관성을 가진 데이터를 표현하는 유일한 모델이다.
- 비즈니스 엔티티의 일관적 상태를 읽을 수 있어야 하고 갱신할 때 낙관적 동시성을 지원해야 한다.

### 읽기 모델(프로젝션)

- 시스템은 사용자에게 데이터를 보여주거나 다른 시스템에 정보를 제공하기 위해 필요한 만큼 모델을 정의할 수 있다.
- 읽기 모델은 캐시에서 언제든 다시 추출할 수 있는 프로젝션이다
  - 잘 구현된 CQRS는 모든 프로젝션의 모든 데이터를 삭제하고 처음부터 다시 재생성할 수 있다.
- 읽기 모델은 읽기 전용이다. 시스템의 어떠한 오퍼레이션도 읽기 모델의 데이터를 직접 수정할 수 없다.

### 읽기 모델의 프로젝션

- 읽기 모델이 작동하려면 시스템은 커맨드 실행 모델에서 변경을 모든 읽기 모델로 프로젝션해야 한다.
- 원천 테이블이 갱신되면 변경사항이 해당 뷰에 반영되어야 한다.
- 프로젝션을 생성하는 방식은 동기식, 비동기식 방식이 있다.

### 동기식 프로젝션

- 격차 해소 구독 모델을 통해 OLTP 데이터의 변경사항을 가져온다.
  - 프로젝션 엔진이 OLTP 디비로 부터 마지막에 처리했던 체크포인트 이후에 추가되거나 갱신된 레코드를 조회한다.
  - 읽어온 데이터를 이용해서 시스템의 읽기 모델을 재생성 또는 갱신한다.
  - 마지막으로 처리 레코드의 체크포인트를 저장한다.
- 격차 해소 구독이 작동하려면 커맨드 실행 모델이 추가되거나 갱신되는 모든 디비 레코드를 체크포인트로 관리해야 한다. 또한, 저장 매커니즘도 체크포인트 기반으로 레코드를 조회하는 것을 지원해야 한다.
- 동기식 프로젝션 메서드에서 새로운 프로젝션을 추가하고 기존의 것을 처음부터 다시 생성하는 것은 쉽다.
  - 기존의 것을 다시 생성하는 방법은 체크포인트를 0으로 초기화하는 것이다.

### 비동기식 프로젝션

- 커맨드 실행 모델은 모든 커밋된 변경사항을 메시지 버스에 발행한다. 시스템의 프로젝션 엔진은 메시지를 구독하고 읽기 모델을 갱신하는 데 사용한다.

### 도전과제

- 비동기식 프로젝션은 순서가 잘못되거나 중복 처리되면 읽기 모델에 일관성 없는 데이터가 프로젝션된다. 또한, 프로젝션을 처음부터 재생성하기 어렵다.
- 동기식 프로젝션을 기반으로 하고 비동기식 프로젝션을 추가하는 것을 권장한다!

### 모델 분리

- CQRS 아키텍처에서 시스템 모델이 담당하는 책임은 그 타입에 따라 분리된다.
  - 커맨드는 강한 일관성을 가진 커맨드 실행 모델에서만 동작한다.
  - 질의는 읽기 모델과 커맨드 실행 모델을 포함하여 그 어떤 시스템의 영속 상태를 직접 수정할 수 없다.
- CQRS 기반 시스템에 대한 일반적인 오해는 바로 커맨드는 데이터를 수정만 할 수 있고, 데이터를 반환해서는 안된다는 것이다.
  - 이런 접근 방식은 우발적 복잡성을 만들고 좋지 않은 사용자 경험을 유발한다.
- 커맨드는 실행이 성공했는지 또는 실패했는지를 항상 호출자에게 알려줘야 한다.
  - 정보를 전달해야 호출자가 커맨드를 어떻게 수정할지 알 수 있다.
  - 그러므로 대부분의 커맨드는 데이터를 반환해야 한다
- 유일한 단점이자 한계는 반환 데이터가 강한 일관성 모델(커맨드 실행 모델)에서 비롯되어야 한다는 것이다. 즉, 데이터가 궁극적으로 일관성을 갖는 프로젝션의 경우에는 데이터에 대한 즉각적인 갱신은 기대할 수 없다. (??)

### CQRS를 사용해야 하는 경우

- 여러 모델, 다양한 종류의 디비에 저장된 동일한 데이터와 작동할 필요가 있는 애플리케이션에 유용하다.
- 이벤트 소싱 도메인 모델에도 적합하다.
  - 이벤트 소싱은 상태에 기반한 레코드 조회가 불가능하지만 CQRS를 통해 상태에 기반한 프로젝션이 가능해진다. (??)

## 범위

- 위에서 설명한 아키텍처가 전체 바운디드 컨텍스트를 위한 고수준 아키텍처 패턴도 아니니 시스템 전체에 적용하는 구성 원칙으로 취급하면 안된다.
- 바운디드 컨텍스트에 단일 아키텍처를 강요하며 의도치않는 우발적 복잡성을 유발할 수 있다.
- 비즈니스 하위 도메인을 묶는 모델의 논리적 경계를 분명하게 정의하고 각각에 맞는 도구를 선택하는 것이 중요하다.
