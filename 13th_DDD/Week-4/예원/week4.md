## 07. 시간 차원의 모델링
- 이벤트 소싱 도메인 모델 패턴은 도메인 모델 패턴과 동일한 전제를 기반으로 같은 전술 패턴(벨류 오브젝트, 에그리게이트, 도메인 이벤트)을 사용한다.
- 이벤트 소싱 도메인 모델 패턴과 도메인 모델 패턴의 차이점은 에그리게이트 상태 저장 방식이다.
  - 이벤트 소싱 패턴은 상태 유지 대신 각 변경사항을 설명하는 도메인 이벤트를 생성하고, 애그리게이트의 원천 데이터로 사용

### 이벤트 소싱
- 데이터 모델에 시간 차원을 도입
- 누락된 정보를 채우는 방법 중 하나
- 이벤트 단일 상태만 프로젝션하는 것이 아니라, 검색/분석에도 사용된다.
  - 다만 실제 필요한 기능을 구현하려면 프로젝션된 모델을 DB에 유지해야함
- 이벤트 스토어
  - 객체상태의 모든 변경사항이 도메인 이벤트로 저장되는 DB
  - 추가만 가능
### 이벤트 소싱 도메인 모델
- 애그리게이트의 수명주기를 모델링 하기 위해 독점적으로 도메인 이벤트 사용
- 장점
  - 애그리게이트의 모든 과거 상태를 필요할 때 언제든 재구성
  - 이벤트를 다른 상태 표현 방식으로 변환할 수 있는 유연한 모델 제공
- 단점
  - 기존 기술과의 차이점
  - 모델 자체를 발전시키는 것은 어려울 수 있음
  - 전체 설계가 복잡해짐

### 결론
- 이벤트 소싱 패턴은 시스템 데이터에 대한 심오한 통찰력이 필요할 경우 적합하다.
- - - 
## 08.아키텍처 패턴
> 좀 더 넓은 맥락에서의 전술적 설계 의사결정을 알아보자.
### 비즈니스 로직과 아키텍처 패턴
- 코드베이스가 처리해야 할 다양한 관심사로 인해 비즈니스 로직이 다양한 구성요소에 흩어지기 쉽다.
- 로직 구현을 지원하고, 장기적인 유지보수를 돕기 위한 주요 아키텍처 패턴으로 "계층형 아키텍처", "포트와 어댑터", "CQRS" 이 있다.

### 계층형 아키텍처
- 코드베이스를 수평 계층으로 조직하고 프레젠테이션/비즈니스 로직/데이터 접근 계층으로 분리
- 비즈니스 로직이 트랜잭션 스크립트나 액티브 레코드 패턴을 사용할 때 적합
- 도메인 모델을 구현하는 데 활용하는건 어려움
  - 비즈니스 엔티티가 하부 인프라스트럭쳐에 대한 의존성이 없어야하고, 또 몰라야하기 때문. 
- 프레젠테이션 계층
  - 시스템이 외부 환경으로부터 요청을 받고 결과를 소통하는 수단
  - 프로그램의 퍼블릭 인터페이스
  - 서비스 계층에서 요구하는 입력을 제공하고 결과를 호출자에게 반환하는 것까지만 책임
- 서비스 계층 (필요에 의한 설계)
    - 논리적인 경계, 비즈니스 로직 계층으로의 관문 역할
- 비즈니스 로직 계층
  - 프로그램의 비즈니스 로직을 구현하고 묶는 것. 
  - 소프트웨어의 중심
- 데이터 접근 계층
  - 영속성 메커니즘에 접근할 수 있게 해줌
  - 프로그램의 기능을 구현하는 데 필요한 다양한 외부 정보 제공자와 연동하는 것 포함
- 계층간 커뮤니케이션은 top-down
- 서비스 계층의 장점
  - 장점 
    - 동일한 서비스 계층 여러 퍼블릭 인터페이스에서 재사용
    - 모듈화 개선
    - 프레젠테이션, 비즈니스 계층 결합도 낮추기

### 포트와 어댑터
- 좀 더 복잡한 비즈니스 로직을 구현하는데 적합 (도메인 모델 패턴 사용할 때)
- 의존성 역전 원칙(DIP) 적용 -> 계층형의 관계 반대 형태
  - 비즈니스 로직을 구현하는 상위 모듈은 하위수준의 모듈에 의존해선 안됨
- 핵심 목적은 인프라스트럭처 구성요소로부터 비즈니스 로직 분리하는 것.
  - 비즈니스 로직은 포트 정의
  - 인프라스트럭처가 어댑터로 구현.

### CQRS
- 여러 모델, 궁극적으로 다양한 종류의 데이터베이스에 저장된 동일 데이터와 작동할 필요가 있는 어플리케이션에 유용
- 여러 영속 모델에 시스템 데이터 표현 가능
- 이벤트 소싱과 밀접한 관련이 있음
- 시스템 모델의 책임 분리
  - 커맨드 실행 모델 : 시스템의 상태를 수정하는 오퍼레이션을 전담으로 수행
  - 읽기 모델 : 캐시에서 언제든 다시 추출할 수 있는 프로젝션
- CQRS 의 일반적인 오해는 커맨드는 데이터 수정만 가능하고, 읽기는 무조건 읽기를 써야한다는 것 => X
  - 반환 데이터가 일관성이 강한 커맨드 모델일 뿐.

### 적용 범위
- 앞선 세 패턴을 시스템 전체에 적용하는 구성 원칙으로 취급하면 안된다.
- 바운디드 컨텍스트에 단일 아키텍처를 강요하면 의도치 않은 우발적 복잡성 유발
- 우리의 목적은 실제 필요성과 비즈니스 전략에 따라 설계 의사결정을 내리는 것!