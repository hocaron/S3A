# 07. 시간 차원의 모델링


### 이벤트 소싱 도메인 모델 패턴

- 도메인 모델과 동일한 전술적 패턴(벨류 오브젝트, 에그리게이트, 도메인 이벤트)를 사용함.
- 차이는 ‘에그리게이트 상태를 저장하는 방식’ → 이벤트 소싱 패턴을 이용
- 애그리게이트의 변경사항에 대한 도메인 이벤트를 생성 → 해당 이벤트들을 애그리게이트의 원천 데이터로 사용
    - 따로 상태를 저장해 유지하지는 않는다는 것.

<br/>

### 이벤트 소싱을 들어가기 이전에 테이블 DB를 통해 상태를 저장한다고 해보자.

- 테이블만 보고
    - 현재 상태에 도달한 이력을 알 수 있는가?
    - 어떤 일이 발생했는지 분석할 수 있는가?
    - 등등 → **알 수 있는 것은 현재의 상태 뿐**
- 비즈니스 관점에서는 데이터를 분석하고, 경험을 기반으로 프로세스를 최적화하는 것이 중요
    - 상태 데이터 만으로는 어렵다!
    - 이력. 즉, 시간 차원의 모델링이 필요하다 → 이벤트 소싱

<br/>

## 이벤트 소싱 패턴

데이터 모델에 시간 차원을 도입

- 현재 상태를 반영하는 스키마 대신 애그리게이트의 수명주기의 모든 변경사항을 이벤트로 유지
- 이벤트를 모아 고객의 현재 상태, 프로세스를 알 수 있음
    - → 서비스 프로세스, 경험을 알 수 있음
- 이벤트를 통해 변경사항들을 확인할 수 있으므로 ‘시간여행’이 가능
    - 특정 시간까지의 이벤트만 모으면, 특정 시간까지의 상태를 확인할 수 있는 것
- 값 변경사항의 이력을 알 수 있다 → 이전의 값으로 검색이 들어와도 어떻게 변경됬는지 확인이 가능

<br/>

이벤트 또한 저장되어야 함. 이벤트를 저장하는데 사용되는 데이터베이스가 이벤트 스토어(Event Store)

- 이벤트 추가만 가능한 저장소로, 이벤트 수정 및 삭제가 불가능
    - 즉, 엔티티의 이벤트들을 가져오고, 추가하는 연산만 존재

<br/>

## 이벤트 소싱 도메인 모델

- 애그리게이트 상태에 대한 모든 변경사항을 도메인 이벤트로 표현하는 것
    - 프로세스
        1. 애그리게이트의 도메인 이벤트를 로드
        2. 이벤트를 비즈니스 의사결정에서 사용할 수 있는 형태로 프로젝션 → 현재 상태표현 재구성 (리하이드레이션)
        3. 애그리게이트 명령을 실행하여 새로운 도메인 이벤트 생성
        4. 새 도메인 이벤트를 이벤트 스토어에
- 사견) 결국, 이벤트를 모아 현재 상태를 그리는 것인데… → 성능 이슈가 없나? 이벤트가 쌓이면 쌓일수록 현재 상태를 구하는 것은 어려워지는 것인데.
    - 프로젝션한 현재 상태를 저장해두고, 버저닝해서 관리? → 새로운 이벤트가 올 때마다 업데이트?
    - 뒷 부분(122p)에 내용이 나옴
        - 성능 이슈가 당연히 있음. 기록될 것으로 예상되는 이벤트, 누적될 이벤트의 이벤트 규모를 예측
        - 애그리게이트 당 10,000개 이상의 이벤트가 있는 경우, 성능 저하가 눈에 띄게 나타남
        - 대다수의 시스템에서 애그리게이트의 평균 수명은 100개 이벤트를 초과하지 않음
            - ? 100개 이벤트를 어떻게 초과안하지? 이벤트 컴프레션(압축) 같은 작업(이벤트 줄이면서 결과 캐싱)을 수행하나?

<br/>

### 장점

- 시간 여행
    - 이벤트를 통해 과거 상태를 복원할 수 있다. ex) 버그가 나타났을 때로 되돌리기
- 심오한 통찰력
    - 비즈니스 프로세스, 유저행동에 대해 탐구가 가능.
    - 시스템의 상태와 동작에 대해 깊은 통찰력 제공.
    - 여러 이벤트에 대해 새로운 프로젝션이 가능 → 추가 통찰력을 위한 새로운 프로젝션 추가가 가능
- 감사 로그
    - 이벤트를 남기다보니 자동으로 감사가 됨
- 고급 낙관적 동시성 제어
    - 읽기 데이터가 기록되는 동안, 다른 프로세스에 의해 덮어 쓰여지는 경우 예외 발생
    - 기존 이벤트를 읽고, 새 이벤트를 작성하는 사이에 무슨일이 일어나는지 처리가 가능
    - 충돌하면 어떻게 행동되는가?

<br/>

### 단점

- 학습 곡선(러닝커브)
    - 팀 교육 및 새로운 사고에 익숙해져야 함
- 모델의 진화
    - 이벤트가 한번 추가되면 이벤트는 변경되기 어려움.
    - 만약 이벤트 스키마를 변경해야 한다면? 어려움
        - 사견) `컨슈머 부분의 코드를 먼저 수정해두고(추가해두고), 프로듀서 코드를 변경, 마지막으로 컨슈머의 이전 코드를 제거 하는 방향으로 진행`하면 되지 않나?
- 아키텍처의 복잡성
    - 아키텍처에 유동적인 부분이 많이 추가 됨 → 전체 설계가 복잡해짐

<br/>

데이터 삭제를 해야하는 경우엔 어떻게 할까?

- 페이로드 패턴 → 제거 될 데이터들은 암호화하여 이벤트로 전달
- 암호화 키를 외부 키-값 저장소에 저장 → 키는 특정 애그리게이트의 ID를 의미
    - 민감데이터를 제거 해야 하는 경우, 암호화 키를 제거함으로서 접근이 불가능하도록 만듦.

<br/>

# 08. 아키텍처 패턴

관심사를 구현할 때, 엄격하게 구성하지 않으면 코드베이스의 변경이 어려워진다.

- 비즈니스 로직이 변경됬을 때, 어떤 부분이 영향을 받는지 분명하지 않을 수 있다.
    - 기대치 않은 부분이 영향을 받을 수도…, 변경해야하는 부분을 놓칠 수도…
- 결국, **유지보수의 비용을 증가**시킨다.

아키텍처 패턴을 통해 코드베이스 측면에서 **구성 원칙을 도입**하고, 이들 사이에 **명확한 경계를 제시**한다.

<br/>

## 계층형 아키텍처

- 프레젠테이션 계층 → 비즈니스 로직 계층 → 데이터 접근 계층

<br/>

프레젠테이션 계층

- 사용자와 상호작용을 하기 위한 사용자 인터페이스 구현
- 외부환경으로부터 요청을 받고 결과를 소통하는 수단

<br/>

비즈니스 로직 계층

- 말그대로 비즈니스 로직이 존재하는 곳, 비즈니스 의사결정을 구현
- 엔티티, 규칙, 프로세스가 위치

<br/>

데이터 접근 계층

- 영속성 메커니즘에 접근하는 곳
- 일반적인 데이터베이스 뿐 아니라 NoSQL, Cloud 기반 오브젝트 저장소, 메시지 버스 등 다양한 저장소를 의미한다. 뿐만 아니라, 다양한 외부 정보 제공자(API, Cloud 관리형 서비스 등)와 연동하는 것을 포함함.
    - 극단적으로 예를 들어, Slack message를 저장소로 사용하면 여기서 Slack API를 사용하는 것.

<br/>

계층 간 커뮤니케이션은 탑-다운 형식. 

- 프레젠테이션 → 비즈니스 → 데이터 접근
    - 각 계층은 바로 아래 계층만 의존. 구현 관심사의 결합성을 낮춤.
    - 영속성 방법 변경? → 비즈니스 로직만 영향 받을 것. 또는 인터페이스로 구현하면 코드 변경없이 의존성 변경으로 쉽게 갈아낄 수 있을 것.
- 사견) 최근에 와서는 비즈니스 로직이 없는 간단한 CRUD 같은 경우 바로 프레젠테이션 → 데이터 접근 의존성을 가지는 경우도 있는 것 같다. 미래를 보면 좋은 것은 아닌 것 같다만…

<br/>

약간의 변화가 생기는 데, ‘서비스’ 계층의 등장

- 비즈니스 계층 로직을 모아서 조율하는 계층 → 필요한 것들을 감싸 퍼블릭 인터페이스 메서드에 상응하게 끔 구현
    - 사견) Facade (패턴) 아닌가? 한국형 구현방식/Spring에서 구현하는 방식인지는 모르겠지만, 보통 비즈니스 로직 계층을 `Service`로 두고 이를 조율하는 클래스로 `Facade`를 사용하고 있다.
- 모듈화 개선, 결합도 낮춤, 테스트 쉬워짐의 장점이 있다.

<br/>

언제 사용하나?

- 비즈니스 로직과 데이터 계층 간의 의존성
    - 트랜잭션 스크립트 또는 액티브 레코드 패턴이 적합함.
    - Q) 의존성이 있는 것과 무슨 상관이지?
- 도메인 모델에는 적용하기 어려움. 도메인 모델에서는 비즈니스 엔티티가 인프라스트럭쳐에 의존하면 안되기 때문. 비즈니스 엔티티는 도메인 모델로써만 존재.

<br/>

## 포트와 어댑터

의존성 역전 원칙

- 비즈니스 로직을 구현하는 **상위 수준의 모듈은 하위 수준의 모듈에 의존**해서는 안된다.
    - 위에서 봤듯 기존에는 비즈니스 로직 계층에서 인프라스트럭쳐(데이터 접근) 계층을 의존했다.
    - 이와 반대로 의존하는 것을 생각하면 된다. → 시스템의 인프라스트럭처 구성요소에 의존하지 않는다.
- 사견) 의존 방향을 반대로 하는 것이 이해안될 수 있는데(나도 가끔 헷갈림), **상위 수준의 모듈에서 인터페이스를 노출하고 하위 수준의 모듈에서 이를 구현하는 것**을 말한다.
    
    ![image](https://user-images.githubusercontent.com/37873745/227191031-32e6b272-1c36-4e8c-b66f-de73f2abc620.png)
    
    - 유즈케이스가 포트 인터페이스를 제공하면 인프라 쪽에서 이에 맞는 어댑터를 구현
    - ex) Spring Data JPA를 사용한다는 것? 포트만 만들면, 어댑터는 Spring Data JPA에서 만들어주는 것.

<br/>

위 그림에서 보이듯 포트와 어댑터에서는 3개의 계층을 사용함 (보이듯 의존성이 반대임)

- 비즈니스 로직 계층 ← 애플리케이션 계층 ← 인프라스트럭쳐 계층
- 헥사고날 아키텍처, 어니언 아키텍처, 클린 아키텍처로 많이 불린다.
    - 애플리케이션 계층 = 서비스 계층 = 유즈케이스 계층
    - 비즈니스 로직 계층 = 도메인 계층 = 핵심 계층
- 모든 기술적 관심사와 비즈니스 로직을 분리할 수 있어 도메인 모델 패턴을 사용한 로직에 매우 적합

<br/>

인프라와 연동

- 포트와 어댑터
    - 포트: 비즈니스 로직 계층에서 인프라스트럭처 계층이 구현해야할 것들을 정의하는 것. 인터페이스.
    - 어댑터: 인프라스트럭처에서 포트에 맞게 구현하는 것.
- 포트를 어댑터가 구현하면 프로젝트 구성 시 어떻게 되는거지?
    - 비즈니스 로직 계층에서 포트를 호출 → **의존성 주입/부트스트래핑 통해 구현된 어댑터가 사용되면서 호출**되는 것.

<br/>

## CQRS

폴리글랏 모델링

- 말그대로 폴리글랏 → 다양한 데이터 / 다양한 언어를 지원하기 위해 다양한 데이터베이스를 사용한 모델
    - 모든 경우에 적합한 완벽한 데이터베이스는 없기에 여러 데이터베이스를 사용하는 것

<br/>

CQRS

- Command Query Responsibility Segregation
    - 커맨드 실행 모델과 읽기/프로젝션 모델의 책임을 분리한 것
    - 커맨드 실행 모델: 엔티티의 상태를 수정하는 오퍼레이션
    - 읽기/프로젝션 모델: 언제든 데이터 추출할 수 있는 프로젝션. 읽기 전용.
- 원래 이벤트 소싱 모델 한계를 극복하려고 정의되었음. 물리적 데이터베이스에 머터리얼라이즈해서 유연한 질의를 사용할 수 있음(머터리얼라이즈 뷰를 사용해 질의의 결과를 미리 테이블에 저장해놓음).

<br/>

읽기 모델의 프로젝션

- 커맨드 실행 모델의 변경을 읽기 모델로 프로젝션 해놓음. (→ DB, File, In-memory cache, etc…)
- 동기식 프로젝션
    - 체크포인트를 사용하여 마지막에 처리해놓은 수행 이후의 추가/갱신 데이터를 조회
    - 체크포인트를 저장하고 관리해야 함
- 비동기식 프로젝션
    - 모든 커밋된 변경사항을 메시지 버스에 발행
    - 구독하는 프로젝션 엔진에서 이를 구독해 읽기 모델을 생성 및 반영
    - 복잡함 → 순서 잘못한 경우? 중복 처리한 경우? 데이터 재생성해야하는 경우? → 도전과제임

<br/>

모델분리

- 커맨드는 강한 일관성을 가진 커맨드 실행 모델에서만 동작함
- 질의는 읽기 모델/커맨드 실행 모델을 포함해 그 어떤 시스템에서도 영속 상태를 수정할 수 없음

<br/>

커맨드는 무조건 상태 변경만하고 질의를 못한다? → 잘못된 생각

- 커맨드 실행의 결과를 단순히 OK?만 반환 → 성공한거 맞아? 유효성 검사? 결과가 어떻게 됬는지 다시 조회해? → 비효율적임.
- 그러므로 대부분의 경우, **커맨드는 상태 변화된 데이터의 결과를 반환**해야 한다.
    - 시스템의 사용자 인터페이스에서 커맨드의 결과를 수정해서 반영해야 하는 경우
    - 즉각적인 피드백으로 좀 더 쉽게 시스템을 사용할 수 있고, 반환 값을 이용해 사용자의 다음 워크플로우에 활용할 수 있음.

<br/>

언제 사용하나?

- 여러 모델, 다양한 종류의 데이터베이스에서 작동할 필요가 있는 애플리케이션에 적합
- 다양한 영속 모델을 사용할 필요가 있는 시스템
- **Q) 어떤 시스템이 있을까?**
    - MSA로 다양한 컨텍스트, 산업을 지원하는 시스템
    - 하나의 바운디드 컨텍스트 내에서 각 도메인 컨텍스트마다 영속성 성질이 달라서 다른 영속성 모델/시스템을 사용하는 것이 적합한 경우