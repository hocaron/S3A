# 05. 간단한 비즈니스 로직 구현

<br/>

## 트랜잭션 스크립트
- 프로시저 기반으로 시스템의 비즈니스 로직 구성
  - 프로시저는 간단하고 쉬운 절차지향 스크립트로 구현
- 프로시저 구현의 요구사항은 '트랜잭션 동작'
  - 각 작업은 성공하거나/실패할 수 있음. 하지만 유효하지 않은 상태를 만들면 안됨.
  - 즉, 일관성을 유지해야 함 -> 롤백 등의 보상조치 실행
- 간단해보이지만, 고급 비즈니스 로직 구현 패턴의 기반임
  - **운영 시스템 문제는 비즈니스 로직에서 트랜잭션 동작을 잘못 구현했기 때문에 많이 발생함을 잊어서는 안됨**
- 함께 동작해야하는 작업은 하나의 트랜잭션으로 묶어서 실행함으로써 구현할 수 있음
  - `start transaction` -> 작업 -> `commit` or `rollback`
  - Spring boot에서 `@Transactional`의 동작방식처럼
- 다중 업데이트, 분산 트랜잭션 같은 상황에선 단순하게 구현할 수 없음
  - CQRS 아키텍처 패턴, 아웃백스 패턴 등을 사용해서 해결할 수 있음 -> 추후 배우도록 함

멱등성의 보장
- 만약 트랜잭션 작업을 수행하는 중 트랜잭션 문제가 아닌 네트워크 등의 이슈로 정상적인 결과를 반환하지 못하는 경우엔 어떻게 될까? (즉, 정상적으로 동작했는데 네트워크 등의 이슈로 결과를 제대로 반환하지 못한 경우)
  - 재실행(재호출) 등으로 원하지 않는 결과가 만들어 질 수도 있다
  - 이러한 문제를 막기 위해 '멱등성' 있게 구현해야만 한다 -> 두 번 이상 실행하더라도 같은 결과
- 이러한 멱등성을 구현하는 방법
  - 사용자로부터 기존의 값 데이터를 받도록 한다. (DB의 업데이트 된 정보를 이용하지 않는다)
  - 낙관적 동시성 제어를 사용한다. (조건절에 기존의 값을 사용한다)
    - JPA에서 `@Version`을 사용
  - [ETag를 이용한 mid-air collisions](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag#%EC%B6%A9%EB%8F%8C_%ED%94%BC%ED%95%98%EA%B8%B0_mid-air_collisions)

트랜잭션 스크립트의 장점은 단순함
- 단순하기에 간단한 로직?의 경우에만 사용하는 것이 좋다.
  - 단순한 지원 하위 도메인 또는 외부 시스템과 연동하기 위한 충돌방지 용으로 적합
- 핵심 하위 도메인 같은 복잡성이 필요한 곳에서는 사용하지 않아야 한다. 
  - 유지보수 불가능한 진흙 덩어리 될 것.

<br/>

## 액티브 레코드
액티브 레코드 라는 전용 객체를 이용해 복잡한 자료구조를 표현.
- 트랜잭션 스크립트로 하면 중복 코드가 많이 생성되서 힘든 경우
- 데이터베이스에 직접 접근하는 대신 트랜잭션 슼릡트가 액티브 레코드 객체를 조작해주는 방법

말이 좀 복잡하지만 단순하게 말하면 직접 데이터베이스 동작을 명시하는 것이 아니라 이를 숨김으로써 자료구조와 로직을 분리시키는 것
- ORM 같은 데이터 접근 프레임워크 역할
- 액티브 레코드 필드에는 외부 프로시저가 상태를 수정할 수 있는 getter/setter가 존재

액티브 레코드의 경우, 복잡한 자료구조를 데이터베이스 스키마에 매핑하는 복잡성을 해소함
- ORM의 예시인 JPA/Hibernate의 경우에도 Entity를 데이터베이스 스키마에 매핑해줘야 하는데 그런 예가 아닌가 하는 의문이 듬

액티브 레코드도 단순한 구현에 적합하다
- 빈약한 도메인 모델 안티패턴 -> 왜 그런가에 대한 설명은 너무 추상적으로 설명되어져 있다.
- 우발적 복잡성을 일으켜 해틀 끼칠 수 있다 -> 내부 구현이 숨겨져있어 이를 확인하지 못하면 이슈가 생길 수 있다?

<br/>

---

# 06. 복잡한 비즈니스 로직 다루기

<br/>

## 도메인 모델

복잡한 비즈니스 로직을 다루기 위한 것
- 복잡한 상태전환, 비즈니스 규칙과 불변성과 관련된 것

비즈니스 로직/요구사항이 복잡하다?
- 당연히 그냥 구현하면 규칙/로직 간에 그물 같은 의존성을 만들 수 있다.
- 액티브 레코드를 적용하면? 로직이 중복되거나 잘못된 규칙으로 인해 시스템이 망가지기 쉽다.

도메인 모델의 구현
- 행동과 데이터를 모두 포함하는 객체 모델
- 데이터베이스, 외부 시스템 구성요소 호출과 같은 인프라/기술적인 관심사를 포함해서는 안됨
  - 그렇기에 도메인 모델 객체는 `플레인 올드 오브젝트`가 된다.
  - 비즈니스 로직 상으로도 복잡하므로...

도메인 모델의 구성요소
- 벨류 오브젝트
- 애그리게이트
- 도메인 서비스

<br/>

## 벨류 오브젝트

복합적(composition)인 값에 의해 식별되는 객체
- 같은 값을 가지는 객체는 같은 의미를 가지는 객체
- 값 만으로도 표현이 되는 객체이므로 식별자가 필요 없다.

도메인 개념/객체은 원시 타입에만 의존할 필요가 없다 (해서는 안된다).
- string, int로만 타입을 구성하고 네이밍만 잘하자?
  - 유효성 검사 힘들다.
  - 유효성 검사 로직이 객체 간 중복될 수 있다.
  - 유지보수하기 어려워진다.
- 결국, 벨류 오브젝트를 사용해 의도를 명확하게 전달한다.
  - 유효성 검사 로직이 오브젝트 자체에 들어가서 하기도 쉽고, 중복도 제거된다.
  - 유비쿼터스 언어를 기반으로 구현되기에 도메인의 개념을 표현하게 된다.
  
벨류 오브젝트의 구현
- 불변의 객체로 구현 -> 필드 하나가 바뀌더라도 다른 값이 생성된다.
- 기본적으로 불변이므로 필드가 수정되는 경우, 새로운 인스턴스를 만들어 반환한다.
- 값을 기반으로 동일성 검사 함수를 만들어야 한다.

벨류 오브젝트는 가능한 모든 경우에 사용하는 것이 좋다.
- 코드의 표현력을 높여준다.
- 분산되기 쉬운 비즈니스 로직을 한 곳에 모아준다.
- 코드를 더욱이 안전하게 사용할 수 있도록 도와준다.
- 불변이기에 부작용/동시성 문제가 없다.

팀과 조율 및 컨벤션이 필요하다.
- 이러한 장점에도 클래스가 많아지는 것에 대해 불만을 가지는 팀원이 있는 경우? 어떻게 해야할지?
- 로직이 복잡해지면 엄청나게 많은 벨류 오브젝트가 생길텐데 패키지 관리는 어떻게 해야할지? 

<br/>

### 엔티티

벨류 오브젝트와 정반대. 다른 엔티티 인스턴스와 구별을 위해 식별 필드가 필요.
- 값이 같다고 동일한 인스턴스가 아니다. Ex) 사람 -> 사람의 이름, 키, 몸무게가 같다고 같은 사람이 아니다.
- 식별필드의 핵심은 당연히도 각 엔티티 인스턴스마다 고유해야 한다는 것.
  - 엔티티 생애주기 내내 불변이어야 한다.
- 벨류 오브젝트는 이러한 엔티티의 속성을 설명하는데 사용된다.

<br/>

## 애그리게이트

애그리게이트는 엔티티이지만, 단순한 엔티티가 아닌 그 이상이다. (뭔 말이야~)
- 목적은 '데이터의 일관성 보호'이다.
  - 애그리게이트 데이터는 변할 수 있기에 일관성을 유지하기 위해 해결해야하는 과제가 존재한다.
- 일관성 보호를 위해서는 애그리게이트 주변의 명확한 경계 표현이 필요하다.
  - 즉, 변경 요청에 대해 비즈니스 규칙에 위배되지 않는지 확인하는 것이 필요하다.
- 상태 변경 메서드는 퍼블릭 인터페이스 형태로 노출되며, '커맨드'라고 부른다.
  - 2가지 종류: 평범한 퍼블릭 메서드 구현, 파라미터 객체를 받는 메서드 구현
  - 퍼블릭 인터페이스를 이용해 엄격한 유횽성 검사, 규칙 및 불변성 강화 등을 수행한다. -> 비즈니스 로직이 애그리게이트 자체에 구현될 수 있도록 만들어준다.

일관성이 중요하다보니 동시성 제어가 필요하고, 중요하다.
- 가장 간단한 형태는 버전 필드를 구성해서 이를 애그리게이트에서 관리하도록 하는 것

트랜잭션의 경계역할도 한다.
- 원자적인 단일 오퍼레이션으로 트랜잭션 처리해야 한다. 
  - 즉, 상태가 수정되면 모든 변경이 커밋되거나 롤백되어야 한다.
- 모든 트랜잭션을 공유해 일관성을 유지 -> 트랜잭션 경계에 속한 비즈니스 엔티티, 벨류 오브젝트를 한데 묶는 역할


다른 애그리게이트 참조하기
- 애그리게이트가 커지면 성능과 확장 문제가 발생한다.
  - 강력한 일관성이 필요한 정보만 애그리게이트에 포함되어야 한다.
    - 시스템의 상태를 손상시킬 수 있는지 여부를 확인. 비즈니스 로직이 애그리게이트 내부에 있는가?
    - 이게 좀 어렵다.
  - 그렇지 않은 경우에는 ID로 참조하여 애그리게이트 경계에 속하지 않음을 명시해야 한다.

애그리게이트 루트
- 애그리게이트 상태는 커맨드 중 하나를 실행해서만 수정할 수 있다. 엔티티 계층 구조를 대표하는, 애그리게이트의 퍼블릭 인터페이스를 애그리게이트 루트라고 한다.
- 애그리게이트 루트의 퍼블릭 인터페이스만을 통해서 애그리게이트의 상태를 변경할 수 있다.

도메인 이벤트
- 비즈니스 도메인에서 일어나는 중요한 이벤트 설명하는 메시지
- 애그리게이트 퍼블릭 인터페이스의 일부
- 메시지/이벤트 기반의 아키텍처로 애그리게이트 간 상호작용하도록 구현하는 것을 의미하는 듯
  - publisher/subscriber

<br/>

## 도메인 서비스

복수의 애그리게이트에 관련된 비즈니스 로직
- 상태가 없는 객체로 다양한 시스템 구성요소의 호출을 조율하는 역할

하나의 트랜잭션에서 다 구현하는 것이 아니다.
- 각 애그리게이트의 호출을 조율할 뿐, 트랜잭션은 한 애그리게이트 인스턴스마다 제한되어야 한다.

<br/>

## 복잡성 관리

애그리게이트와 벨류 오브젝트는 복잡한 것을 불변성으로 감싸서 복잡성을 낮추는 역할
- 비즈니스 로직은 비즈니스 불변성을 감싸고 보호해서 결국 자유도를 줄이는 것
