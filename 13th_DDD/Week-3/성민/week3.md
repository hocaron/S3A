# 05. 간단한 비즈니스 로직 구현

### 트랜잭션 스크립트

- 트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스를 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현한다.

### 구현

- 각 프로시저는 간단하고 쉬운 절차지향 스크립트로 구현한다.
- 각 프로시저가 구현해야 하는 유일한 요구사항은 트랜잭션 동작이다.
  - 각 작업은 성공하거나 실패할 수 있지만 유효하지 않은 상태를 만들면 안 된다.
  - 트랜잭션 스크립트 실행이 실패하더라도 시스템은 오류가 발생할 때까지 변경사항을 롤백하거나 보상 조치를 실행하여 일관성을 유지해야 한다.

### 그렇게 쉽진 않다!

- 겉보기에는 단순한데 가장 틀리기 쉬운 패턴이다.

### 트랜잭션 동작 구현 실패

- users 테이블의 레코드를 업데이트하고 visitsLog 테이블에 레코드를 삽입하는 경우가 있다.
  - users 테이블의 레코드는 업데이트가 됐지만 visitsLog테이블에 레코드 삽입하는 것이 실패한다면, 시스템이 일관되지 않는 상태가 된다.
  - 이 문제는 네트워크 중단, 디비 시간 초과 혹은 교착 상태, 프로세스를 실행하는 서버의 충돌로도 발생할 수 있다.
- 두 데이터 변경을 모두 포함하는 트랜잭션을 만들어서 해결할 수 있다.
- 다중 레코드 트랜잭션을 지원하지 않는 디비에서 다중 업데이트를 하거나 분산 트랜잭션에서 통합할 수 없는 여러 개의 저장 장치로 작업하는 경우에는 상황이 더 복잡해진다.

### 분산 트랜잭션

- 최신 분산 시스템에서는 디비의 데이터를 변경한 다음 메시지 버스에서 메시지를 발행하여 시스템의 다른 컴포넌트에 변경사항을 알리는 것이 일반적이다.
  - 이 방식에서도 시스템의 일관적인 상태를 유지하는 것은 어려운 일이다.

### 암시적 분산 트랜잭션

```jsx
_db.Execute("update users set visits=visits+1 where user_id=1");
```

- 위 쿼리는 하나의 디비에 있는 하나의 테이블에서 하나의 값을 업데이트 하는 것이다. 그러나, 이것은 여전히 잠재적으로 일관성 없는 상태로 이어질 수 있는 분산 트랜잭션이다.
  - 쿼리를 호출한 외부 프로세스와 디비에 정보를 전달하기 때문에 분산 트랜잭션을 구성한다.
- 쿼리는 성공했지만 호출자에게 결과를 전달하는 데 실패하면 어떻게 될까?
  - 호출자는 실패를 가정하고 다시 호출하게 된다. 그러면 카운터 값이 잘못 증가한다.
- 트랜잭션 동작을 보장하는 한 가지 방법은 작업을 멱등성으로 만드는 것이다.
  - 사용자에게 업데이트할 카운터 값을 전달하도록 요청할 수 있다.
- 문제를 해결하는 또 다른 방법은 낙관성 동시성 제어를 사용하는 것이다.
  - 사용자는 카운터의 현재 값을 읽고 전달한다.
  - 사용자에게 전달 받은 값과 현재 값이 동일할 경우에만 카운터 값을 업데이트 한다.

### 트랜잭션 스크립트를 사용하는 경우

- 비즈니스 로직이 단순한 절차적 작업처럼 매우 간단한 문제 도메인에 효과적이다.
- 정의상 비즈니스 로직이 단순한 지원 하위 도메인에 적합하다.
- 일반 하위 도메인과 같은 외부 시스템과 연동하기 위한 어댑터로 사용하거나 충돌 방지 계층의 일부로 사용할 수도 있다.
- 트랜잭션 스크립트 패턴의 주요 장점은 단순함이다.
  - 최소한의 추상화를 도입하여 런타임 성능을 최적화하고, 비즈니스 로직을 이해하기 위한 시간을 최소화한다.
- 단순함은 단점이 될 수도 있다.
  - 비즈니스 로직이 복잡할수록 트랜잭션 간에 비즈니스 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화되지 않을 때 일관성 없는 동작이 발생한다.
- 결과적으로 핵심 하위 도메인에는 트랜잭션 스크립트를 사용하면 안된다.
  - 핵심 하위 도메인의 비즈니스 로직이 복잡한 경우 트랜잭션 스크립트 패턴이 대처할 수 없다는 문제점이 발생할 수 있다.

### 액티브 레코드

- 비즈니스 로직이 단순한 경우 사용한다.
  - 더 복잡한 자료구조에서도 비즈니스 로직이 작동할 수 있다.

### 구현

- 액티브 레코드라고 하는 전용 객체를 사용하여 복잡한 자료구조를 표현한다.
  - 액티브 레코드 객체는 객체 관계 매핑(ORM) 또는 다른 데이터 접근 프레임워크와도 관련이 있다.
  - 각 자료구조가 액티브하다는 점에서 이름이 만들어 졌다.
- 자료구조 외에도 이러한 객체는 CRUD작업도 구현한다.
- 트랜잭션 스크립트 패턴과 마찬가지로 액티브 레코드는 트랜잭션 스크립트로 시스템의 비즈니스 로직을 만든다.
- 두 패턴의 차이점은 액티브 레코드의 경우 디비에 직접 접근하는 대신 트랜잭션 스크립트가 액티브 레코드 객체를 조작한다는 것이다.
- 액티브 레코드 패턴의 목적은 메모리 상의 객체를 디비 스키마에 매핑하는 복잡성을 숨기는 것이다.
  - 영속성을 담당하는 것 외에도 액티브 레코드 객체에는 비즈니스 로직이 포함될 수 있다.
  - 즉, 액티브 레코드 객체의 고유한 기능은 자료구조와 동작(비즈니스 로직)의 분리다.
  - 일반적으로 액티브 레코드의 필드에는 외부 프로시저가 상태를 수정할 수 있게 하는 퍼블릭 게터, 세터가 있다.

### 액티브 레코드를 사용하는 경우

- 액티브 레코드는 본질적으로 디비에 대한 접근을 최적화하는 트랜잭션 스크립트이기 때문에 이 패턴은 기껏해야 사용자 입력의 유효성을 검사하는 CRUD 작업과 같은 비교적 간단한 비즈니스 로직만 지원할 수 있다.
- 지원 하위 도메인, 일반 하위 도메인과 외부 솔루션의 연동, 모델 변환 작업에 적합하다.
- 빈약한 도메인 모델 안티패턴이라고도 하며, 다시 말하면 부적절하게 설계된 도메인 모델이다.
  - 잘못된 컨텍스트에 적용하면 잠재적으로 득보다 실이 많을 수 있다.
- 이러한 맥락에서 액티브 레코드는 프레임워크가 아니라 디자인 패턴을 의미한다는 점이 중요하다.

### 실용적인 접근 방식

- 비즈니스 데이터가 중요하고 설계 및 개발되는 코드의 무결성도 보호해야 하지만 실용적인 접근 방식이 더 바람직한 몇 가지 경우가 있다.
  - 대규모로 데이터를 다루는 시스템에서는 데이터의 일관성 보장이 덜 염격할 수 있다.
- 보편적인 것은 없다. 작업 중인 비즈니스 도메인에 달려 있다.

# 06. 복잡한 비즈니스 로직 다루기

### 도메인 모델

- 도메인 모델은 복잡한 비즈니스 로직을 다루기 위한 것이다.
  - CRUD 인터페이스 대신 복잡한 상태 전환, 항상 보호해야 하는 규칙인 비즈니스 규칙과 불변성을 다룬다

### 구현

- 도메인 모델은 행동과 데이터 모두를 포함하는 도메인의 객체 모델이다.
- DDD의 전술 패턴인 애그리게이트, 밸류 오브젝트, 도메인 이벤트, 도메인 서비스는 모두 객체 모델의 구성 요소이다.
- 이 같은 모든 패턴은 비즈니스 로직을 최우선으로 다룬다는 공통 관심사가 있다.

### 복잡성

- 도메인 비즈니스 로직은 이미 본질적으로 복잡하므로 모델링에 사용되는 객체가 모델에 조금이라도 우발적 복잡성을 추가하면 안 된다.
- 모델에는 디비 또는 외부 시스템의 구성요소의 호출 구현 같은 인프라 또는 기술적인 관심사를 피해야 한다.
- 이 같은 제약에 따르면 모델의 객체는 플레인 올드 오브젝트가 된다.
  - 플레인 올드 오브젝트는 인프라 구성 요소 또는 프레임워크에 의지하지 않고 직접 협업하지 않으면서 비즈니스 로직을 구현하는 객체다.

### 유비쿼터스 언어

- 도메인 모델의 객체가 기술적 관심사가 아닌 비즈니스 로직에 집중하게 되면 바운디드 컨텍스트에서 사용하는 유비쿼터스 언어의 용어를 따르기 쉬워진다.
  - 코드에서 유비쿼터스 언어를 사용하게 하고 도메인 전문가의 멘탈 모델을 따르게 한다.

### 밸류 오브젝트

- 색(color)처럼 복합적인 값에 의해 식별되는 객체다.

### 엔티티

- 객체를 식별하기 위해 식별 필드가 필요하다.
- 불변이 아니고 변할 것으로 예상된다.
- 엔티티의 속성을 밸류 오브젝트가 설명하는 관계

### 애그리게이트

- 엔티티지만 단순한 엔티티가 아닌 그 이상의 개념
- 패턴의 목적은 데이터의 일관성을 보호하는 데 있는데 애그리게이트의 데이터는 변할 수 있기에 이를 해결하기 위한 과제가 있음을 내포함
- 모든 들어오는 변경 요청을 검사해서 그 변경이 애그리게이트의 비즈니스 규칙에 위배되지 않게 해야 한다
- 비즈니스 로직을 통해서만 애그리게이트의 상태를 변경해야 일관성이 강화된다.
- 퍼블릭 인터페이스를 노출해 상태 변경을 하는데 이 때 변경하는 메서드를 커맨드라고 한다.

### 커맨드를 구현하는 방식

- 애그리게이트 객체에 평범한 퍼블릭 메서드로 구현한다.
  - 입력값의 유효성을 검사하고 관련된 모든 비즈니스 규칙과 불변성을 강화하는 것을 담당.
  - 이와 같은 애그리게이트와 관련된 모든 비즈니스 로직은 애그리게이트 자체에 구현되게 한다.
- 갱신할 때마다 증가하는 버전 필드를 애그리게이트에서 관리한다.
  - 애그리게이트상태가 변경되기 전에 읽었던 버전과 현재 버전과 같을 경우에만 애그리게이트 인스턴스의 상태를 변경한다.
  - 쓰는 디비가 동시성 관리를 지원하는 지 확인하는 것이 중요하다.
- 모든 애그리게이트의 상태 변경은 원자적인 단일 오퍼레이션으로 트랜잭션 처리돼야 한다
- 애그리게이트의 상태 변경은 DB 트랜잭션 하나당 한 개의 애그리게이트로, 개별적으로 커밋될 수 있다
- 외부 애그리게이트를 참조할 때 ID를 이용하는 이유는 객체가 애그리게이트 경계에 속하지 않음을 명확히 하고 각 애그리게이트가 자신의 트랜잭션 경계를 갖게 보장하기 위함이다.
- 애그리게이트가 엔티티의 계층 구조를 대표하기 때문에 하나만 애그리게이트의 퍼블릭 인터페이스, 즉 애그리게이트 루트로 지정돼야 한다.

### 도메인 이벤트

- 외부에서 애그리게이트와 커뮤니케이션 할 수 있는 메커니즘이다.
  - 애그리게이트의 퍼블릭 인터페이스의 일부.
- 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지이다.
- 도메인 이벤트의 목적은 비즈니스 도메인에서 일어난 일을 설명하고 이벤트와 관련된 모든 필요한 데이터를 제공하는 것이다.
- 애그리게이트는 자신의 도메인 이벤트를 발행하며 외부에서 이 도메인 이벤트를 구독할 수 있고 그에 해당하는 자신만의 로직을 실행할 수 있다.
- 애그리게이트 또한 유비쿼터스 언어를 사용해 비 개발자 또는 도메인 전문가와 소통할 때도 동일한 언어를 기반으로 의사소통해야 한다.

### 도메인 서비스

- 복수의 애그리게이트에 관련된 비즈니스 로직을 다루게 될 경우 도메인 서비스로 로직을 구현한다.
- 비즈니스 로직을 구현한 상태가 없는 객체다.
- 한 개의 DB 트랜잭션에서 한 개의 애그리게이트 인스턴스만 수정할 수 있다는 애그리게이트 패턴의 한계를 명심해야 함.
- 도메인 서비스는 위의 한계를 극복해주는 것이 아닌 여러 애그리게이트의 데이터를 읽는 것이 필요한 계산 로직을 구현하는 데 도움을 줄 뿐이다.

### 복잡성 관리

- 시스템의 복잡성을 논의할 때 제어와 동작 예측의 어려움을 평가하는 데 관심이 있다.
  - 시스템의 자유도는 시스템의 상태를 설명하는 데 필요한 데이터 요소의 개수로 측정된다.
- 자유도를 더 많이 가질수록 다루기 어렵다.
- 복잡한 것을 불변성으로 감싸서 복잡성을 낮추는 것이 애그리게이트와 밸류 오브젝트 패턴이 하는 것이다.
