# Part 2. 전술적 설계
> 1부에서는 소프트웨어의 전략적 설계 측면에서 '무엇'과 '왜'에 대해 논의했다.
> 2부에서는 전술적 설계 측면에서 '방법'에 대해 논의한다.
- - -
## 05. 간단한 비즈니스 로직 구현
- 비즈니스 로직은 소프트웨어를 구현하는 이유이다.
- 비즈니스 로직 코드를 모델링하고 구현하는 다양한 방법을 배워보자.
- 단순한 비즈니스 로직에 적합한 패턴
    - 트랜잭션 스크립트
    - 액티브 레코드
### 트랜잭션 스크립트
트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스 로직을 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현
- 구현
    - 프로시저가 구현해야 하는 유일한 요구사항은 트랜잭션 동작
    - 각 작업은 성공하거나 실패할 수 있지만, 유효하지 않은 상태를 만들면 안됨.
    - 트랜잭션 스크립트를 올바르게 구현하지 못하면 데이터 손상을 불러일으킨다. (서비스 중단을 일으킨다 ; ;)
    - 트랜잭션 동작을 보장하는 여러가지 방법 
      - 작업의 멱등성 보장
      - 낙관적 동시성 제어(호출자가 매개변수로 넘긴 값과 비교)
- 사용 예시
    - 비즈니스 로직이 단순한 절차 작업
- 단순함이 주요 장점 => 핵심 하위 도메인에는 트랜잭션 스크립트를 사용해선 안된다. 
    - 비즈니스 로직이 복잡해지면 패턴 대체 불가능
- 여러 패턴의 기반이 됨
### 액티브 레코드
비즈니스 로직이 단순한 경우 사용하나, 좀 더 복잡한 자료구조 안에서도 작동 가능
- 구현 
    - 액티브 레코드라고 하는 전용 객체를 사용하여 복잡한 자료구조 표현
    - 데이터 접근 로직을 구현한다.
- 트랜잭션 스크립트와의 차이점 
    - 액티브 레코드는 DB에 직접 접근하지 않는 대신, 트랜잭션 스크립트가 객체를 조작함.
- 목적
    - 메모리 상의 객체를 DB 스키마에 매핑하는 복잡성 숨기는 것
    - 액티브 레코드 객체의 고유한 기능은 자료구조와 동작(비즈니스 로직)의 분리이다.
- 액티브 레코드는 본질적으로 DB 접근을 최적화하는 트랜잭션 스크립트
- 빈약한 도메인 모델 안티패턴(anemic domain model antipattern)라고도 함 == 부적절하게 설계된 도메인 모델
    - 단순한 비즈니스 로직일 때에 적합.
- "항상 그렇듯 보편적 법칙은 없다. 작업 중인 비즈니스 도메인에 달려있다."
- - -
## 06. 복잡한 비즈니스 로직 다루기
앞서 단순한 비즈니스 로직을 다루는 패턴을 보았다면, 이번엔 복잡한 비즈니스 로직에 사용되는 도메인 모델 패턴을 소개
- 도메인 모델 패턴이란?
    - 단순 CRUD 인터페이스 대신 복잡한 상태 전환, 항상 보호해야하는 비즈니스 규칙과 불변성을 다룸

- 도메인 모델은 행동(behavior)과 데이터(data) 모두를 포함하는 도메인의 객체 모델
- DDD의 전술 패턴인 **애그리게이트** / **벨류 오브젝트** / **도메인 이벤트** / **도메인 서비스** 는 모두 객체 모델의 구성 요소 
    - 전술 패턴,, DDD가 되기 위해 써먹는 패턴
- 위의 세 패턴은 모두 비즈니스 로직을 최우선으로 둔다는 공통점 가짐
- 도메인 비즈니스 로직은 이미 복잡하므로, 모델링에 사용되는 객체는 복잡하지 않아야 한다.
    - ex. DB 또는 외부 시스템 구성요소의 호출 및 구현과 같은 인프라/기술적 관심은 피하자.
    - POJO 가 되자!
### 벨류 오브젝트
```c#
class Color {
 int _red;
 int _green;
 int _blue;
}
```
- 복합적인(composition) 값에 의해 식별되는 객체
- 명시적 식별 필드가 필요 없다
- 짧은 변수 이름을 사용하더라도 의도 명확히 전달 가능 (ex CountryCode country)
- 유효성 검사 로직이 벨류 오브젝트 내에 정의되어있으므로, 값 할당 전 유효성 검사 할 필요 X
- 벨류 오브젝트 필드가 바뀌면, 개념적으로는 벨류 오브젝트의 다른 인스턴스가 생성
- 벨류 오브젝트의 동일상은 id필드나 참조 대신 값을 기반으로 하므로 equals() 오버라이드 해서 적절히 구현한다.
- 가능한 모든 경우에 사용하는게 좋다.
- 다른 객체의 속성을 표현하는 도메인의 요소에 벨류 오브젝트를 사용한다.
### 엔티티
```c#
class Person {
    public PersonId id; // 식별 필드이자 벨류 오브젝트
    public Name name;
}
```
- 벨류 오브젝트와 정반대, 명시적인 식별 필드가 필요하다
- 식별 필드의 핵심 요구사항은 각 엔티티의 인스턴스마다 고유해야 한다는 것
- 벨류 오브젝트는 엔티티의 속성을 설명한다.
- 도메인 모델의 구성요소는 아닌 이유 => 엔티티는 애그리게이트 패턴의 컨텍스트에서만 구현된다.
### 애그리게이트
- 엔티티이자 그 이상
  - 명시적 식별 필드가 필요하고, 인스턴스 생애주기 동안 상태가 변동된다.
- 목적은 데이터의 일관성을 보호하는 것
- 애그리게이트 주변에 명확한 경계를 설정해야한다. => 애그리게이트는 데이터 손상을 지양하고 일관성을 강화하는 경계.
    - 퍼블릭으로 노출된 상태 변경 메서드(커맨드)를 통해서만 변경. 
- 애그리게이트의 상태는 자신의 비즈니스 로직에 의해서만 수정되기에, 애그리게이트가 트랜잭션 경계의 역할을 함
    - 모든 상태 변경은 원자적 단일 오퍼레이션으로 트랜잭션 처리 되어야함
    - 다중 애그리게이트 트랜잭션 지원은 없다고 가정.
    - 만약 하나의 트랜잭션에서 여러 애그리게이트를 커밋해야한다면 불길불길징조
- 만약 동일 트랜잭션에서 여러 객체를 수정해야한다면? 우째야할까?
    - 엔티티 계층
      - 애그리게이트 패턴은 엔티티 계층 구조와 유사하게 모든 트랜잭션을 공유해 일관성 유지 <= 엔티티 계층이 몬데
      - 엔티티와 밸류 오브젝트를 모두 담고있음. 한데 묶는다는 점에서 "에그리게이트"
    - 다른 애그리게이트 참조하기
      - 에그리게이트 내 모든 객체는 같은 트랜잭션 경계 공유하기에 너무 커지면 성능과 확장 문제 생길 수 있음
      - 데이터의 일관성은 애그리게이트의 경계를 설계하는 데 편리한 가이드 원칙 => 강려크한 일관성이 필요할 때에만 애그리게이트 포함
      - 애그리게이트는 가능한 작게 유지하기
    - 애그리게이트 루트
      - 애그리게이트가 엔티티의 계층 구조를 대표하기에, 하나만 에그리게이트 루트(퍼블릭 인터페이스)로 지정되어야한다.
    - 도메인 이벤트
      - 외부에서 에그리에트와 소통할 수 있는 또다른 메커니즘
      - 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지
      - 목적은 비즈니스 도메인에서 일어난 일을 설명하고 관련된 모든 필요 데이터 제공하는 것
      - 애그리게이트의 퍼블릭 인터페이스의 일부
### 도메인 서비스
- 에그리게이트, 벨류 오브젝트에도 속하지 않는, 복수의 에그리게이트 관련한 로직을 다룰 때. -> DDD에선 도메인 서비스로 로직 구현 제안
- 도메인 서비스는 비즈니스 로직을 구현한 상태가 없는 객체(stateless object).
- 다양한 시스템 구성요소의 호출 조율
- 한 개의 트랜잭션이 한 개의 인스턴스를 갖는 규칙은 여전히 유효하게 작용.
- 대신 도메인 서비스는 여러 애그리게이트의 데이터를 읽는 것이 필요한 계산로직의 구현을 도움.

## 복잡성 관리
- 애그리게이트와 밸류 오브젝트 패턴이 하는 것은 복잡한 것을 불변성으로 감싸 복잡성을 낮추는 것
- 비즈니스 로직은 비즈니스 불변성을 감싸고 보호하여 자유도를 줄인다.