# [DDD] 박재민 9~10장

# 9장. 커뮤니케이션 패턴

> 바운디드 컨텍스트 간 커뮤니케이션을 용이하게 하고, 애그리게이트 설계 원칙에 의해 부과된 제한 사항을 해결하고, 여러 시스템 컴포넌트에 걸쳐 비즈니스 프로세스를 조율해보자!
> 

## 모델 변환

사용자-제공자 관계에서 권력은 업스트림 혹은 다운스트림 BC가 갖는다. 이 상황에 바운디드 컨텍스트의 모델을 변환할 때 업스트림에는 OHS를 사용하고 다운스트림에는 ACL를 사용하여 변환할 수 있다. 

### 모델의 변환 로직

1. stateful
    - 상태 보존을 위해 DB를 사용해 좀 더 복잡한 변환 로직을 다룰 수 있음
2. stateless
    - 수신 또는 발신 요청이 발행할 때 즉석에서 발생

### Stateless 모델 변환

프록시 디자인 패턴을 구현해 수신과 발신 요청을 삽입하고 소스 모델을 BC의 목표 모델에 매핑함. 이 프록시의 구현은 동기, 비동기 방식으로 구현이 가능하다

- 동기식 구현
    - 동기식 통신에 사용하는 모델을 변환하는 일반적인 방법은 바운디드 컨텍스트의 코드베이스에 변환 로직을 포함하는 것
    - 오픈 호스트 서비스에서 공용 언어로의 변환은 유입되는 요청을 처리할 때 발생하고 ACL에서는 업스트림 바운디드 컨텍스트를 호출할 때 발생
    - 경우에 따라 프록시 방식이 아닌 API 게이트웨이 패턴과 같은 외부 컴포넌트로 넘기는게 효율적이다
    - 이 방식은 API 버전을 관리하기 용이하며, 충돌 방지 계층으로도 사용이 가능하다.
- 비동기식 구현
    - message 프록시를 구현할 수 있으며 소스 바운디드 컨텍스트에서 오는 메시지를 구독하는 컴포넌트.
    - 제공자 → 모델 A → 메시지 변환기 → 모델 B → 사용자의 흐름을 갖는다
    - 관련없는 메시지를 필터링해 목표 BC의 노이즈를 줄일 수 있다

### Stateful 모델 변환

더 중요한 모델 변환의 경우 스테이트풀 변환이 필요할 수 있다

**들어오는 데이터 집계하기**

- 바운디드 컨텍스트가 들어오는 요청을 집계하고, 일괄 처리 등에 관심있다고 가정하면, 동기 및 비동기 요청 모두에 대한 집계가 필요할 수 있음
- 유입되는 데이터 집계는 API 게이트웨이를 사용해 구현할 수 없으므로 좀 더 정교한 처리가 필요
- 들어오는 데이터를 추적하고 모델 변환 로직에 영구 저장소가 필요함

**여러 요청 통합**

- 여러 요청에서 집계된 데이터를 처리해야할 수 있음
- 사용자 인터페이스가 여러 서비스에서 발생하는 데이터를 결합하는 경우의 예시가 있다
- 여러 다른 BC의 데이터를 처리하고 이를 위해 복잡한 비즈니스 로직을 구현해야 하는 BC이다

### 애그리게이트 연동

애그리게이트가 시스템의 나머지 부분과 통신하는 방법 중 하나는 도메인 이벤트를 발행하는 것이다. 외부 컴포넌트는 이런 도메인 이벤트를 구독하고 해당 로직을 실행할 수 있다. 그럼 어떻게 도메인 이벤트가 메시지 버스에 발행될까?

**애그리게이트에서 도메인 이벤트를 발행하는 것이 좋지 않은 이유**

1. 애그리게이트의 새 상태가 디비에 커밋되기 전에 이벤트가 전돨되어 구독자는 캠페인이 비활성화되었다는 알림을 받을 수 있지만 실제는 아닐 수 있다
2. 경합 조건, 후속 애그리게이트 로직으로 인해 작업이 무효화되거나 디비 트랜잭션이 롤백되어도 이벤트는 이미 발행돼 철회할 수 없다

→ 애그리게이트에서 안하고 애플리케이션 계층으로 가져와 load → change → commit의 과정을 거친 후 발행되면 신뢰할 수 있을까? **NOPE!!!!!!**

**그 이유는**

- 메시지 버스가 다운되거나 코드를 실행하는 서버가 디비 트랜잭션을 커밋한 후 이벤트를 발행하기 전에 실패하는 등의 이유로 로직을 실행하는 프로세스가 도메인 이벤트를 발행하지 못할 수 있음
- 결국에 시스템은 여전히 일관성 없는 상태로 종료될 수 있으며, 이런 극단적인 경우 아웃박스 패턴을 사용해 해결할 수 있음

### 아웃박스

**도메인 이벤트의 안정적인 발행을 보장하기 위한 아웃박스 패턴의 알고리즘**

```
1. 업데이트된 애그리게이트의 상태와 새 도메인 이벤트는 모두 동일한 원자성 트랜잭션으로 커밋된다.
2. 메시지 릴레이는 데이터베이스에서 새로 커밋된 도메인 이벤트를 가져온다.
3, 릴레이는 도메인 이벤트를 메시지 버스에 발행한다
4. 성공적으로 발행되면 릴레이는 이벤트를 데이터베이스에 발행한 것으로 표시하거나 완전히 삭제한다,
```

- 관계형 디비를 사용할 때 두 개의 테이블에 원자적으로 커밋하고 메시지를 저장하기 위한 전용 테이블을 사용하는 것이 좋다.
- 다중 문서 트랜잭션을 지원하지 않는 NoSQL 디비를 사용할 때 전달될 도메인 이벤트는 애그리게이트 레코드에 포함되어야 한다.
- 적어도 한 번은 메시지 배달을 보장한다는 점에 유의해야 한다. 메시지를 발행한 후 릴레이가 실패했지만 디비에 발행한 것으로 표시하기 전에 릴레이가 실패하면 다음 이터레이션에서 같은 메시지가 다시 발행된다.

### 발행되지 않는 이벤트 가져오기

발행 릴레이는 pull 기반, push 기반 방식으로 새 도메인 이벤트를 갖고올 수 잇다.

1. Pull 방식 (발행자 풀링)
    - 릴레이는 발행되지 않은 이벤트에 대해 DB에 계속 질의 가능. 지속적인 풀링으로 인한 디비 부하를 피하려면 인덱싱 필수
2. Push 방식 (트랜잭션 로그 추적)
    - 디비의 기능을 활용해 새 이벤트 추가 시마다 발행 릴레이를 호출
    - 일부 NoSQL 디비는 커밋된 변경사항을 이벤트 스트림으로 노출하기도 한다

## 사가

- 오래 지속되는 비즈니스 프로세스이며, 시간 측면이 아닌 트랜잭션 측면에서 보는 것. 즉, 여러 트랜잭션에 걸쳐 있는 비즈니스 프로세스임
- 관련 컴포넌트에서 발생하는 이벤트를 수신하고 다른 컴포넌트에 후속 커맨드를 실행
- 실행 단계 중 하나가 실패하면 사가는 시스템 상태를 일관되게 유지하도록 적절한 보상 조치를 내리는 일을 담당
- 상태관리가 필요한 사가도 있고 아닌것도 있음

### 보상 조치 (보상 트랜잭션)

기본 트랜잭션에서 오류가 발생할 때 발생한 문제를 해결하는 데 사용되는 트랜잭션이며, 이를 통해 기본 트랜잭션의 롤백 없이 문제 해결이 가능하다

보상 트랜잭션은 기본 트랜잭션의 반대 방향으로 실행되며 기본 트랜잭션에서 변경한 데이터를 되돌리는 역할을 담당한다!

### 일관성

- 사가 패턴이 다중 컴포넌트의 트랜잭션을 조율하지만 관련 컴포넌트의 상태는 궁극적으로 일관성을 갖는다.
- 사가가 관련 커맨드를 실행한다고 해도 두 개의 트랜잭션은 원자적으로 간주되지 않아 모두 성공 혹은 실패할 수 없다. 그러니, 남용하진 말자!

### 프로세스 관리자

시퀀스의 상태를 유지하고 다음 처리 단계를 결정하는 중앙 처리 장치

- 단일 소스 이벤트에 바인딩 될 수 없다.
- 대부분의 경우, 사가 패턴은 여러 MS 간에 데이터 일관성을 유지하는 데 사용되며, 단일 서비스 내에서 실행되는 비즈니스 프로세스를 정의하고 실행하는 데 사용됨

# 10장. 휴리스틱 설계

## 휴리스틱

완벽한 것을 보장하지 않지만 당면에 목표에 부합할 만큼의 경험에 기반한 규칙이며, 수많은 단서에 내재된 노이즈를 무시하고 가장 중요한 단서에서 느껴지는 압도적인 힘에 집중해 효과적으로 문제를 해결하는 접근방법이다.

### 바운디드 컨텍스트

- 기능을 원하는 크기에 최적화해 모델링하는 것보다 모델의 어떤 기능이 포함되는 크기대로 모델링하는 것이 좋다
- BC를 설계할 때는 경계를 넓게 해서 시작하고 도메인 지식이 쌓이면 좁히자
- 핵심 하위 도메인을 포함하는 BC를 설계할 때 그 핵심 도메인이 가장 빈번히 상호작용하는 다른 도메인을 포함하면 예측하지 못한 변경으로 부터 스스로를 보호할 수 있음

### 비즈니스 로직 구현 패턴

**비즈니스 로직을 다루는 방법**

1. 트랜잭션 스크립트
2. 액티르 레코드
3. 도메인 모델
4. 이벤트 소싱 도메인 모델 패턴

**비즈니스 로직의 적절한 구현 패턴을 선택하기 위한 질문**

- 하위 도메인이 금전 혹은 통화 트랜잭션을 추적하거나, 일관된 감사 로그를 제공하거나, 비즈니스에서 하위 도메인의 동작에 대한 심층적 분석을 요청하는가?
    - Yes: 이벤트 소싱 도메인 모델
    - No: 하위 도메인의 비즈니스 로직이 복잡한가?
        - Yes: 도메인 모델을 구현
        - No: 하위 도메인이 복잡한 자료구조를 포함하는가?
            - Yes: 액티브 레코드 패턴
            - No: 트랜잭션 스크립트
- 복잡한 비즈니스 로직과 간단한 비즈니스 로직의 차이점을 정의하는 데도 또 다른 휴리스틱 사용이 가능하다
    - 일반적으로 복잡한 비즈니스 로직은 복잡한 비즈니스 규칙, 불변성, 알고리즘을 포함한다
    - 간단한 접근 방법은 주로 입력을 검증하는 것이다!
- 비즈니스 로직의 구현 패턴을 결정하는 것은 하위 도메인 유형에 대한 가정을 검증하는 방법

## 아키텍처 패턴

이전 장에서 봤듯이 계층형, 포트와 어댑터, CQRS 등이 있다.

- 각 패턴이 의도한 비즈니스 로직 구현 패턴을 알면 선정이 쉽다!
    - 이벤트 소싱 도메인 모델은 CQRS가 필요하다. 그렇지 않다면 시스템은 데이터 질의 옵션이 극심하게 제한돼 자신의 ID만으로 단일 인스턴스를 가져와야 함
    - 도메인 모델은 포트와 어댑터가 필요하다. 계층형에서는 영속성에 대한 고려 없이 애그리게이트와 VO를 만들기 어려움
    - 액티브 레코드 패턴은 애플리케이션 계층을 추가한 계층형 아키텍처가 필요함. 이는 액티브 레코드를 제어하는 로직을 위한 것
    - 트랜잭션 스크립트 패턴은 세 개의 계층으로만 이어진 최소한의 계층형 아키텍처를 적용할 수 있음
- CQRS는 이벤트 소싱 도메인 모델에 도움이 될 뿐 아니라 하위 도메인이 여러 영속 모델에 있는 데이터를 표현할 필요가 있는 경우에 도움이 됨

## 테스트 전략

- 비즈니스 구현 패턴과 아키텍처 패턴의 모든 지식은 코드베이스의 테스트 전략을 선택할 때 활용이 가능
- 피라미드형
    - 단위 테스트를 강조. 통합 테스트는 별로 없으며, E2E는 더더욱 없음
    - 애그리게이트와 VO 도메인 모델 패턴을 잘 지원함
- 다이아몬드형
    - 통합 테스트에 가장 집중
- 역전형 피라미드형
    - E2E에 집중
    - 트랜잭션 스크립트 패턴에 가장 어울림
- 액티브 레코드 패턴이 사용되면 시스템의 비즈니스 로직은 서비스 계층과 비즈니스 로직 계층에 흩어지므로 두 계층의 연동에 중점을 둔다면 다이아몬드형 테스트를 선택하자

## 전술적 설계 의사결정 트리

하위 도메인 유형을 식별하고 의사 결정 트리를 참조하는 것은 필수적인 설계 의사결정을 위한 시작점이다.

- 고정된 규칙이 아닌 휴리스틱을 반복하는 것이 중요!
- 자신만의 의사 결정 트리를 만들어보자!