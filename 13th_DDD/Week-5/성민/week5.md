# 09. 커뮤니케이션 패턴

### 모델 변환

- 사용자-제공자 관계에서 권력은 업스트림(제공자) 또는 다운스트림(사용자) 바운디드 컨텍스트가 갖는다.
- 다운스트림 바운디드 컨텍스트가 업스트림 바운디드 컨텍스트 모델을 따를 수 없다고 가정하자.
  - 이 경우 바운디드 컨텍스트의 모델을 변환하여 커뮤니케이션을 용이하게 하는 것 보다 더 정교한 기술 솔루션이 필요하다.
- 다운스트림 바운디드 컨텍스트는 충돌 방지 계층(ACL)을 사용하여 업스트림 바운디드 컨텍스트의 모델을 필요에 맞게 조정한다.
- 업스트림 바운디드 컨텍스트는 오픈 호스트 서비스(OHS)의 역할을 하고 연동 관련 공표된 언어를 사용하여 구현 모델에 대한 변경으로부터 사용자를 보호할 수 있다.
- 모델의 변환 로직은 stateless, statefull이 될 수 있다.
  - stateless 변환은 수신(OHS) 또는 발신(ACL) 요청이 발행할 때 즉석에서 발생한다.
  - statefull 변환은 상태 보존을 위해 디비를 사용하여 좀 더 복잡한 변환 로직을 다룰 수 있다.

### Stateless 모델 변환

- Proxy design pattern을 구현하여 수신과 발신 요청을 삽입하고 소스 모델을 바운디드 컨텍스트의 목표 모델에 매핑한다.
  - proxy 구현은 바운디드 컨텍스트가 동기식으로 통신하는 지 또는 비동기식으로 통신하는 지에 따라 다르다.
- 동기
  - 동기식 통신에 사용하는 모델을 변환하는 일반적인 방법은 바운디드 컨텍스트의 코드베이스에 변환 로직을 포함하는 것이다.
    - 오픈 호스트 서비스에서 공용 언어로의 변환은 유입되는 요청을 처리할 때 발생하고 충돌 방지 게층에서는 업스트림 바운디드 컨텍스트를 호출할 때 발생한다.
  - 경우에 따라 변환 로직을 proxy가 아닌 API 게이트웨어 패턴과 같은 외부 컴포넌트로 넘기는 것이 더 효율적일 수 있다.
    - 오픈 호스트 서비스를 구현할 때 API 게이트웨이는 내부 모델을 통합에 최적화된 공표된 언어로 변환하는 역할을 한다.
    - API 버전도 관리할 수 있다.
    - 충돌 방지 계층으로도 사용이 가능하다.
    - 위에 것들을 교환 컨텍스트라고도 부른다.
- 비동기
  - message proxy를 구현할 수 있다. 소스 바운디드 컨텍스트에서 오는 메시지를 구독하는 중개 컴포넌트다. 필요한 모델 변환을 적용하고 결과 메시지를 대상 구독자에게 전달한다.
  - 제공자 → 모델 A → 메시지 변환기 → 모델 B → 사용자
  - 관련 없는 메시지를 필터링하여 목표 바운디드 컨텍스트의 노이즈를 줄일 수 있다.
  - 오픈 호스트 서비스를 구현할 때 비동기식 모델 변환은 반드시 필요하다.
    - 도메인 이벤트가 있는 그대로 발행되게 허용하여 바운디드 컨텍스트의 구현 모델을 노출하는 것은 흔한 실수다.
    - 비동기 변환을 사용하면 도메인 이벤트를 가로채서 공표된 언어로 변환할 수 있어 구현 상세를 캡슐화 한다.
    - 메시지를 공표된 언어로 변환하면 바운디드 컨텍스트의 내부 요구사항을 위한 private event와 public event를 구분할 수 있다. (??)
    - 애그리게이트 → 도메인 이벤트 → 오픈 호스트 서비스 → 공표된 언어 → 다운스트림

### Statefull 모델 변환

- 더 중요한 모델 변환의 경우 필요할 수 있다.
- 들어오는 데이터 집계하기
  - 바운디드 컨텍스트가 들어오는 요청을 집계하고 성능 최적화를 위해 일괄 처리에 관심이 있다고 가정한 경우, 동기와 비동기 요청 모두에 대해 집계가 필요할 수 있다.
  - 유입되는 데이터를 집계하는 모델 변환은 API 게이트웨이를 사용하여 구현할 수 없으므로 좀더 정교한 처리가 필요하다.
  - 들어오는 데이터를 추적하고 그에 따라 처리하려면 변환 로직에 영구 저장소가 필요하다.
- 여러 요청 통합
  - 여러 요청에서 집계된 데이터를 처리해야 할 수도 있다.
    - 이에 대한 일반적인 예는 사용자 인터페이스가 여러 서비스에서 발생하는 데이터를 결합해야 하는 프론트엔드를 위한 백엔드 패턴이다.
    - 여러 다른 컨텍스트 데이터를 처리하고 이를 위해 복잡한 비즈니스 로직을 구현해야 하는 바운디드 컨텍스트다.
      - 이 때는 다른 바운디드 컨텍스트에서 데이터를 집계하는 충돌 방지 계층을 바운디드 컨텍스트 전면에 배치해서 복잡성을 분리할 수 있다. (p.154)

### 애그리게이트 연동

- 애그리게이트가 시스템의 나머지 부분과 통신하는 방법 중 하나는 도메인 이벤트를 발행하는 것이다.
- 외부 컴포넌트는 이러한 도메인 이벤트를 구독하고 해당 로직을 실행할 수 있다. 그렇다면 어떻게 도메인 이벤트가 메시지 버스에 발행될까?
- 애그리게이트에서 바로 도메인 이벤트를 발행하는 것은 두 가지 이유로 좋지 않다.
  - 애그리게이트의 새 상태가 디비에 커밋되기 전에 이벤트가 전달된다. 그렇다면, 구독자는 캠페인이 비활성화되었다는 알림을 받을 수 있지만 실제 캠페인 상태와 모순될 수 있다.
  - 경합 조건, 후속 애그리게이트 로직으로 인해 작업이 무효화되거나 단순히 디비 트랜잭션이 롤백되더라도 이벤트는 이미 발행되어 구독자에게 전달되며 철회할 방법이 없다.
- 그럼 애그리게이트에서 안하고 애플리케이션 계층으로 가져와 load → change → commit 과정을 먼저 거친 후 도메인 이벤트가 메시지 버스에 발행된다면 신뢰할 수 있을까?
  - no!!
  - 어떤 이유로 로직을 실행하는 프로세스가 도메인 이벤트를 발행하지 못할 수 있다.
    - 메시지 버스가 다운되었을 수도 있다.
    - 코드를 실행하는 서버가 디비 트랜잭션을 커밋한 직후 이벤트를 발행하기 전에 실패할 수도 있다.
  - 결국에 시스템은 여전히 일관성 없는 상태로 종료된다.
  - 이런 극단적인 경우는 아웃박스 패턴을 사용하여 해결할 수 있다.

### 아웃박스

- 아래 알고리즘들을 사용하여 도메인 이벤트의 안정적인 발행을 보장한다.
  - 업데이트된 애그리게이트의 상태와 새 도메인 이벤트는 모두 동일한 원자성 트랜잭션으로 커밋된다.
  - 메시지 릴레이는 디비에서 새로 커밋된 도메인 이벤트를 가져온다.
  - 릴레이는 도메인 이벤트를 메시지 버스에 발행한다.
  - 성공적으로 발행되면 릴레이는 이벤트를 디비에서 발행한 것으로 표시하거나 완전히 삭제한다.
- 관계형 디비를 사용할 때 두 개의 테이블에 원자적으로 커밋하고 메시지를 저장하기 위한 전용 테이블을 사용하는 디비의 기능을 활용하는 것이 좋다.
- 다중 문서 트랜잭션을 지원하지 않는 NoSQL 디비를 사용할 때 전달될 도메인 이벤트는 애그리게이트 레코드에 포함되어야 한다.
- 아웃박스 패턴은 적어도 한 번은 메시지 배달을 보장한다는 점에 유의해야 한다. 메시지를 발행한 후 릴레이가 실패했지만 디비에 발행한 것으로 표시하기 전에 릴레이가 실패하면 다음 이터레이션에서 같은 메시지가 다시 발행된다. (???)

### 발행되지 않은 이벤트 가져오기

- 발행 릴레이는 pull 기반 또는 push 기반 방식으로 새 도메인 이벤트를 가져올 수 있다.
  - pull: 발행자 폴링
    - 릴레이는 발행되지 않은 이벤트에 대해 데이터베이스를 지속해서 질의할 수 있다. 지속적인 폴링으로 인한 디비 부하를 최소화하려면 인덱스가 있어야 한다.
  - push: 트랜잭션 로그 추적
    - 디비의 기능을 활용하여 새 이벤트가 추가될 때마다 발행 릴레이를 호출할 수 있다.
    - 예를 들어, 일부 관계형 디비에는 트랜잭션 로그를 추적하여 업데이트/삽입된 레코드에 대한 알림을 받을 수 있다.
    - 일부 NoSQL 디비는 커밋된 변경사항을 이벤트 스트림으로 노출하기도 한다.

도메인 이벤트의 안정적인 발행을 활용하여 애그리게이트 설계 원칙으로 인해 발생한 몇 가지 제한 사항을 극복할 수 있는 방법을 살펴보자.

- 핵심 애그리게이트 설계 원칙 중 하나는 각 트랜잭션을 애그리게이트의 단일 인스턴스로 제한하는 것이다.
- 그러나 여러 애그리게이트에 걸쳐 있는 비즈니스 프로세스를 구현해야 하는 경우가 있다.

### 사가

- 오래 지속되는 비즈니스 프로세스다.
  - 시간 측면이 아닌 트랜잭션 측면에서 보는 것이다.
  - 즉, 여러 트랜잭션에 걸쳐 있는 비즈니스 프로세스를 말한다.
- 관련 컴포넌트에서 발생하는 이벤트를 수신하고 다른 컴포넌트에 후속 커맨드를 실행한다.
- 실행 단계 중 하나가 실패하면 사가는 시스템 상태를 일관되게 유지하도록 적절한 보상 조치를 내리는 일을 담당한다.
- 상태 관리가 필요한 사가도 있고 아닌 것도 있다.
  - 예를 들어, 실행된 작업을 추적하여 실패 시 적절한 보상 조치를 실행할 수 있다,
  - 사가는 이벤트 소싱 애그리게이트로 구현되어 수신된 이벤트와 실행된 커맨드의 전체 기록을 유지할 수 있다.
  - 그러나, 커맨드 실행 로직은 도메인 이벤트가 아웃박스 패턴으로 전달하는 방식과 유사하게 사가 패턴 자체에서 벗어나 비동기적으로 실행한다.

### 보상 조치(보상 트랜잭션)

- 보상 트랜잭션이란 기본 트랜잭션에서 오류(책에서는 퍼블리셔가 거부한 경우로 예시가 나와있음)가 발생할 때 발생한 문제를 해결하는 데 사용되는 트랜잭션이다. 이를 통해 기본 트랜잭션의 롤백 없이 문제를 해결할 수 있다.
- 보상 트랜잭션은 기본 트랜잭션의 반대 방향으로 실행되며 기본 트랜잭션에서 변경한 데이터를 되돌리는 역할을 담당한다.

### 일관성

- 사가 패턴이 다중 컴포넌트의 트랜잭션을 조율하기는 하지만 관련된 컴포넌트의 상태는 궁극적으로 일관성을 갖는다.
- 사가가 관련 커맨드를 실행한다고 해도 두 개의 트랜잭션은 원자적으로 간주되지 않으므로 모두 성공하거나 실패할 수 없다.
- 사가를 남용하진 말자

### 프로세스 관리자

- 시퀀스의 상태를 유지하고 다음 처리 단계를 결정하는 중앙 처리 장치로 정의한다.
- 사가에 올바른 동작 과정을 선택하는 if-else문이 있다면 아마도 프로세스 관리자일 것이다.
- 프로세스 관리자는 단일 소스 이벤트에 바인딩될 수 없다.
- 대부분의 경우, 사가 패턴은 여러 개의 마이크로서비스 간에 데이터 일관성을 유지하는 데 사용되며, 프로세스 관리자는 단일 서비스 내에서 실행되는 비즈니스 프로세스를 정의하고 실행하는 데 사용된다.

# 10. 휴리스틱 설계

### 휴리스틱

- 완벽한 것을 보장하지 않지만 당면한 목적에 충분할 만큼의 경험에 기반한 규칙이다.
- 휴리스틱을 사용하는 것은 수많은 단서에 내재된 노이즈를 무시하면서도 가장 중요한 단서에서 느껴지는 압도하는 힘에 집중하려 효과적으로 문제를 해결하는 접근법이다.

### 바운디드 컨텍스트

- 기능을 원하는 크기에 최적화해서 모델링하는 것보다 모델의 어떤 기능이 포함하는 크기대로 모델링하는 것이 좋다.
- 바운디드 컨텍스트를 설계할 때는 경계를 넓게 해서 시작하고 도메인 지식이 쌓이게 되면 필요에 따라 좁혀 나가자.
- 핵심 하위 도메인을 포함하는 바운디드 컨텍스트를 설계할 때 그 핵심 도메인이 가장 빈번하게 상호작용하는 다른 하위 도메인을 포함하면 예측하지 못한 변경으로부터 스스로를 보호할 수 있다.

### 비즈니스 로직 구현 패턴

- 비즈니스 로직을 다루는 방법은 아래와 같다.
  - 트랜잭션 스크립트
  - 액티브 레코드
  - 도메인 모델
  - 이벤트 소싱 도메인 모델 패턴
- 비즈니스 로직의 적절한 구현 패턴을 선택하기 위한 효과적인 휴리스틱은 다음과 같이 질문을 해보는 것이다.
  - 하위 도메인이 금전 또는 통화의 트랜잭션을 추적하거나, 일관된 감사 로그를 제공하거나, 또는 비즈니스에서 하위 도메인의 동작에 대한 심층적인 분석을 요청하는가? 그렇다면 이벤트 소싱 도메인 모델을 적용한다. 그렇지 않다면
  - 하위 도메인의 비즈니스 로직이 복잡한가? 그렇다면 도메인 모델을 구현한다. 그렇지 않다면
  - 하위 도메인이 복잡한 자료구조를 포함하는가? 그렇다면 액티브 레코드 패턴을 사용한다. 그렇지 않다면
  - 트랜잭션 스크립트를 구현한다.
- 복잡한 비즈니스 로직과 간단한 비즈니스 로직의 차이점을 정의하는 데도 또 다른 휴리스틱을 사용할 수 있다.
  - 일반적으로 복잡한 비즈니스 로직은 복잡한 비즈니스 규칙, 불변성, 알고리즘을 포함한다.
  - 간단한 접근 방법은 주로 입력을 검증하는 것이다. (??)
- 비즈니스 로직의 구현 패턴을 결정하는 것은 하위 도메인 유형에 대한 가정을 검증하는 방법이다.
- 가정하고 선택한 구현 패턴이 정답이 아닐 수 있다. 이러한 상황은 하위 도메인과 비즈니스 도메인에 대한 추측을 다시 되돌아보는 좋은 기회가 된다.
- 핵심 하위 도메인의 경쟁력은 반드시 기술적인 것이 아니다.

### 아키텍처 패턴

- 계층형 아키텍처, 포트와 어댑터, CQRS 등이 있다.
- 각 아키텍처 패턴이 의도한 비즈니스 로직 구현 패턴을 알면 쉽게 아키텍처 패턴을 선정할 수 있다.
  - 이벤트 소싱 도메인 모델은 CQRS가 필요하다. 그렇지 않으면 시스템은 데이터 질의 옵션이 극심하게 제한되어 자신의 ID만으로 단일 인스턴스를 가져와야 한다.
  - 도메인 모델은 포트와 어댑터 아키텍처가 필요하다. 계층형 아키텍처에서는 영속성에 대한 고려 없이 애그리게이트와 밸류 오브젝트를 만들기 어렵다.
  - 액티브 레코드 패턴은 애플리케이션(서비스) 계층을 추가한 계층형 아키텍처와 잘 어울린다. 이는 액티브 레코드를 제어하는 로직을 위한 것이다.
  - 트랜잭션 스크립트 패턴은 세 개의 계층만으로 이어진 최소한의 계층형 아키텍처를 적용하여 구현할 수 있다.
- CQRS 패턴은 이벤트 소싱 도메인 모델에 도움이 될 뿐만 아니라 하위 도메인이 여러 영속 모델에 있는 데이터를 표현할 필요가 있는 경우에도 도움이 된다.

### 테스트 전략

- 비즈니스 구현 패턴과 아키텍처 패턴의 모든 지식은 코드베이스의 테스트 전략을 선택할 때 휴리스틱으로써 활용할 수 있다.
- 피라미드형 테스트
  - 단위 테스트를 강조한다. 통합 테스트는 별로 없다. 엔드-투-엔드 테스트는 더더욱 없다.
  - 애그리게이트와 밸류 오브젝트 도메인 모델 패턴을 모두 잘 지원한다.
- 다이아몬드형 테스트
  - 통합 테스트에 가장 집중한다.
  - 액티브 레코드 패턴이 사용되면 시스템의 비즈니스 로직은 서비스 계층과 비즈니스 로직 계층에 흩어지므로 두 계층의 연동에 중점을 둔다면 다이아몬드형 테스트가 효과적인 선택이다.
- 역전된 피라미드형 테스트
  - 엔드-투-엔드 테스트에 가장 집중한다.
  - 트랜잭션 스크립트 패턴에 가장 어울린다.

### 전술적 설계 의사결정 트리

- 하위 도메인 유형을 식별하고 의사 결정 트리를 참조하는 것은 필수적인 설계 의사결정을 위한 시작점이다.
- 고정된 규칙이 아닌 휴리스틱을 반복하는 것이 중요하다.
- 자신만의 의사 결정 트리를 만들자.
