# 프로듀서의 내부 동작 원리와 구현

* 프로듀서의 기본 역할은 소스에 있는 메시지들을 카프카의 토픽으로 전송하는 것이다.
* 전송하려는 메시지들은 프로듀서의 send() 메소드를 통해 시리얼라이저, 파티셔너를 거쳐 카프카로 전송된다.

### 5.1 파티셔너
* 카프카의 토픽은 성능 향상을 위한 병렬 처리가 가능하도록 하기 위해 파티션으로 나뉘고 최소 하나 또는 둘 이상의 파티션으로 구성된다.
* 프로듀서는 토픽으로 메시지를 보낼 때 해당 토픽의 어느 파티션으로 메시지를 보내야 할지를 결정해야 하는 데, 이 때 사용하는 것이 파티셔너이다.
    * 프로듀서가 파티션을 결정하는 알고리즘은 기본적으로 메시지의 키를 해시 처리해 파티션을 구성하는 방식을 사용한다.
    * 파티션 수가 변경되면 메시지의 키와 매핑된 해시 테이블도 변경된다.
* 메시지의 키를 이용해 카프카로 메시지를 전송하는 경우, 관리자의 의도와 다르게 메시지 전송이 될 수 있으므로 되도록 파티션 수를 변경하지 않는 것을 권장한다.

### 5.1.1 라운드 로빈 전략
* 메시지의 키 값은 필숫값이 아니므로 키 값을 지정하지 않는다면 키 값은 null이 되고, 라운드 로빈 알고리즘을 사용해 프로듀서는 목적지 토픽의 파티션들로 레코드들을 랜덤 전송한다.
* 배치 전송 시 라운드 로빈 전략을 사용한다면 배치와 압축의 효과를 얻지 못할 수 있다.
* 그래서 스티키 파티셔닝 전략이 나온다.

### 5.1.2 스키닝 파티셔닝 전략
* 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략을 말한다.

### 5.2 프로듀서의 배치
* 장점이 많지만 카프카를 사용하려는 목적에 따라 처리량을 높일 지, 지연 없는 전송을 할 지 선택해야 한다.
* 높은 처리량을 목표로 한다면 buffer.memory의 크기는 batch.size보다 커야 한다.
  * 최소 3배 이상 추천

### 5.3 중복 없는 전송
* 적어도 한 번 전송은 메시지 손실 가능성은 없지만 중복 가능성이 존재하고, 최대 한 번 전송은 메시지 손실 가능성은 있지만 메시지 중복 가능성은 없다.
* 카프카 0.1.1 버전부터 중복 없는 전송을 지원한다.
* PID와 메시지 번호를 비교해서 중복을 확인한다.
  * PID는 프로듀서에 의해 자동 생성 된다.
* 프로듀서가 보낸 메시지의 시퀀스 번호가 브로커가 갖고 있는 시퀀스 번호보다 정확하게 하나 큰 경우가 아니라면 브로커는 프로듀서의 메시지를 저장하지 않는다.
* 중복을 피하기 위한 메시지 비교 동작에는 오버헤드가 존재할 수 밖에 없다.
* 중복 없는 전송을 사용하려면 acks 속성을 all로 설정해야 한다.
  * 20% 정도의 성능이 감소되었으며 프로듀서 전송 성능에 그다지 민감하지 않은 경우에 권장한다.

### 5.4 정확히 한 번 전송
* 중복 없는 전송은 정확히 한 번 전송의 일부 기능이라고 볼 수 있다.
* 전체적인 프로세스를 관리하기 위해 카프카에서는 정확히 한 번 처리를 담당하는 별도의 프로세스가 있는데 이를 트랜잭션 API라고 부른다.
* 프로듀서가 보내는 메시지들은 원자적으로 처리되어 전송에 성공하거나 실패하게 된다. 이런 프로듀서의 전송을 위해 카프카에는 컨슈머 그룹 코디네이터와 동일한 개념으로 트랜잭션 코디네이터라는 것이 서버 측에 존재한다.
* 이러한 코디네이터의 역할은 프로듀서에 의해 전송된 메시지들을 관리하며 커밋 또는 중단 등을 표시한다.
* 카프카의 메시지를 다루는 클라이언트들은 해당 메시지의 커밋, 실패 여부를 식별하기 위해 컨트롤 메시지라고 불리는 특별한 타입의 메시지를 추가로 사용한다.