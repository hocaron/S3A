# 카프카 기본 개념과 구조
* 리플리케이션
  * 각 메시지들을 여러 개로 복제해서 카프카 클러스터 내 브로커들에게 분산시키는 동작.
  * 하나의 브로커가 종료되더라도 카프카는 안정성을 유지할 수 있다.
  * 리플리케이션 팩터는 브로커당 복제본의 수를 의미한다.
  * 리플리케이션 팩터 수가 커지면 안정성은 높아지지만 그만큼 브로커 리소스를 많이 사용하게 된다.

* 파티션
  * 하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 토픽 하나를 여러 개로 나눠 병렬 처리가 가능하게 만든 것.
  * 파티션 수는 초기 생성 후 언제든지 늘릴 수 있지만, 반대로 한 번 늘린 파티션 수는 절대로 줄일 수 없다.
    * 데이터 무결성: 파티션 수를 줄이려면 여러 파티션에 분산된 데이터를 재분배해야 합니다. 이 과정에서 데이터의 무결성을 보장하는 것이 매우 어렵습니다. 데이터 손실이나 중복 등의 문제가 발생할 수 있습니다.
    * 복잡성: 데이터를 재분배하는 과정은 매우 복잡하며, 대규모 시스템에서는 이를 안정적으로 처리하기 어려울 수 있습니다. 특히 데이터가 실시간으로 계속 쓰여지고 있는 환경에서는 더욱 어려움을 겪을 수 있습니다.
    * 성능 저하: 파티션 수를 줄이는 작업은 많은 리소스를 소모하며, 이 과정에서 시스템의 성능이 크게 저하될 수 있습니다. 또한, 작업 중에는 일부 데이터에 대한 접근이 제한될 수 있어 서비스에 영향을 줄 수 있습니다.
    * 비용: 데이터 재분배 과정은 추가적인 네트워크 및 컴퓨팅 리소스를 요구합니다. 대량의 데이터를 다루는 시스템에서는 이로 인한 비용이 상당할 수 있습니다.

* 세그먼트
  * 프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장되며. 각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장된다.


### 3.2 카프카의 핵심 개념
* 분산 시스템
  * 카프카도 최초 구성한 클러스터의 리소스가 한계치에 도달한다면 브로커를 추가하는 방식으로 확장이 가능하다.
* 페이지 캐시
  * 직접 디스크에 읽고 쓰는 대신 물리 메모리 중 어플리케이션이 사용하지 않는 일부 잔여 메모리를 활용한다.
  * 디스크 I/O에 대한 접근이 줄어드므로 성능을 높일 수 있다.
* 배치 전송 처리
* 압축 전송
  * 배치 전송 처리와 결합해 사용한다면 더욱 높은 효과를 낼 수 있다.
  * 높은 압축률이 필요하다면 gzip, zstd. 빠른 응답 속도가 필요하다면 lz4, snappy 권장.
    * 압축과 압축 해제 과정에서 cpu 작업이 필요하다. 그에 따른 차이다.
  * 토픽, 파티션, 오프셋
    * 카프카는 토픽에 데이터를 저장한다. 토픽은 병렬 처리를 위해 여러 개의 파티션으로 나뉜다. 이 파티션의 메시지가 저장되는 위치를 오프셋이라고 하며 순차적으로 증가하는 숫자 형태로 되어 있다.
    * 각 파티션에서의 오프셋은 고유한 숫자이고, 오프셋을 통해 메시지의 순서를 보장하고 컨슈머에서는 마지막까지 읽은 위치를 알 수도 있다.

### 3.3 프로듀서의 기본 동작
* Producer Record는 카프카로 전송하기 위한 실제 데이터이며, 레코드는 토픽, 파티션, 키, 밸류로 구성된다.
  * 레코드에서 토픽과 밸류는 필숫값이며, 특정 파티션을 지정하기 위한 레코드의 파티션과 특정 파티션에 레코드를을 정렬하기 위한 레코드의 키는 선택사항이다.
* 프로듀서의 전송 방법은 메시지를 보내고 확인하지 않기, 비동기 전송, 동기 전송 3가지가 있다.

### 3.4 컨슈머의 기본 동작
* 컨슈머 그룹은 각 파티션의 리더에게 카프카 토픽에 저장된 메시지를 가져오기 위한 요청을 보낸다.
* 파티션 수와 컨슈머 수는 일대일로 매핑되는 것이 이상적이다.
* 파티션 수보다 컨슈머 수가 많게 구현하는 것은 바람직하지 않다.
  * 컨슈머 수가 파티션 수보다 더 많다고 해서 토픽의 메시지를 빠르게 가져오거나 처리량이 높아지는 것이 아니라 더 많은 수의 컨슈머들이 그냥 대기 상태로만 존재한다.
  * 컨슈머 그룹 내에서 리밸런싱 동작을 통해 장애가 발생한 컨슈머의 역할을 동일한 그룹에 있는 다른 컨슈머가 그 역할을 대신 수행하므로 굳이 장애 대비를 위한 추가 컨슈머 리소스를 할당하지 않아도 된다.
* 컨슈머에서 메시지를 가져오는 방법은 오토 커밋, 동기 가져오기, 비동기 가져오기 3가지가 있다.