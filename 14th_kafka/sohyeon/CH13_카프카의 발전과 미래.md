# 13장 카프카의 발전과 미래
## 13.1 주키퍼 없는 카프카의 미래
카프카가 다양한 기능을 탑재하며 진화해나가면서 주키퍼 의존성 관련 이슈가 불거지기 시작했다.

<br/>

### 13.1.1 주키퍼 사용에 따른 제약사항
- **컨슈머의 오프셋 저장소 전환**
  - 메시지 수가 늘어나면서 오프셋 숫자도 커지고 컨슈머의 숫자도 늘어남에 따라 주키퍼에 대한 부담감이 높아졌다.
  - 컨슈머의 오프셋 저장소를 카프카의 내부 토픽(`_consumer_offsets`)으로 이전하면서 주키퍼 의존성이 제거되었다.
    - Kafka 0.10 version(in 2016) ~
   
- **각기 다른 애플리케이션 운영에 대한 부담**
  - 각기 다른 API 사용에 따른 부담
    - 주키퍼와 카프카 2가지 개별 애플리케이션 운영으로 인해 API 간의 호환성이나 사용 방법 등이 달라 간혹 혼동을 일으키고 종국에는 개발 생산성 저하로 이어지기도 한다.
   
  - 운영의 어려움
    - 주키퍼라는 애플리케이션을 추가로 사용하므로 관리자가 습득해야 하는 애플리케이션 지식이 2배가 된다.
   
  - 보안 문제
    - 주키퍼 따로, 카프카 따로 보안을 적용해야 한다.
    - 두 애플리케이션에 보안이 적용된 상태에서 서로 통신이나 권한에는 문제가 없는지까지 확인해야 한다.
    - 관리자/운영자에게 큰 부담이 된다.
   
  - 메타데이터 관리 문제
    - 주키퍼가 카프카의 메타데이터를 저장한다.
    - 둘은 다른 애플리케이션이므로, 변경사항이 발생하는 경우 길게는 수 초동안 컨트롤러(in kafka)와 주키퍼 간의 메타데이터가 불일치하는 상황이 발생할 수 있다.
    - 메타데이터가 불일치하는 경우 카프카 클러스터에 큰 영향을 줄 수 있다.
   
<br/>

### 13.1.2 주키퍼 의존성을 제거한 카프카 업그레이드
주키퍼에 저장해둔 메타데이터를 카프카로 이동시킨다.

<br/>

<img width="500" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/45ead903-a0cc-4925-bad6-812784e65321">

🔼 주키퍼를 사용하는 카프카의 구성도
- 주키퍼를 통해 선정된 브로커 중 하나의 컨트롤러가 주키퍼와의 통신을 담당하며 메타데이터 업데이트 등의 역할을 수행한다.
- 컨트롤러는 메타데이터들을 나머지 브로커들에게 푸시한다.

<br/>

<img width="500" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/5743d3da-030d-426b-b7d4-9323ca9caef3">

🔼 주키퍼에 대한 의존성을 제거한 카프카의 구성도
- 주키퍼의 역할을 대체하는 컨트롤러가 3대 생겼다.
- 컨트롤러 노드에는 하나의 리더가 존재한다.
- 카프카 클러스터 내 나머지 모든 브로커는 컨트롤러부터 당겨오는 풀(pull) 방식으로 변경된다.

<br/>

<img width="500" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/64cf6237-c7b7-44f1-83a4-ae76c45bc4a2">

🔼 주키퍼 의존성을 삭제한 카프카 버전 업그레이드 방법
- 중간에 주키퍼 의존성을 완전히 격리시키는 브리지(bridge) 릴리즈 버전으로 업그레이드를 진행한다.
  - `브리지 버전`: 주키퍼 의존성이 완전히 격리된 임의의 카프카 버전
  - `주키퍼 의존성이 있는 카프카 롤링 업그레이드`를 참고하여 브리지 버전 업그레이드
 
- 브리지 버전 업그레이드 후, 정식 카프카 클러스터로 버전 업그레이드를 진행한다.

<br/>

## 13.2 새로운 합의 프로토콜: KRaft
- 주키퍼 의존성을 제거하면서 새로운 합의 프로토콜이 필요해졌고, 래프트(Raft) 합의 프로토콜과 카프카의 특성을 추가한 **크래프트(KRaft) 합의 프로토콜**이 개발되었다.
- `래프트`는 기존보다 좀 더 이해하기 쉽게 만들어진 합의 알고리즘으로서 훌륭한 성능과 내결함성을 지닌다.
  - 내부적으로 합의를 통해 정보를 유지한다.
  - 일반적인 합의는 과반수 찬성 방식을 따른다.
  - 노드들은 `팔로워`, `후보자`, `리더` 총 3가지 상태를 가진다.
    - `팔로워`: 처음 시작할 때 모든 노드
    - `후보자`: 타임아웃 시간동안 하트비트를 받지 못한 팔로워 상태의 노드는 후보자 상태로 바뀌고, 다른 노드들에게 투표를 요청한다.
    - `리더`: 후보자 노드가 다른 노드들로부터 과반수 이상의 투표를 받으면 새로운 리더 노드로 변경된다. (하트비트 제대로 못하면 재교체)
   
- Raft와 합의 기능에서 큰 차이는 없다. (사용 용어가 다름)
- 쿼럼 상태를 저장하는 메타데이터를 카프카에서 직접 관리하고, 리더 컨트롤러는 무한정 커지지 않도록 주기적으로 스냅샷을 생성한다.
- 동일한 쿼럼 내 다른 컨트롤러들에서 장애가 발생하면 스냅샷에서 필요한 부분만 복구한다. (복구 시간 단축 👍)

<br/>

## 13.3 최적화된 컨트롤러 노드 구성
브로커 내에 존재하는 컨트롤러 노드의 구성은 주키퍼와 동일하게 3대의 컨트롤러가 필요하고, 컨트롤러 노드는 별도의 JVM 프로세스로 분리되어 실행된다.

<br/>

<img width="500" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/aee9b142-6561-42d6-a062-5999bd6d7f09">

🔼 컨트롤러 노드와 브로커 구성 방식
1. 클러스터 내 임의의 브로커 3대를 선정하고, 동일한 노드에서 브로커 프로세스와 컨트롤러 프로세스를 실행하는 방법
   - 일부 개발 환경 등에서 주키퍼와 카프카를 동일한 노드에서 실행하는 방법과 유사하다.
   - 👍 컨트롤러 노들르 위한 별도의 노드나 서버가 필요하지 않으므로 서버를 절약할 수 있다.
  
2. 클러스터 내 실행되는 브로커 노드와 컨트롤러 노드를 분리해 별도의 서버에 구성하는 방법
   - 엔터프라이즈 환경 등에서 주키퍼와 카프카를 분리해 구성하는 방법과 유사하다.
   - 👍 노드의 장애가 발생할 경우 문제가 되는 노드에서 실행되고 있는 프로세스만 종료되어 더욱 높은 안정성을 확보할 수 있고, 각 노드에 할당된 리소스를 단독으로 사용할 수 있다.
  
<br/>

## 13.4 카프카의 미래가 담긴 KIP
- KIP(Kafka Improvement Proposals) 사이트를 통해 카프카의 향후 진척 방향을 예상할 수 있다.
- `카프카 개선사항을 제안`하는 곳이다.
- 하나의 KIP는 독립적이거나, 다수의 KIP와 연결되는 경우도 있다.
