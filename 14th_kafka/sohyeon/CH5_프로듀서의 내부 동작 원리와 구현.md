# 5장 프로듀서의 내부 동작 원리와 구현
## 5.1 파티셔너(partitioner)
- 프로듀서는 토픽으로 메시지를 보낼 때 해당 토픽의 어느 파티션으로 메시지를 보내야 할 지 결정한다. (이때 파티셔너 사용)
- 메시지의 키값이 동일하면 해당 메시지들은 모두 같은 파티션으로 전송된다. (키값을 해시처리)
- 메시지의 키를 이용해 카프카로 전송하는 경우, 관리자의 의도와 다른 방식으로 전송이 이뤄질 수 있으므로 되도록 파티션 수를 변경하지 않는 것이 권장된다.

<br/>

### 5.1.1 라운드 로빈(round-robin) 전략
- 키값을 지정하지 않으면, 라운드 로빈 알고리즘(기본값)을 사용해 토픽의 파티션들로 레코드들이 전송된다.
- 파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에서 잠시 대기 후 전송되는데, 효율이 저하될 수 있다.

<br/>

<img width="688" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/3c068984-e5eb-4c14-b2df-7841b50d2c2f">

🔼 키값이 null인 라운드 로빈 전략
- 라운드 로빈 전략을 사용하는 프로듀서 내부의 처리 과정을 보여준다.
- 토픽A는 3개의 파티션으로 구성, 각 파티션별로 배치 전송을 위해 필요한 레코드 수는 3이다.
- 키값이 null인 레코드들이 총 5개 전송되고, 라운드 로빈 전략에 의해 각 파티션에 하나씩 순차적으로 할당된다.
  - 배치 전송을 위한 최소 레코드 수(3)을 충족하지 못했으므로 프로듀서의 버퍼 메모리에서 대기
  - 특정 시간을 초과하면 전송하도록 설정할 수 있지만, 토픽A-파티션2와 같이 배치, 압축의 효과 없이 레코드 하나만 전송되는 것은 비효율
  - 비효율 전송을 보완하기 위해 스티키 파티셔닝 전략 공개
 
<br/>

### 5.1.2 스티키 파티셔닝(sticky partitioning) 전략
- 라운드 로빈 전략에서 지연시간이 불필요하게 증가되는 비효율적인 전송을 개선한다.
- 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송한다.

<br/>

<img width="700" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/258d81de-c533-4f25-8603-5c1db660f3eb">

🔼 스티키 파티셔닝 전략
- 토픽의 파티션 수는 3, 배치를 위한 최소 레코드 수는 3이다.
- 파티셔너는 배치를 위한 레코드 수에 도달할 때까지 동일한 파티션으로 레코드를 담아놓는다.
- 토픽A-파티션0에 최소 레코드 수를 충족했으므로 즉시 카프카로 배치 전송이 수행된다.
- 👍 기본 설정에 비해 약 30% 이상 지연시간이 감소했다.
- 👍 프로듀서의 CPU 사용률이 감소했다.
- 메시지의 순서가 크게 중요하지 않다면 해당 전략을 사용할 것이 권장된다.

<br/>

## 5.2 프로듀서의 배치
- 프로듀서에서는 카프카로 전송하기 전, 배치(batch) 전송을 위해 토픽의 파티션별로 레코드들을 잠시 보관한다.
- 배치 전송을 위해 옵션들을 제공한다.
  - buffer.memory: 카프카로 메시지를 전송하기 위해 담아두는 프로듀서의 버퍼 메모리 옵션 (기본값 32MB)
  - batch.size: 배치 전송을 위해 레코드들을 묶는 단위를 설정하는 배치 크기 옵션 (기본값 16KB)
  - linger.ms: 배치 전송을 위해 버퍼 메모리에서 대기하는 레코드들의 최대 대기시간을 설정하는 옵션 (단위 ms, 기본값 0)
- 처리량을 높이려면 batch.size와 linger.ms의 값을 크게 설정하고, 지연 없는 전송이 목표라면 batch.size와 linger.ms의 값을 작게 설정한다.
- **높은 처리량**을 목표로 할 경우, 버퍼 메모리 크기가 충분히 커야 한다. (buffer.memory > batch.size)

<br/>

## 5.3 중복 없는 전송
- 중복 없이 전송할 수 있는 기능을 제공한다.

<br/>

### 적어도 한 번 전송

<img width="437" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/e4447460-1ba9-4081-b19a-16f9ef0a72a3">

🔼 적어도 한 번 전송 과정
1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다.
2. 브로커는 메시지A를 기록하고, 잘 받았다는 ACK를 프로듀서에게 응답한다.
3. 브로커의 ACK를 받은 프로듀서는 다음 메시지인 메시지B를 브로커에게 전송한다.
4. 브로커는 메시지B를 기록하고, ACK를 프로듀서에게 전송하려고 한다. 이때 어떤 장애가 발생하여 프로듀서는 메시지B에 대한 ACK를 받지 못한다.
5. 메시지B를 전송한 후 브로커로부터 ACK를 받지 못한 프로듀서는 브로커가 메시지B를 받지 못했다고 판단해 메시지B를 재전송한다.

<br/>

- 메시지B를 브로커에 기록한 후 ACK를 보내지 못했기 때문에, 메시지B는 중복 전송된다. (4-5)
- 최소한 하나의 메시지는 반드시 보장한다는 것이 해당 방식이다.
- 카프카는 기본적으로 적어도 한 번 전송 방식을 기반으로 동작한다.

<br/>

### 최대 한 번 전송

<img width="426" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/c55cf454-ae7d-42f7-a3d4-22d2573e1cb9">

🔼 최대 한 번 전송 과정
1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다.
2. 브로커는 메시지A를 기록하고, 잘 받았다는 ACK를 프로듀서에게 응답한다.
3. 프로듀서는 다음 메시지인 메시지B를 브로커에게 전송한다.
4. 브로커는 메시지B를 기록하지 못하고, ACK를 프로듀서에게 전송하지 못한다.
5. 프로듀서는 브로커가 메시지B를 받았다고 가정하고, 다음 메시지C를 전송한다.

<br/>

- ACK를 받지 못하더라도 재전송을 하지 않는다. (실제 ACK 응답 과정은 필요 X)
- 메시지 손실 가능성은 있지만 메시지 중복 가능성은 없다.

<br/>

### 중복 없는 전송 과정

<img width="424" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/0aa632a9-1e20-49bd-b6dc-1780829eb687">

🔼 중복 없는 전송 과정
1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다. 이때 PID 0과 메시지 번호 0을 헤더에 포함해 함께 전송한다.
2. 브로커는 메시지A를 저장하고, PID와 메시지 번호(0)를 메모리에 기록한다. 이후 프로듀서에게 ACK로 응답한다.
3. 프로듀서는 다음 메시지B를 브로커에게 전송한다. PID는 동일하게 0이고, 메시지 번호는 1(0에서 증가)이다.
4. 브로커는 메시지B를 저장하고, PID와 메시지 번호(1)를 기록한다. 이후 장애가 발생하여 ACK로 응답하지 못한다.
5. 브로커로부터 ACK를 받지 못한 프로듀서는 브로커가 메시지B를 받지 못했다고 판단해 메시지B를 재전송한다.

<br/>

- 브로커는 PID(0)와 메시지 번호(1)를 비교해서, 이미 기록되어 있으면 ACK만 응답한다. (중복 해결 ⭐️)
- 메시지 번호를 시퀀스 번호라고도 한다.
- PID는 프로듀서에 의해 자동 생성된다.
- 프로듀서가 보낸 메시지의 시퀀스 번호가 브로커가 갖고 있는 시퀀스 번호보다 정확하게 하나 큰 경우가 아니라면, 브로커는 프로듀서의 메시지를 저장하지 않는다.
- 리더가 변경되더라도 새로운 리더가 PID와 시퀀스 번호를 정확히 알 수 있으므로 중복 발생을 막을 수 있다. (PID/시퀀스 번호 브로커의 메모리에 유지, 리플리케이션 로그에 저장)
- 기존 대비 약 20% 정도만 성능이 감소했다.

<br/>

|프로듀서 옵션|값|설명|
|---|---|---|
|enable.idempotence|true|프로듀서가 중복 없는 전송을 허용할지 결정하는 옵션|
|max.in.flight.requests.per.connection|1 ~ 5|ACK를 받지 않은 상태에서 하나의 커넥션에서 보낼 수 있는 최대 요청 수|
|acks|all|프로듀서 acks와 관련된 옵션|
|retries|5|ACK를 받지 못한 경우 재시도 해야 하므로 0보다 큰 값으로 설정|

🔼 중복 없는 전송을 위한 프로듀서 설정

<br/>

```
$ vi /home/ec2-user/producer.config
```
🔼 프로듀서의 설정 파일(producer.config) 생성
- 토픽(peter-test04)은 미리 생성해야 한다. (파티션 수 1, 리플리케이션 팩터 수 3)

<br/>

```
enable.idempotence=true
max.in.flight.requests.per.connection=5
retries=5
```
🔼 중복 없는 전송을 위한 producer.config 파일
- acks 옵션은 제외되었다. (추가하지 않을 때의 상황을 알아보기 위함)

<br/>

```
$ /usr/local/kafka/bin/kafka-console-producer.sh --bootstrap-server peter-kafka01.foo.bar:9092 --topic peter-test04 --producer.config /home/ec2-user/producer.config
```
- 생성한 프로듀서 설정 파일을 로드하여 실행한다.
- acks 옵션이 제외되었으므로 ConfigException 예외가 발생한다.

<br/>

```
enable.idempotence=true
max.in.flight.requests.per.connection=5
retries=5
acks=all
```
🔼 중복 없는 전송을 위해 acks=all을 추가한 producer.config 파일
- 다시 실행해보면 에러 없이 메시지를 입력할 수 있는 커맨드(>)가 나타난다.
- 메시지를 전송한다. (exatly one1)

<br/>

```
$ cd /data/kafka-logs/peter-test04-0/
$ ls
```
- 브로커의 peter-test04 토픽 메시지가 저장된 경로로 이동한 후, 파일 리스트를 확인한다.
- snapshot 파일이 있는지 확인한다. (snapshot: 브로커가 PID와 시퀀스 번호를 주기적으로 저장하는 파일)

<br/>

```
$ /usr/local/kafka/bin/kafka-dump-log.sh --print-data-log --files /data/kafka-logs/peter-test04-0/000000000000001.snapshot
```
- 카프카의 dump 명령어를 통해 snapshot 파일을 확인한다.
- 출력 내용을 보면 PID, 시퀀스 번호(first, last)와 마지막 오프셋 정보 등이 기록된 것을 확인할 수 있다.

<br/>

## 5.4 정확히 한 번 전송
