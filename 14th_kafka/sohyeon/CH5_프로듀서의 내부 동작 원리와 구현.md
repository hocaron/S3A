# 5장 프로듀서의 내부 동작 원리와 구현
## 5.1 파티셔너(partitioner)
- 프로듀서는 토픽으로 메시지를 보낼 때 해당 토픽의 어느 파티션으로 메시지를 보내야 할 지 결정한다. (이때 파티셔너 사용)
- 메시지의 키값이 동일하면 해당 메시지들은 모두 같은 파티션으로 전송된다. (키값을 해시처리)
- 메시지의 키를 이용해 카프카로 전송하는 경우, 관리자의 의도와 다른 방식으로 전송이 이뤄질 수 있으므로 되도록 파티션 수를 변경하지 않는 것이 권장된다.

<br/>

### 5.1.1 라운드 로빈(round-robin) 전략
- 키값을 지정하지 않으면, 라운드 로빈 알고리즘(기본값)을 사용해 토픽의 파티션들로 레코드들이 전송된다.
- 파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에서 잠시 대기 후 전송되는데, 효율이 저하될 수 있다.

<br/>

<img width="688" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/3c068984-e5eb-4c14-b2df-7841b50d2c2f">

🔼 키값이 null인 라운드 로빈 전략
- 라운드 로빈 전략을 사용하는 프로듀서 내부의 처리 과정을 보여준다.
- 토픽A는 3개의 파티션으로 구성, 각 파티션별로 배치 전송을 위해 필요한 레코드 수는 3이다.
- 키값이 null인 레코드들이 총 5개 전송되고, 라운드 로빈 전략에 의해 각 파티션에 하나씩 순차적으로 할당된다.
  - 배치 전송을 위한 최소 레코드 수(3)을 충족하지 못했으므로 프로듀서의 버퍼 메모리에서 대기
  - 특정 시간을 초과하면 전송하도록 설정할 수 있지만, 토픽A-파티션2와 같이 배치, 압축의 효과 없이 레코드 하나만 전송되는 것은 비효율
  - 비효율 전송을 보완하기 위해 스티키 파티셔닝 전략 공개
 
<br/>

### 5.1.2 스티키 파티셔닝(sticky partitioning) 전략
- 라운드 로빈 전략에서 지연시간이 불필요하게 증가되는 비효율적인 전송을 개선한다.
- 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송한다.

<br/>

<img width="700" alt="image" src="https://github.com/mash-up-kr/S3A/assets/55437339/258d81de-c533-4f25-8603-5c1db660f3eb">

🔼 스티키 파티셔닝 전략
- 토픽의 파티션 수는 3, 배치를 위한 최소 레코드 수는 3이다.
- 파티셔너는 배치를 위한 레코드 수에 도달할 때까지 동일한 파티션으로 레코드를 담아놓는다.
- 토픽A-파티션0에 최소 레코드 수를 충족했으므로 즉시 카프카로 배치 전송이 수행된다.
- 👍 기본 설정에 비해 약 30% 이상 지연시간이 감소했다.
- 👍 프로듀서의 CPU 사용률이 감소했다.
- 메시지의 순서가 크게 중요하지 않다면 해당 전략을 사용할 것이 권장된다.

<br/>

## 5.2 프로듀서의 배치
