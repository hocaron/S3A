# 1. 파티셔너

## 1.1 파티셔너 개요

프로듀서가 카프카로 전송한 메세지는 토픽의 각 파티션의 로그 세그먼트에 저장된다. 

따라서 프로듀서는 토픽으로 메세지를 보낼 때 해당 토픽의 어느 파티션으로 메세지를 보내야 할지를 결정해야하는데 이 때 `파티셔너`를 사용한다.

프로듀서가 파티션을 결정하는 알고리즘은 메세지(레코드)의 키를 해시처리하여 파티션을 구하는 방식을 사용한다. 따라서 키값이 동일하면 해당 메세지들은 동일한 파티션에 저장된다.

카프카의 파티션을 늘리는 경우, 파티션 수가 변경되는 것과 동시에 메세지의 키와 매핑된 해시 테이블도 변경된다. 따라서 프로듀서가 파티션이 증가한 이후에 동일한 키로 전송을 해도 다른 파티션에 저장된다.

---

## 1.2 파티셔너 - 라운드 로빈 전략

메세지(레코드)의 키값은 필수값이 아니다. 따라서 개요에서 살펴보았던 해시처리 방식은 모든 상황에 적용할 수 없게 된다. 따라서 키값은 지정하지 않을 때는 `라운드 로빈`알고리즘을 사용하여 파티션에 메세지가 저장된다.

라운드 로빈으로 파티션에 분배되었다 하더라도 기본적으로 설정해놓은 배치 옵션에 의해 프로듀서 내에서 대기하게 된다.

배치 크기에 도달하기 전까지 기다리지 않는 방법으로는 `타이머를 두는 것`이 있는데 이는 성능적으로 굉장히 비효율적이다.

---

## 1.3 파티셔너 - 스티키 파티셔닝 전략

라운드 로빈 전략은 배치 크기에 도달하는 것을 기다리며 비효율적으로 가용성을 떨어뜨리게 되는 상황이 종종 발생한다.

2.4버전부터는 스티키 파티셔닝 전략으로 그 문제점을 보완한다.

`스티키 파티셔닝`은 하나의 파티션에 레코드 수를 채워 배치 전송하는 전략이다. 즉, 최소 레코드 수에 도달할때까지 하나의 파티션으로만 레코드를 보내게 된다.

이 전략으로 기본 라운드 로빈보다 약 30%이상 지연시간이 감소했다는 벤치마킹 결과도 있다.

---

# 2. 프로듀서 배치처리

## 배치 처리 관련 옵션

### `buffer.memory`

프로듀서의 버퍼 메모리 옵션을 지정한다. 기본값은 32MB이다.

### `batch.size`

배치 전송을 위해 메세지(레코드)들을 묶는 단위를 설정한다. 기본값은 16KB이다.

### `linger.ms`

배치 전송을 위해 버퍼 메모리에서 대기하는 메세지들의 최대 대기시간을 설정한다. 단위는 ms이며, 기본값은 0ms이다. --> 배치 전송을 기다리지 않고 즉시 전송함

---

## 높은 처리량을 얻고 싶어!

`batch.size`, `linger.ms`의 값을 크게 설정하는 등 배치 전송의 옵션을 적절히 수정해야한다. 또한 `buffer.memory`가 커야 오랜시간동안 많은 배치 사이즈를 담아둘 수 있기 때문에 이점을 유의해아한다.

즉, 기본 `배치 사이즈`가 `16KB`이고 `파티션`이 `3개`이면 최소 48KB를 할당해야한다.

그리고 `압축 옵션`으로 `gzip`, `zstd`를 선택하는 것이 도움이 된다.

## 지연이 없는 방식으로 사용하고 싶어!

`batch.size`, `linger.ms`의 값을 작게 설정하는 등 배치 전송의 옵션을 적절히 수정해야한다. 그리고 `압축 옵션`으로 `lz4`, `snappy`를 사용하면 도움이 된다.

또한 정답은 없기 때문에 옵션값을 조정해가며 판별하는 모니터링이 중요하다.

---

# 3. 중복 없는 전송 (멱등성 전송)

중복 없는 전송을 살펴보기 전 크게 3가지로 나뉘는 메세징 시스템 방식을 알아본다.

이 과정들의 주체는 프로듀서와 브로커이다.

## 적어도 한 번 전송 (Like TCP)

1. 프로듀서가 메시지A를 보낸다. 
2. 브로커가 메시지A를 기록하고 ACK를 응답한다.
3. ACK를 받으면 다음 메시지를 브로커에 전송한다.
4. 브로커가 메시지B를 기록하고, ACK를 프로듀서에게 전송하는 중, 장애 발생하여 프로듀서는 메시지B에 대한 ACK를 받지 못한다.
5. 메시지B를 전송한 후 브로커에게 ACK를 받지 못한 프로듀서는 브로커가 메시지B를 받지 못했다고 판단해 메시지B를 재전송한다.

위 방식의 특징으로는 

- **실제로 브로커가 받은 메세지B는 중복이 발생했다.**
- **하지만 최소한 하나의 메세지는 보냈음을 보장한다.**
- **카프카의 기본 값이다**

---

## 최대 한 번 전송 (Like UDP)

1. 프로듀서가 특정 토픽에 메시지A를 전송한다.
2. 브로커는 메시지A를 기록하고 ACK를 프로듀서에게 응답한다.
3. 프로듀서가 메시지B를 브로커에게 전송한다.
4. 브로커는 메시지B를 기록하지 못해서 ACK를 보내지 않는다.
5. 프로듀서가 브로커가 메시지B를 받았다고 가정하고, 다음 메시지C를 전송한다.

위 방식의 특징으로는

- ACK를 받지 못하더라도 재전송을 하지 않는다.
- 메시지 손실 가능성이 크지만 메시지 중복 가능성은 없다.

이 방식은 주로 대량의 로그 수집이나 IoT환경에서 쓰이곤한다.

---

## 중복 없는 전송 (Like RUDP)

1. 프로듀서가 특정 토픽으로 메시지A를 전송한다. 이때 PID(Producer ID) 0과 메시지 번호 0을 헤더에 포함해 함께 전송한다.
2. 브로커는 메시지A를 저장하고, PID와 메시지 번호(0)를 메모리에 저장한 후 프로듀서에게 ACK로 응답한다.
3. 프로듀서가 메시지B를 브로커에게 전송한다. PID는 동일하게 0이고, 메시지 번호는 1(0에서 증가)이다.
4. 브로커는 메시지B를 저장하고, PID와 메시지 번호(1)를 기록한다. 이 때 예기치 못한 이유로 ACK를 응답하지 못한다.
5. 브로커로부터 ACK를 받지 못한 프로듀서는 브로커가 메시지B를 받지 못했다고 판단해 메시지B를 재전송한다.

위 방식의 특징으로는

- 브로커는 PID(0)와 메시지 번호를 비교해서, 이미 기록되어 있으면 ACK만 응답한다.
- 메시지 번호 == 시퀀스 번호라고 불린다.
- PID는 프로듀서에 의해 자동 생성된다.
- 프로듀서 메시지의 시퀀스 번호가 브로커가 갖고 있는 시퀀스 번호보다 `정확하게 하나 큰` 경우가 아니라면, 브로커는 프로듀서의 메시지를 저장하지 않는다.
- 리더가 변경되더라도 새로운 리더가 PID와 시퀀스 번호를 정확히 알 수 있어 중복을 막을 수 있다.
  - PID와 시퀀스 번호는 브로커의 메모리에 유지되고 리플리케이션 로그에 저장된다.
- 성능 오버헤드가 낮다.

### 중복 없는 전송을 위한 옵션

#### `enable.idempotence`

중복 없는 전송을 사용할 것인지에 대한 옵션이다. 기본값은 false이다.

ture로 설정 시 부가적인 옵션도 설정해줘야한다.

#### `max.in.flight.requests.per.connection`

ACK를 받지 않은 상태의 하나의 커넥션에서 보낼 수 있는 최대 요청 수 이다. 기본값은 5이며 5이하의 자연수로 설정해야한다.

#### `acks`

프로듀서 acks와 관련된 옵션으로 기본값은 1이지만 -1(all)로 설정해야 중복 없는 전송 옵션을 사용할 수 있다.

#### `retries`

ack를 받지 못한 경우 재시도를 수행하는 횟수에 대한 옵션이다. 반드시 0보다 큰 값으로 설정해야한다.

---

## 중복 없는 전송 설정해보기

### producer.config

```text
enable.idempotence=true
max.in.flight.requests.per.connection=5
retries=5
```

위와 같은 설정 파일에 옵션을 등록한 후 프로듀서를 실행시킬 때 `--producer.config`라는 옵션을 추가하여 설정 옵션을 반영해야한다.

---

# 4. 정확히 한 번 전송

중복 없는 전송 방식이 정확히 한 번 전송한다는 의미는 아니다. 카프카에서의 정확히 한 번 전송은 트랜잭션과 같은 전체적인 프로세스 처리를 가리키기 때문에

중복 없는 전송은 정확히 한 번 전송의 일부 기능인 것이다.

## 정확히 한 번 전송을 위한 컴포넌트 - 트랜잭션 코디네이터

프로듀서에 의해 전송된 메시지를 관리한다. 커밋 또는 중단 등을 표시한다.

## 정확히 한 번 전송을 위한 컴포넌트 - _transaction_state

카프카의 내부 토픽으로 트랜잭션 로그를 저장한다.

기본 값으로는 `transaction.state.log.num.partitions=50`, `transaction.state.log.replication.factor=3`이다.

## 정확히 한 번 전송을 위한 컴포넌트 - 컨트롤 메시지

클라이언트들이 메시지들을 식별하기 위한 정보로서 사용된다. 브로커와 클라이언트 통신에서만 사용된다.

## 정확히 한 번 전송 예시

```java
public class OneCoin {
	public static void main(String[] args) {
      // 기타 카프카 설정
		Properties props = new Properties();
        // 기타 카프카 설정
		
		// 정확히 한 번 전송 관련 설정
		props.setProperty(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, "true");
		props.setProperty(ProducerConfig.ACKS_CONFIG, "all");
		props.setProperty(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, "5");
		props.setProperty(ProducerConfig.RETRIES_CONFIG, "5");
		props.setProperty(ProducerConfig.TRANSACTIONAL_ID_CONFIG, "peter-transaction-01");
		
		Producer<String, String> producer = new KafkaProducer<>(props);

        // 프로듀서 트랜잭션 init
		producer.initTransactions();

        // 프로듀서 트랜잭션 시작
		producer.beginTransaction();
		
		try {
			for (int i = 0; i < 1; i++) {
				ProducerRecord<String, String> record = new ProducerRecord<>(
						"diger-topic", 
						"카푸카 정확히 한 번 전송"
                );
				producer.send(record);
				producer.flush();
			}
		} catch (Exception e) {
            // 프로듀서 트랜잭션 중단
			producer.abortTransaction();
			producer.close();
		} finally {
            // 프로듀서 트랜잭션 커밋
			producer.commitTransaction();
			producer.close();
		}
	}
}
```

### `TRANSACTIONAL_ID_CONFIG`

`중복 없는 전송`과 `정확히 한 번 전송`의 옵션 설정에서 가장 큰 차이점인 옵션이다.

실행하는 프로듀서 프로세스마다 고유한 아이디로 설정해야 한다.

---

## 정확히 한 번 전송 동작 방식

트랜잭션 API를 활용하는 것이 기본이다.

### 1. 프로듀서가 브로커에게 API를 요청하여 트랜잭션 코디네이터의 위치를 찾는다. (FindCoordinatorRequest)

- 트랜잭션 코디네이터의 주 역할은 PID와 transcational.id를 매핑하고 해당 트랜잭션 전체를 관리한다.
  - 만약 트랜잭션 코디네이터가 존재하지 않는다면 새로운 코디네이터가 생성된다.

- __transaction_state토픽의 파티션 번호는 transcational.id를 기반으로 해시하여 결정된다. 
  - 이 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 선정된다.
  - 따라서 transcational.id가 정확히 하나의 코디네이터만 갖고 있다는 것이다.

### 2. 프로듀서가 트랜잭션 전송을 위한 InitPidRequest를 트랜잭션 코디네이터에게 보낸다. (InitPidRequest)

트랜잭션 코디네이터는 TID, PID를 매핑하고 해당 정보를 트랜잭션 로그에 기록한다.

그 후, PID 에포크를 한 단계 올려 이전과 동일한 PID와 이전 에포크에 대한 쓰기 요청은 무시된다.

### 3. 프로듀서가 새로운 트랜잭션을 알린다. (beginTransaction())

프로듀서는 내부적으로 트랜잭션이 시작됐음을 기록하지만, 트랜잭션 코디네이터는 첫 레코드가 전송되기 전까지 트랜잭션 시작을 알 수 없다.

### 4. 트랜잭션 코디네이터가 트랜잭션 상태를 로그에 기록한다.

프로듀서는 토픽 파티션 정보를 트랜잭션 코디네이터에게 전달한다.

트랜잭션 코디네이터는 이 정보를 트랜잭션 로그에 기록한다.

- 이는 아래와 같이 기록한다고 볼 수 있고, 트랜잭션의 현재 상태를 Ongoing으로 기록한다.
  - TID-PID(에포크)
  - TID-P0(Ongoing)

트랜잭션 로그에 추가되는 첫 번째 파티션일 때 트랜잭션 코디네이터는 해당 트랜잭션에 대한 타이머를 시작하여 기본값인 1분동안 트랜잭션 업데이트가 없으면 실패로 처리한다.

### 5. 프로듀서가 메세지를 전송한다.

프로듀서가 토픽의 파티션으로 메세지를 전송한다.

메세지에는 PID, 에포크, 시퀀스 번호가 포함되어 전송된다.

### 6. 프로듀서가 트랜잭션 종료를 요청한다. (commitTranscation(), abortTranscation())

메세지 전송을 마친 프로듀서는 commitTranscation(), abortTranscation() 메서드 둘 중 하나를 반드시 호출하여 트랜잭션을 마쳐야한다.

### 7. 트랜잭션 코디네이터가 토픽에 커밋 표시 메세지(컨트롤 메세지)를 기록한다.

트랜잭션 코디네이터는 트랜잭션 로그에 기록된 토픽의 파티션에 트랜잭션 커밋 표시를 기록한다.

트랜잭션 커밋이 끝나지 않은 메시지는 컨슈머에게 반환하지 않는다.

오프셋의 순서 보장을 위해 트랜잭션 성공/실패를 나타내는 LSO(Last Stable Offset)라는 오프셋을 유지한다.

### 8. 트랜잭션 완료

트랜잭션 코디네이터는 Committed로 트랜잭션 로그에 기록한다.

프로듀서에게 해당 트랜잭션이 완료됨을 알림으로써 해당 트랜잭션을 끝낸다.
