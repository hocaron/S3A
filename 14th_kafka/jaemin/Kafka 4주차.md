# Kafka 4주차

# 파티셔너

카프카의 토픽은 성능 향상을 위해 병렬 처리가 가능하도록 파티션으로 나누고, 최소 하나 또는 둘 이상의 파티션으로 구성된다.  그리고 프로듀서가 카프카로 전송한 메세지는 토픽의 각 파티션의 로그 세그먼트에 저장된다. 따라서 프로듀서는 토픽으로 메시지를 보낼 때 해당 토픽의 어느 파티션으로 메시지를 보내야 할지를 결정해야 하는데 이때 사용하는 것이 **파티셔너** 이다.

프로듀서가 파티션을 결정하는 알고리즘은 메시지의 키를 해시처리해 파티션을 구하는 방식을 사용한다. 따라서 키값이 동일하면 결정되는 파티션도 동일하다.

카프카의 파티션을 늘리는 경우, 파티션 수가 변경되는 것과 동시에 메시지의 키와 매핑된 해시 테이블도 변경되어 프로듀서가 파티션이 증가한 후에 동일한 키 값을 사용해도 다른 파티션에 저장된다.

## 라운드 로빈 전략

메시지의 키 값은 필수가 아니기에 키 값이 들어오지 않은 경우에도 파티션을 결정할 수 있어야한다. 이 때 라운드 로빈 전략을 사용한다. 라운드 로빈으로 파티션에 분배되었다 하더라도 기본적으로 설정해놓은 배치 옵션에 의해 잠시 프로듀서 내에 대기한다.

물론 관리자가 프로듀서의 옵션을 조정해 특정 시간을 초과하면 즉시 전송할 수 있지만 이는 비효율적이다. 이를 보완하기 위해 스티키 파티셔닝이 공개되었다.

## 스티키 파티셔닝 전략

위의 비효율성을 보완하기 위해 스티키 파티셔닝 전략이 공개됐다. 이 알고리즘은 하나의 파티션에 레코드 수를 채워 배치 전송하는 전략이다. 즉, 최소 레코드 수에 도달할때까지 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략이다. 이 전략으로 기본 라운드 로빈보다 약 30%이상 지연시간이 감소했다는 결과도 있다.

# 프로듀서의 배치

### **배치 전송을 위한 옵션들**

- buffer.memory
    - 카프카로 메시지들을 전송하기 위해 담아두는 프로듀서의 버퍼 메모리 옵션. def: 32MB
- batch.size
    - 배치 전송을 위해 메시지들을 묶는 단위를 설정하는 배치 크기 옵션 def:16KB
- linger.ms
    - 배치 전송을 위해 버퍼 메모리에서 대기하는 메시지들의 최대 대기시간을 설정하는 옵션 def:0

### 높은 처리량을 얻기 위한 설정값

버퍼 메모리 크기가 충분히 커야한다. 즉, buffer.memory 크기는 반드시 batch.size보다 커야한다.

만약 batch.size가 16KB이고 파티션이 3개이면 buffer.memory는 48KB 이상이어야 한다.

### 지연 없는 전송을 위한 설정값

batch.size와 [linger.ms](http://linger.ms) 값을 작게 설정해야 한다.

### 압축은 무엇을 사용할까?

압축옵션으로 높은 압축률을 선호하면 gzip, zstd를 선택하고 낮은 시연시간을 선호하면 lz4, snappy를 사용하자.

# 중복 없는 전송

메시지 시스템들의 메시지 전송 방식부터 알아보자

## 적어도 한 번 전송

1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다
2. 브로커는 메시지A를 기록하고 ACK를 응답한다.
3. ACK를 받은 프로듀서는 다음 메시지를 브로커에게 전송한다
4. 브로커는 해당 메시지를 기록하고 ACK를 프로듀서에게 전송하려고 하지만 네트워크 오류 또는 브로커 장애로 프로듀서는 메시지에 대한 ACK를 받지 못한다.
5. 해당 메시지 전송 후 브로커로부터 ACK를 받지 못한 프로듀서는 프로커가 메시지를 받지 못했닥 생각하고 재전송한다.

### 특징

- 실제로 브로커가 받은 메시지B는 중복 전송되었다.
- 하지만 최소한 하나의 메시지는 보냄을 보장한다
- 카프카의 기본 값이다

## 최대 한 번 전송

1. 프로듀서가 특정 토픽에 메시지A를 전송한다.
2. 브로커는 메시지A를 기록하고 ACK를 프로듀서에게 응답한다.
3. 프로듀서가 메시지B를 브로커에게 전송한다.
4. 브로커는 메시지B를 기록하지 못해서 ACK를 보내지 않는다.
5. 프로듀서가 브로커가 메시지B를 받았다고 가정하고, 다음 메시지C를 전송한다.

### 특징

- ACK를 받지 못하더라도 재전송을 하지 않는다.
- 메시지 손실 가능성이 크지만 메시지 중복 가능성은 없다.
- 손실되어도 괜찮은 로그 수집이나 IoT 환경에서 쓰인다

## 중복 없는 전송

1. 프로듀서가 특정 토픽으로 메시지A를 전송한다. 이때 PID(Producer ID) 0과 메시지 번호 0을 헤더에 포함해 함께 전송한다.
2. 브로커는 메시지A를 저장하고, PID와 메시지 번호(0)를 메모리에 저장한 후 프로듀서에게 ACK로 응답한다.
3. 프로듀서가 메시지B를 브로커에게 전송한다. PID는 동일하게 0이고, 메시지 번호는 1(0에서 증가)이다.
4. 브로커는 메시지B를 저장하고, PID와 메시지 번호(1)를 기록한다. 이 때 예기치 못한 이유로 ACK를 응답하지 못한다.
5. 브로커로부터 ACK를 받지 못한 프로듀서는 브로커가 메시지B를 받지 못했다고 판단해 메시지B를 재전송한다.

### 특징

- 브로커는 PID(0)와 메시지 번호를 비교해서, 이미 기록되어 있으면 ACK만 응답한다.
- 메시지 번호 == 시퀀스 번호라고 불린다.
- PID는 프로듀서에 의해 자동 생성된다.
- 프로듀서 메시지의 시퀀스 번호가 브로커가 갖고 있는 시퀀스 번호보다 `정확하게 하나 큰` 경우가 아니라면, 브로커는 프로듀서의 메시지를 저장하지 않는다.
- 리더가 변경되더라도 새로운 리더가 PID와 시퀀스 번호를 정확히 알 수 있어 중복을 막을 수 있다.
    - PID와 시퀀스 번호는 브로커의 메모리에 유지되고 리플리케이션 로그에 저장된다.
- 성능 오버헤드가 낮다.

### 중복 없는 전송을 위한 프로듀서 설정

- enable.idempotence
    - def: false
    - 프로듀서가 중복 없는 전송을 허용할지 결정하는 옵션
- max.in.flight.requets.per.connection
    - def: 5
    - ACK를 받지 않은 상태에서 하나의 커넥션에 보낼 수 있는 최대 커넥션 수
- acks
    - def: 1
    - 프로듀서 acks와 관련된 옵션
- retries
    - ACK를 받지 못한 경우 재시도를 해야 하므로 0보다 큰 값으로 설정해야 함

### 중복 없는 전송을 위한 producer.config 파일

```kotlin
enable.idempotence=true
max.in.flight.requests.per.connection=5
retries=5
```

### 중복 없는 전송을 위해 ack=all을 추가하 producer.config 파일

```kotlin
enable.idempotence=true
max.in.flight.requests.per.connection=5
retries=5
acks=all
```

# 정확히 한 번 전송

중복 없는 전송 방식이 정확히 한 번 전송한다는 의미는 아니다. 카프카에서의 정확히 한 번 전송은 **트랜잭션**과 같은 전체적인 프로세스 처리를 가리키기 때문에 중복 없는 전송은 정확히 한 번 전송의 일부 기능인 것이다.

## 동작 방식

정확히 한 번 전송을 위해 트랜잭션 API를 사용한다.

1. 트랜잭션 코디네이터 찾기
    1. 프로듀서는 브로커에게 FindCoordinatorRequest를 보내 트랜잭션 코디네이터를 찾고 없으면 신규 트랜잭션 코디네이터를 생성한다.
    2. **transaction**state 토픽의 파티션 번호는 transactional.id를 기반으로 해싱하고 이 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 최종 선정됨
2. 프로듀서 초기화
    1. 프로듀서는 `initTransactions()` 메소드를 이용해 트랜잭션 전송을 위한 InitPidRequest를 트랜잭션 코디네이터로 보낸다
    2. TID가 선정된 경우 이도 함께 전달한다.
    3. 트랜잭션 코디네이터는 TID, PID를 매핑해 해당 정보를 트랜잭션 로그에 기록하고 PID 에포크를 한 단계 올려 이전 에포크에 대한 쓰기 요청을 무시한다
3. 트랜잭션 시작
    1. 프로듀서는 `beginTransaction()` 메소드를 이용해 새로운 트랜잭션의 시작을 알린다
    2. 프로듀서는 내부적으로 트랜잭션이 시작됨을 기록하지만 트랜잭션 코디네이터의 입장에선 첫 레코드가 전송되기 전까지는 시작된 것이 아니다
4.  트랜잭션 상태 추가
    1. 토픽 파티션 정보를 트랜잭션 코디네이터에게 전달하고, 트랜잭션 코디네이터는 해당 정보를 트랜잭션 로그에 기록한다
    2. 트랜잭션 로그에 추가되는 첫 번째 파티션일 때 트랜잭션 코디네이터는 해당 트랜잭션에 대한 타이머를 시작하여 기본값인 1분동안 트랜잭션 업데이트가 없으면 실패로 처리한다.
5. 메시지 전송
    1. 프로듀서가 토픽의 파티션으로 메세지를 전송한다.
    2. 메세지에는 PID, 에포크, 시퀀스 번호가 포함되어 전송된다.
6. 트랜잭션 종료 요청
    1. 메세지 전송을 마친 프로듀서는 commitTranscation(), abortTranscation() 메서드 둘 중 하나를 반드시 호출하여 트랜잭션을 마쳐야한다.
7. 사용자 토픽에 표시 요청
    1. 트랜잭션 코디네이터는 트랜잭션 로그에 기록된 토픽의 파티션에 트랜잭션 커밋 표시를 기록한다.
    2. 트랜잭션 커밋이 끝나지 않은 메시지는 컨슈머에게 반환하지 않는다.
    3. 오프셋의 순서 보장을 위해 트랜잭션 성공/실패를 나타내는 LSO(Last Stable Offset)라는 오프셋을 유지한다.
8. 트랜잭션 완료
    1. 트랜잭션 코디네이터는 Committed로 트랜잭션 로그에 기록한다.
    2. 프로듀서에게 해당 트랜잭션이 완료됨을 알림으로써 해당 트랜잭션을 끝낸다. (내부적으로 실패했다면 재시도)