# Kafka 9주차

# 스키자 레지스트리

스키마란 정보를 구성하고 해석하는 것을 도와주는 프레임워크나 개념을 의미한다. 10장에서는 스키마 레지스트리라는 애플리케이션을 이용해 카프카에서 어떻게 스키마를 정의하고 활용할 수 있는지 살펴보자.

# 스키마의 개념과 유용성

관계형 데이터베이스에서 스키마가 없이 운영한다고 했을 때 Human Error등의 이유로 데이터 입력이 잘못돼 데이터 파싱이나 백엔드 시스템에서 문자열 오류를 발생시킬 수 있다. 카프카에서도 이와같이 관리자 혼자 관리할 경우 큰 문제가 안될 수 있지만 클러스터가 커지고 여러 관계자가 사용하게 되면 누군가의 실수로 사전에 정의되지 않은 형태의 데이터를 전달해 파싱 에러와 같은 장애를 일으킬 수 있다. 더불어 특정 토픽에 대한 데이터 타입이 변경될 때 스키마를 정의하지 않은 경우 해당 토픽에 관여하는 많은 관계자들과 회의를 통해 변경사항을 직접 전파해야 하지만 스키마를 사용하면 이러한 커뮤니케이션을 최소화 할 수 있다. 카프카에서 스키마 사용은 권장사항이다!

# 카프카와 스키마 레지스트리

스키마를 카프카에서 활용한다면 관리자는 데이터 처리 시 유연성을 확보할 수 있으며 불필요한 커뮤니케이션 비용도 줄일 수 있다. 이번 절에서 카프카에서 스키마를 활용하는 방법과 스키마 레지스트리에 가장 최적화된 에이브로 활용에 대해 알아보자.

## 스키마 레지스트리 개요

스키마 레지스트리는 카프카와 별도로 구성된 독립적 애플리케이션이다. 프로듀서와 컨슈머와 직접 통신한다.

클라이언트들이 스키마 정보를 사용하기 위해선 프로듀서와 컨슈머, 스키마 레지스트리 간에 직접 통신이 필요하다. 프로듀서는 스키마 레지스트리에 스키마를 등록하고, 스키마 레지스트리는 프로듀서에 의해 등록된 스키마 정보를 카프카 내부 토픽에 저장한다. 프로듀서는 스키마 레지스트리에 등록된 스키마의 ID와 메시지를 카프카에 전송하고, 컨슈머는 스키마 ID를 스키마 레지스트리로부터 읽어온 후 프로듀서가 전송한 스키마 ID와 메시지를 조합해 읽을 수 있다. 스키마 레지스트리를 이용하기 위해서는 스키마 레지스트리가 지원하는 데이터 포맷을 사용해야 하는데 가장 대표적인 포맷은 에이브로이다.

## 스키마 레지스트리의 에이브로 지원

에이브로는 시스템, 프로그래밍 언어, 프로세싱 프레임워크 사이에서 데이터 교환을 도와주는 오픈소스 직렬화 시스템이다. 에이브로는 빠른 바이너리 데이터 포맷을 지원하며 JSON 형태의 스키마를 정의할 수 있는 매우 간결한 데이터 포맷이다. 가장 많이 사용하는 데이터 타입은 JSON이지만 컨플루언트는 다음과 같은 이유로 에이브로 포맷 사용을 권장한다.

1. 에이브로는 JSON과 매핑한다
2. 에이브로는 매우 간결한 데이터 포맷이다
3. JSON은 메시지마다 필드 네임들이 포함되어 전송되므로 효율이 떨어진다
4. 에이브로는 바이너리 형태이므로 매우 빠르다.

# 스키마 레지스트리 실습

스키마 레지스트리는 HTTP 기반으로 통신이 이뤄지며, 사용자들의 유연성과 편의성을 위해 스키마 레지스트리의 주요 기능들에 대한 API를 제공하고 있다. 사용자들은 이런 API를 통해 애플리케이션 개발을 간소화하고 시간도 절약할 수 있다.

## 스키마 레지스트리와 클라이언트 동작

카프카의 모델은 펍/섭 모델로서, 프로듀서와 컨슈머는 직접 통신을 주고받지 않는다. 스키마가 정의되어 있는 메시지를 컨슈머가 읽기 위해서는 프로듀서가 정의한 스키마 정보를 알아야 한다. 프로듀서와 컨슈머가 직접 통신하지 않는데 컨슈머는 어떻게 프로듀서가 정의한 스키마 정보를 알 수 있을까?

### 동작 순서

1. 에이브로 프로듀서는 컨플루언트에서 제공하는 `io.confluent.kafka.serializers.KafkaAvroSerializer` 라는 새로운 직렬화를 사용해 스키마 레지스트리의 스키마가 유효한지 여부를 확인한다. 만약 스키마가 확인되지 않으면, 에이브로 프로듀서는 스키마를 등록하고 캐시한다.
2. 스키마 레지스트리는 현 스키마가 저장소에 저장된 스키마와 동일한 것인지, 진화한 스키마인지 확인한다. 스키마 레지스트리 자체적으로 각 스키마에 대해 고유 ID를 할당한다. 이 ID는 순차적으로 1씩 증가하지만, 반드시 연속적이진 않다. 스키마에 문제가 없다면 스키마 레지스트리는 프로듀서에게 고유 ID를 응답한다.
3. 프로듀서는 스키마 레지스트리로부터 받은 스키마 ID를 참고해 메시지를 카프카로 전송한다. 이때 프로듀서는 스키마의 전체 내용이 아닌 오로지 메시지와 스키마 ID만 보낸다. JSON은 키:밸류 형태로 전체 메시지를 전송해야 하지만, 에이브로를 사용하면 프로듀서가 스키마 ID와 밸류만 메시지로 보내 카프카로 전송하는 전체 메시지 크기를 줄일 수 있다.
4. 에이브로 컨슈머는 스키마ID로 컨플루언트에서 제공하는 `io.confluent.kafka.serializers.KafkaAvroDerializer` 라는 새로운 역직렬화를 사용해 카프카의 토픽에 저장된 메시지를 읽는다. 이때 컨슈머가 스키마 ID를 갖고 있지 않다면 스키마 레지스트리로부터 가져온다.

이를 통해 프로듀서와 컨슈머는 직접 통신하지 않고 각자 스키마 레지스트리와 통신하면서 스키마 정보를 주고받을 수 있다. 프로듀서가 스키마 정보를 스키마 레지스트리에 등록함으로써 프로듀서가 전송하는 메시지의 크기도 줄일 수 있고, 컨슈머가 읽는 메시지의 크기도 줄일 수 있다. 사전에 정의되지 않은 형식의 메시지는 전송할 수 없으므로 데이터를 처리하는 쪽에서 협의되지 않은 메시지가 들어오는 경우에 대한 고민도 할 필요가 없다. 즉, 스키마 레지스트리를 통해 SSOT (Single Source of Truth)를 확립하는 것이다.

# 스키마 레지스트리 호환성

스키마 레지스트리는 버전별 스키마에 대한 관리를 효율적으로 해주며, 각 스키마에 대해 고유한 ID와 버전 정보를 관리한다. 스키마 레지스트리에서는 하나의 서브젝트에 대한 버전 정보별로 진화하는 각 스키마를 관리하고 스키마가 진화함에 따라 호환성 레벨을 검사해야 하는데, 스키마 레지스트리에서는 대표적으로 BACKWARD, FORWARD, FULL 등의 호환성 레벨을 제공한다.

## BACKWARD 호환성

스키마 레지스트리를 사용하다보면 데이터 포맷의 변경이 필요하며, 데이터 포맷을 변경하는 스키마는 진화하게 된다. 이렇게 진화함에 따라 스키마 레지스트리 내에는 버전별 스키마를 갖게 된다. BACKWARD 호한성이란 진화된 스키마를 적용한 컨슈머가 진화 전의 스키마가 적용된 프로듀서가 보낸 메시지를 읽을 수 있도록 허용하는 호환성이다. 

스키마 레지스트리에 버전별로 버전1, 버전2, 버전2의 스키마가 저장되어 있다고 할 때 최신 버전의 스키마인 버전3 스키마를 이용해 컨슈머가 데이터를 가져올 때, 컨슈머는 자신과 동일한 버전인 버전3 스키마를 사용하는 프로듀서의 메시지를 처리할 수 있다. BACKWARD 호환성의 추가 기능으로 한 단계 이전의 스키마를 처리할 수 있다. 즉, 스키마의 버전 업데이트가 필요하면 프로듀서와 컨슈머의 스키마도 업데이트해야 하는데 BACKWARD 호환성에서는 컨슈머부터 상위 버전의 스키마를 적용하고 BACKWARD 호환성의 추가 기능으로 그 이전에 프로듀서에서 보낸 메시지도 처리하다가 프로듀서를 업데이트하면 동작의 오류 없이 업데이트가 가능하다. 만약 모든 하위 버전의 스키마를 호환하고자 한다면 `BACKWARD_TRANSITIVE 를 사용하자.`

## FORWARD 호환성

FORWARD 호환성이란 BACKWARD 호환성과 대비되는 성질을 지니며 진화된 스키마가 적용된 프로듀서가 보낸 메시지를 진화 전의 스키마가 적용된 컨슈머가 읽을 수 있게 하는 호환성이다.

FORWARD 호환성은 BACKWARD 호환성과 반대되기 때문에 스키마 업데이트 시 프로듀서부터 업데이트한 후 컨슈머의 스키마를 업데이트 하자. 이또한 모든 버전의 스키마를 호환하고자 한다면 `FORWARD_TRANSITIVE` 를 사용하자.

## FULL 호환성

FULL 호환성은 BACKWARD, FORWARD 호환성 모두를 지원한다. 이 또한 모든 버전의 스키마를 호환하고자 한다면 `FULL_TRANSITIVE` 를 사용하자.