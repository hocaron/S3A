# Kafka 8주차

# 카프카 보안

카프카 애플리케이션에서 제공하는 보안 요소를 살펴보고, 직접 보안 기능을 구성해보면서 장단점을 알아보자!

# 카프카 보안의 세 가지 요소

카프카는 기본 설치하는 부분에서 보안을 기본적으로 설정하지 않기에 관리자가 보안과 관련된 부분을 직접 설정해줘야 한다. 카프카는 기본적으로 사내에서 운영하다보니 보안이 적용되지 않은 경우가 대부분이다.

카프카 클러스터를 운영할 때 취약한 부분들은 어떤게 있을까?

1. 외부의 악의적인 목적을 가진 사용자가 침입할 경우 손쉽게 주요 정보가 유출될 수 있다 (인증)
2. Human Error 등으로 다른 서비스에서 사용하는 메시지를 보내 정합성 오류가 발생할 수 있다. (권한)
3. 클라이언트와 카프카 간의 통신이 암호화 되어 있지 않기에 악의적인 목적을 가진 사용자가 통신에 끼어들어 모든 패킷을 가로채고 이로인해 중요한 데이터가 노출될 수 있다.(암호화)

## 암호화

- 악의적인 목적을 가진 사용자가 중간에서 패킷을 가로채더라도 암호화를 설정해두어 데이터를 읽을 수 없게 해야한다. 우리에게 익숙한 웹으로 비유하자면 http가 아닌 https로 접근하는 것과 같은 원리이다.
- 이러한 암호화 통신을 설정하기 위해 일반적으로 SSL을 사용한다. SSL은 보안 소켓 레이어(Secure Socket Layer)의 약자로, 서버와 서버 사이 또는 서버와 클라이언트 사이에서 통신 보안을 적용하기 위한 표준 암호 규약이다.
- SSL은 인증기관으로 부터 인증서를 발급받은 후, 인증서를 이용한 퍼블릭 키, 프라이빗 키 방식으로 서버와 클라이언트가 암/복호화를 하면서 통신한다.
- 대칭키, 비대칭키 방식으로 암/복호화가 가능하다. 대칭키는 오버헤드가 적지만 키 노출이 우려되고, 비대칭키는 키 노출의 우려는 적지만 오버헤드가 크다는 단점이 있어 효율적인 고성능을 얻기 위해 두 가지 방식을 모두 혼용해서 사용한다.

## 인증

- 카프카로 접근할 때 안전하다고 확인된 클라이언트만 접근할 수 있도록 설정하는 부분이다. 아이디/비밀번호를 입력해 로그인에 성공한 사용자만 웹 페이지에 접근할 수 있는것과 비슷하다.
- SASL(Simple Authentication and Security Layer)은 인터넷 프로토콜에서 인증과 데이터 보안을 위한 프레임워크로서 카프카에서도 사용된다.
- 애플리케이션 프로토콜에서 인증 매커니즘을 분리해 모든 애플리케이션에서 사용할 수 있다. 다음과 같은 네 가지 SASL 메커니즘을 지원한다.
    - SASL/GASSAPI
        - 카프카 0.9부터 지원. 커버로스 인증 방식으로 많이 사용되는 인증 방식 중 하나. 회사 내부에 별도의 커버로스 서버가 있는 환경이라면 커버로스 인증 방식을 사용하는 것이 가장 좋다. 렐름이라는 설정이 필요한데, 이때는 되도록 하나의 렐름으로 모든 애플리케이션을 적용하는 방법을 추천한다. 그 이유는 클라이언트들의 재인증, 인증 실패 등이 일어나는 경우가 종종 있기 때문이다.
    - SAS/PLAIN
        - 0.10.0 버전부터 지원. PLAIN은 ID/PW 테스트 형태로 사용하는 방법으로 운영환경보다는 개발 환경에서 테스트 등의 목적으로 활용한다.
    - SASL/SCRAM-SHA-256, SASL/SCRAM-SHA-512
        - 0.10.2 버전부터 지원. 본래의 암호에 해시된 내용을 추가함으로써 암호가 유출되어도 본래 암호를 알 수 없게 저장할 수 있는 의미로 이름 붙여진 솔티드 챌린지 응답 인증 메커니즘의 약어인 SCRAM은 인증 정보를 주키퍼에 저장해 사용하는 방식으로 토큰 방식도 지원하므로 커버로스 서버를 구성하지 않은 경우 사용하기 가장 좋은 방법이다.
    - SASL/OAUTHBEARER
        - 2.0 버전부터 지원. OAUTH 방식은 최근 인증에서 많이 사용하는 방식이긴 하지만 카프카에서 제공하는 기능은 매우 한정적이라 개발 환경정도에서만 사용하자.

## 권한

- 인증받은 A라는 클라이언트가 B라는 토픽에 접근할 수 있는 권한을 부여하는 것이다. 웹으로 비유하자면, 일반 사용자는 모두에게 공개된 정보만 접근 가능하지만 관리자의 경우 비공개된 웹 페이지까지 접근할 수 있는 것과 비슷하다.
- 카프카뿐 아니라 다른 애플리케이션 또는 방화벽 등에서 권한을 설정하는 대표적인 방식은 ACL(Access Control Layer)를 적용하는 것이다. 규칙 기반의 리스트를 만들어 접근 제어 하는 방식
- 모든 ACL 규칙들은 주키퍼에 저장된다.
- ACL은 리소스 타입별로 구체적인 설정이 가능하다.

# SSL을 이용한 카프카 암호화

일반적으로 자바 기반 애플리케이션에서는 키스토어라고 불리는 인터페이스를 통해 퍼블릭 키, 프라이빗 키, 인증서를 추상화해 제공한다. 카프카 또한 자바 기반이기에 자바의 keytool 명령어를 이용해 카프카에 SSL 적용 작업을 진행한다.

## 키스토어

- keytool을 이용해 관리되며, 각 스토어에 저장되는 내용은 다소 차이가 있다.
- 일반적으로 서버 측면에서 프라이빗 키와 인증서를 저장하며, 자격 증명을 제공한다.
- 프라이빗하고 민감한 정보를 저장한다.

## 트러스트스토어

- keytool을 이용해 관리되며, 각 스토어에 저장되는 내용은 다소 차이가 있다.
- 일반적으로 클라이언트 측면에서 서버가 제공하는 인증서를 검증하기 위한 퍼블릭 키와 서버와 SSL 연결에서 유효성을 검사하는 서명된 인증서를 저장하며, 민감한 정보는 저장하지 않는다.

## CA 인증서 설정

- 공인 인증서를 사용하는 이유는 위조된 인증서를 방지해 클라이언트-서버 간 안전한 통신을 하기 위한 것이며, 이러한 역할을 보장해주는 곳이 인증기관 CA 이다. CA가 인증서를 서명해야 비로소 그 인증서는 공증 자격을 얻게 되는 셈이다.

## 암호화 설정 과정

1. 브로커 키스토어 생성
    1. 브로커 즉, 서버 부분에 키스토어를 생성한다.
2. CA 인증서 생성
    1. 공인 인증된 기관 CA에서 인증서를 발급받는다.
3. 트러스트스토어 생성
    1. 각 클라이언트는 서버 측으로 접속해 서버가 갖고 있는 인증서가 신뢰할 수 있는지 여부를 확인하기 위해 위에서 생성한 자체 서명된 CA 인증서를 클라이언트가 신뢰할 수 있도록 각 클라이언트 트러스트스토어에 추가한다.
4. 인증서 서명
    1. 키스토어에 저장된 모든 인증서는 자체 서명된 CA의 서명을 받아야 한다. 그렇게 해야 클라이언트가 인증서 요청을 보냈을 때 해당 인증서를 신뢰할 수 있기 때문이다.
5. 나머지 브로커에 대한 SSL 구성
6. 브로커 설정에 SSL 추가
    1. 모든 브로커에서 브로커 설정 파일인 [`server.properties`](http://server.properties) 설정을 변경해야 한다.
    2. 기존의 PLAINTEXT로 통신하는 부분은 남겨두고 SSL 통신을 추가하는 형태로 설정해 기존의 통신은 유지하면서 추가로 SSL 통신도 가능하게 한다.
    3. 암/복호화로 인한 오버헤드를 줄이기 위해서 신뢰하는 브로커간의 통신은 PLAINTEXT로 하고 서버-클라이언트간의 통신은 SSL 통신을 하도록 분리할 수 있다.
7. SSL 기반 메시지 전송
    1. 설정한 SSL 통신으로 테스트 전송을 진행해본다.

# 커버로스(SASL)를 이용한 카프카 인증

## 커버로스

- 커버로스는 티켓을 기반으로 하는 컴퓨터 네트워크 인증 프로토콜로서, 사용자의 신원을 식별하기 위한 용도로 사용된다.
- 하나의 커버로스 티켓을 이용해 여러 서비스에서 같이 적용할 수 있는 싱글 사인온(Single Sign-On, SSO)을 지원하기 때문에 많이 사용된다.

## 커버로스를 이용한 카프카 인증 과정

1. 우선 커버로스 서버가 필요하기에 커버로스 서버를 따로 구성해야 한다.
2. `scp` 라는 툴을 이용해 커버로스 서버에 접근하기 위한 pem 키를 모든 브로커에 복사한다.
3. 모든 서버의 `/etc/krb5.conf` 파일에서 렐름 정보를 추가한다.
4. 모든 브로커에서 `server.properties` 설정을 변경한다.
    1. listeners, adverties.listeners, security.inter.broker.protocol 항목을 변경한다.
5. `jaas.conf` 파일을 생성한다.
    1. JASS(Java Authentication and Authorization Service)는 자바 애플리케이션의 유연성을 위해 사용자 인증에 대한 부분을 분리해 독립적으로 관리할 수 있는 표준 API이다.
6. `kafka_server_jaas.conf` 파일이 브로커 시작 시 로드할 수 있도록 **KAFKA_OPTS** 카프카 환경 변수에 설정을 추가한다.
7. 브로커를 재시작한다.
8. 클라이언트 커버로스 설정
9. 서버와 동일하게 `kafka_client_jaas.conf` 파일을 생성해 관련 설정을 작성한다.
10. 클라이언트도 KAFKA_OPTS 환경 변수를 이용해 `kafka_client_jaas.conf` 설정을 로드하도록 추가한다.
11. 콘솔 프로듀서와 콘솔 컨슈머에서 사용할 `kerberos.config` 파일을 생성해 관련 설정을 추가한다.
12. `klist` 를 이용해 정상적으로 티켓이 발급됐는지 확인한다.

# ACL을 이용한 카프카 권한 설정

카프카에서의 권할 설정을 위해 ACL을 사용하는데 브로커의 설정 파일을 수정하고 `kafka-acls.sh` 명령어를 이용해 유저별 권한을 설정하자.

## 카프카 권한 설정 과정

1. 브로커 권한 설정
    1. `/usr/local/kafka/config/server.properties` 파일을 수정해서 브로커의 설정을 변경하자.
    2. authorizer.class.name, super.users 를 변경한다.
    3. 권한 설정에서는 차단 정책의 우선순위가 가장 높다.
2. 브로커를 재시작한다.
3. 유저별 권한 설정
    1. `kafka-acls.sh` 명령어를 이용해 유저에 대한 ACL 규칙을 생성한다.
    2. 현재 적용되어 있는 ACL 규칙의 리스트는 `--list` 파라미터를 추가해 확인할 수 있다.
4. 리소스 그룹에 대한 ACL 규칙을 추가한다.
    1. 카프카에서는 리소스 타입으로 권한을 설정하도록 구분되어 있기에 컨슈머 그룹에 대한 권한 설정은 그룹 리소스 타입의 권한이 필요하다.