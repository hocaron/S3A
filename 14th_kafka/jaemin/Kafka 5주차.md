# Kafka 5주차

‘컨슈머의 기본 동작’에서 다루지 못했던 주제인 컨슈머 그룹, 오프셋 관리, 컨슈머들의 파티션 할당 정책과 트랜잭션 컨슈머의 내부 동작을 자세히 살펴보자.

# 컨슈머 오프셋 관리

컨슈머는 카프카에 저장된 메시지를 꺼내오는 역할을 하기 때문에 컨슈머가 메시지를 어디까지 가져왔는지를 정확히 표시하는 것이 매우 중요하다. 카프카에서는 메시지의 위치를 나타내는 위치를 **오프셋**이라고 부르는데 이 오프셋은 숫자 형태로 나타내며, 가장 안전한 저장소인 토픽 __consumer__offsets 토픽에 각 컨슈머 그룹별로 오프셋 위치 정보를 기록한다.

컨슈머 그룹에서 __consumer__offsets 에 오프셋을 기록할 때 컨슈머가 마지막까지 읽은 위치가 아니라 다음 읽어야 하는 위치를 가르킨다. __consumer__offsets의 파티션 수와 리플리케이션 팩터 수는 기본값만 사용해도 충분하다.

**기본값**

- 파티션: 50
- 리플리케이션 팩터: 3

# 그룹 코디네이터

컨슈머들은 하나의 컨슈머 그룹에 속하고 언제든 이를 떠날 수도 새로운 컨슈머가 합류할 수도 있기에 이러한 변화를 감지하고 각 컨슈머들에게 작업을 균등하게 분배해야 한다. 이렇게 변화가 일어나 각 컨슈머들에게 작업을 균등하게 분해하는 동작을 **컨슈머 리밸런싱**이라고 한다.

이러한 변화를 감지하기 위해 그룹 코디네이터를 사용하는데 이 코디네이터의 목적은 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹하는것이다. 이 코디네이터는 카프카 클러스터 내의 브로커 중 하나에 위치한다.

## 컨슈머 그룹 등록 과정

1. 컨슈머는 컨슈머 설정값 중 bootstrap.brokers 리스트에 있는 브로커에게 컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청을 보낸다
2. 해당 요청을 받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에게 응답한다. 컨슈머 그룹의 첫 번째 컨슈머가 등록되기 전까지 아무 일도 일어나지 않는다.
3. 그룹 코디네이터는 group.initial.rebalance.delay.ms의 시간 동안 컨슈머의 요청을 기다린다
4. 컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보낸다. 이 때 가장 먼저 요청을 보낸 컨슈머가 해당 그룹의 리더가 된다
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는 해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등 리더 컨슈머의 요청에 응답을 보낸다
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당하고 그룹 코디네티어게 전달한다
7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알린다
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메시지들을 가져온다

### 특징

- 우리는 bootstrap.brokers와 group.id만 설정하면 컨슈머 그룹이 생성돼 메시지를 갖고 온다고 생각했는데 실제로는 컨슈머 그룹과 그룹 코디네이터의 긴밀한 협력으로 이게 가능했다
- 이제 컨슈머 그룹은 그룹 코디네이터의 관리를 받게 되며 컨슈머들은 해당 그룹을 leave 할 수도, join할 수도 있는데 만약 leave요청을 보내지 못하고 종료가 되는경우 어떻게 할까?
- 컨슈머들의 변경 감지를 위해 그룹 코디네이터와 컨슈머들은 서로 하트비트를 주고 받는다.

### 컨슈머 하트비트 옵션

- heartbeat.interval.ms
    - def: 3000
    - 그룹 코디네이터와 하트비트 인터벌 시간.
    - session.timeout.ms보다 낮게 설정해야 함. 1/3이 적당
- session.timeout.ms
    - def: 1000
    - 어떤 컨슈머가 특정 시간 안에 하트비트를 받지 못하면 문제가 발생했다고 판단하는 시간
    - 문제가 발생하면 컨슈머 그룹에서 해당 컨슈머는 제거되고 리밸런싱 동작
- max.poll.interval.ms
    - def: 300000
    - 컨슈머는 주기적으로 poll을 호출해 토픽으로부터 레코드들을 가져오는데 poll()호출 후 최대 5분간 poll 호출이 없다면 문제가 있다고 판단하고 리밸런싱 동작

### 특징

- 하트비트 뿐 아니라 poll 동작 여부까지 확인해서 리밸런싱 동작이 일어날지를 판단한다.
- 리밸런싱의 비용은 매우 높기에 너무 빈번하게 발생하지 않는게 좋다
- 기본적으로 기본값을 사용하되 반드시 필요한 경우에만 관련 옵션값을 조정하자

# 스태틱 멤버십

## 리밸런싱이 일어나는 배경

하드웨어 점검이나 소프트웨어 업데이터 등의 이유로 컨슈머 그룹 내의 컨슈머들이 순차적으로 재시작하는 경우가 있을 수 있다. 만약 10개의 컨슈머가 있는 그룹의 경우 총 10번 이상의 리밸런싱이 일어날 수 있다. 이 이유는 컨슈머는 컨슈머 그룹내에서 각 컨슈머들을 식별하기 위한 엔티티 ID를 부여받게 되는데 컨슈머가 재시작되면 기존에 있던 ID를 부여받는게 아니라 새로운 ID를 부여받기에  새로운 컨슈머로 인식되어 컨슈머 그룹의 리밸런싱이 발생한다.

## 스태틱 멤버십의 기능

대용량 메시지들을 처리하는 컨슈머 그룹이라면 이 리밸런싱 동작으로 원래 상태를 복구하는데 상당한 시간이 소요될 수 있다. 이러한 불필요한 리밸런싱을 막기 위해 **스태틱 멤버십**이라는 개념이 도입되었다. 스태틱 멤버십은 컨슈머 그룹 내 컨슈머가 재시작 등으로 그룹을 나갔다 들어와도 리밸런싱이 일어나지 않게 한다. 이는 나가는 컨슈머마다 인식할 수 있는 ID를 부여해 기존 구성원임을 인식하게 하는것이고 이 기능을 가진 컨슈머는 그룹을 나가도 그룹 코디네이터에게 알리지 않아 불필요한 리밸런싱도 발생하지 않는다.

## 스태틱 멤버십 활용법

스태틱 멤버십의 재시작의 경우 나갈 때 한 번, 들어올 때 또 한 번 총 두 번의 불필요한 리밸런싱을 회피할 수 있다. 이를 사용하기 위해 기본값이 `null` 인 `group.instance.id`만 설정해주면 된다. 아파치 카프카 버전이 2.3이상이어야 하고 보통 접두어로 `consumer-` , 접미어에 호스트네임이나 서버의 IP 등을 붙이기도 한다

스태틱 멤버십을 적용한 경우면 당연히 `session.timeout.ms`를 기본값보다 큰 값으로 조정해 재시작하고 난 후 합류할 시간 이상으로 설정해야 한다.

# 컨슈머 파티션 할당 전략

컨슈머의 동작에서 특정 토픽의 어느 파티션으로부터 레코드를 읽어야 할지를 정할 필요성이 있다. 이렇게 파티션 할당 전략은 컨슈머 옵션의 `partition.assignment.strategy`로 표시하며 아래 4개의 전략들이 있다.

| 파티션 할당 전략 | 설명 |
| --- | --- |
| 레인지 파티션 할당 전략 | 파티션 할당 전략의 기본값으로서 토픽별로 할당 전략을 사용. 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 유용 |
| 라운드 로빈 파티션 할당 전략 | 사용 가능한 파티션과 컨슈머들을 라운드 로빈으로 할당. 균등한 분배 가능 |
| 스티키 파티션 할당 전략 | 컨슈머가 컨슘하고 있는 파티션을 계속 유지할 수 있음 |
| 협력적 스티키 파티션 할당 전략 | 스티키 방식과 유사. 전체 일시 정지가 아닌 연속적인 재조정 방식 |

## 레인지 파티션 할당 전략

### 동작 방식

1. 먼저 구독하는 토픽에 대한 파티션을 순서대로 나열한다. 
2. 컨슈머를 순서대로 정렬한다.
3. 각 컨슈머가 몇 개의 파티션을 할당해야 하는지 전체 파티션 수를 컨슈머 수로 나눈다
4. 컨슈머 수와 파티션 수가 일치하면 균등하게 할당 할 수 있지만 균등하게 나눠지지 않는 경우에는 앞쪽의 컨슈머들은 추가 파티션을 할당바든ㄴ다

### 특징

- 파티션 할당 전략 중 기본값이며, 각 토픽별로 할당 전략을 사용한다
- 동일한 레코드 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용하게 사용할 수 있다
- 컨슈머에 균등하게 파티션이 분배되지 않을 가능성이 있다
- 특수한 환경에서 사용하는 것이 좋다

## 라운드 로빈 파티션 할당 전략

### 동작 방식

1. 구독 대상 토픽의 전체 파티션을 나열한다
2. 전체 컨슈머들도 나열한다
3. 나열된 파티션을 컨슈머들과 하나씩 라운드 로빈 방식으로 일대일 매핑한다

### 특징

- 파티션 할당 전략 중 가장 간단한 할당 방식
- 레인 파티션 할당 전략에 비해 파티션과 컨슈머를 더욱 균등하게 매핑할 수 있다

## 스티키 파티션 할당 전략

위의 두 방식은 리밸런싱 동작이 일어나면 각 컨슈머들이 구독하는 파티션이 달라질 가능성이 크다. 이를 방지하기 위해 스티키 파티션 할당 전략이라는 개념이 공개됐다.

스티키 파티션 할당 전략은 **균형 잡힌 파티션 할당**, 재할당이 발생할때 되도록 **기존에 할당된 파티션 정보를 보장**하는 것을 목표로 한다. 후자보다는 전자의 목적의 우선순위가 높다. 따라서 스티키 파티션 할당 전략이라 해서 무조건 기존의 파티션과 컨슈머를 유지하지는 않는다.

### 동작 방식

최초 할당 방식은 라운드 로빈과 흡사하나 리밸런싱 이후의 동작의 차이가 있다.

**라운드 로빈의 리밸런싱 동작**

1. 컨슈머2가 컨슈머 그룹에서 떠남
2. 리밸런싱 동작이 일어남
3. 모든 파티션을 순서대로 배치
4. 모든 컨슈머를 순서대로 배치
5. 라운드 로빈 파티션 할당 전략에 맞춰 하나씩 매핑

**스티키 방식의 리밸런싱 동작**

1. 컨슈머2가 컨슈머 그룹에서 떠남
2. 리밸런싱 동작이 일어남
3. 기존 컨슈머들이 할당됐던 파티션들은 모두 유지한 채 떠난 컨슈머2에 할당된 파티션들만 나머지 컨슈머에 할당

**스티키 파티션 할당 전략이 이상적으로 동작하는 이유**

- 컨슈머들의 최대 할당된 파티션의 수의 차이는 1
- 기존에 존재하는 파티션 할당은 최대한 유지
- 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거
- 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에 할당

## 협력적 스티키 파티션 할당 전략

협력적 스티키 파티션 할당 전략을 결과적으로 본다면 기존 스티키 파티션 할당 전략과 동일한 방식이다. 다만 차이점은 컨슈머 그룹 내부의 리밸런싱 동작을 한층 더 고도화 했다는 것이다.

지금까지의 컨슈머 리밸런싱 동작은 EAGER라는 리밸런스 프로토콜을 사용했는데 이 방식은 리밸런싱 동작에서 모든 파티션을 항상 취소하였다. 그 이유는 첫째로 컨슈머들의 파티션 소유권 변경때문이었다. 컨슈머는 하나의 파티션만을 할당해야 하기 때문에 먼저 파티션을 취소해야 소유권 변경 작업을 할 수 있기 때문이다. 둘째는 이 작업을 편안하게 구현하기 위해서이다. 

이렇게 리밸런싱 동작에서 컨슈머에 할당된 모든 파티션을 취소하는 동작은 리소스를 많이 사용하는 컨슈머 그룹에는 큰 문제가 된다. 바로 컨슈머들의 다운타입이다.

협력적 스티키 파티션 할당 전략은 이렇게 리밸런싱 동작 중 모든 파티션을 취소하는 것이 아니라 점진적으로 몇 차례에 걸쳐 리밸런싱을 해 기존에 이미 컨슘중인 컨슈머들에게 피해를 최소화해 다운타임을 줄이자는 아이디어에서 발생한 개념이다.

### 동작 방식

1. 컨슈머 그룹에 peter-kafka01 컨슈머가 합류해 리밸런싱이 트리거됨
2. 컨슈머 그룹 내 컨슈머들은 그룹 합류 요청과 자신들이 컨슘하는 토픽의 파티션 정보를 그룹 코디네이터로 전송
3. 그룹 코디네이터는 해당 정보를 조합해 컨슈머 그룹의 리더에게 전송
4. 컨슈머 그룹의 리더는 현재 컨슈머들이 소유한 파티션 정보를 활용해 제외해야 할 파티션 정보를 담은 새로운 파티션 할당 정보를 컨슈머 그룹 멤버들에게 전달
5. 새로운 파티션 할당 정보를 받은 컨슈머 그룹 멤버들은 현재의 파티션 할당 전략과 비교해보고 필요없는 파티션을 골라 제외
6. 제외된 파티션 할당을 위해 컨슈머들은 다시 합류 요청을 함
7. 컨슈머 그룹의 리더는 제외된 파티션을 적절한 컨슈머에게 할당

→ 이를 통해 컨슈머의 영향을 최소화 하고 점진적인 리밸런싱을 하더라도 최종적으로는 컨슈머들은 균형 잡힌 분산을 하게 된다. 이러한 장점으로 관리자들은 컨슈머의 확장 및 축소, 롤링 재시작 등의 작업 시 부담을 줄일 수 있게 되었다.

# 정확히 한 번 컨슈머 동작

프로듀서는 ‘정확히 한 번 전송’을 하면서 트랜잭션 코디네이터를 사용하는데 이 코디네이터는 정확히 한 번 전송이 성공하면 특수한 메시지를 표시하는데 이 특수한 메시지를 표시한 레코드만 읽는다면 컨슈머는 정확히 한 번 읽을 수 있다.

단순히 일반 컨슈머 코드에서 `ISOLATION_LEVEL_CONFIG` 라는 설정만 추가하면 되고 트랜잭션 컨슈머는 트랜잭션 코디네이터와 통신하는 부분은 없으면 트랜잭션이 완료된 메시지만 읽을 수 있다. `ISOLATION_LEVEL_CONFIG` 를 기본값인 `read_uncommitted` 에서 `read_committed`로 변경해주자.

## 과연 트랜잭션 컨슈머는 정확히 한 번만 가져올까?

아니다! 프로듀서의 경우엔 트랜잭션 코디네이터와 통신하면서 트랜잭션이 정확하게 처리되는 것을 보장했지만 컨슈머의 경우 트랜잭션 프로듀서가 보낸 메시지만 가져올 수 있는지에 대해서만 옵셔으로 선택하고 트랜잭션 코디네이터와 통신하지는 않기에 이를 보장할 수는 없다!

또한 컨슈머에 의해 컨슘된 메시지가 다른 싱크 저장소로 중복 저장될 수 있다. 카프카 클라이언트인 컨슈머는 다른 싱크 저장소로 메시지들이 중복 저장되는 결과를 알 수 없으므로 정확히 한 번 저장또한 보장할 수 없다.

컨슈머의 동작까지 정확히 한 번 처리가 가능해지려면 ‘컨슘-메시지 처리-프로듀싱’ 동작이 모두 하나의 트랜잭션에 포함되어야 한다. `컨슘- 메시지 처리 - 프로듀싱` 의 트랜잭션에서는 `sendOffsetsToTransaction` 메소드를 이용해 컨슈머 그룹의 오프셋 커밋을 트랜잭션에 포함시킨다. 만약 이게 실패하면 해당 컨슈머 그룹의 커밋 오프셋을 증가시키지 않기에 실패한 트랜잭션을 다시 시작할 수 있다.

## 그럼 프로듀서-카프카 구간과 카프카-컨슈머 구간 모두에서 정확히 한 번 메시지 전송이 가능할까?

아니다! 하지만 카프카 커넥트 중에서 `HDFS 커넥터`의 경우 정확히 한 번 저장되도록 지원하기도 하므로 사용하고자 하는 컨슈머 애플리케이션이 양 종단 간 정확히 한 번 메시지 전송을 지원하는지 확인해보자!