# Item [11 ~ 15]

- 일자: 2024년 4월 30일
- MC: 박범근
- 참석자: 한정민, 박범근, 예원 오, 김보배


## Item 11. 가독성을 목표로 설계하라

- 71p) 프로그래밍은 쓰기보다 읽기가 중요하다는 의미 (인지부하를 줄이는 방향으로 코드를 작성하라)
    - 정민 ) 코드가 더러우면 업무 의지가 팍 죽어버려 그냥
    - 보배 ) 명대사인듯 기억해야함
      - 코틀린 처음배울 땐 여러가지 함수/키워드를 사용하는게 잘하는 건지 알고 모잇 때 코드 보면 scope function 강제로 막 썼던게 기억남…ㅋㅋ
    - 예원 ) 가끔 코틀린 여러 함수들을 잘 쓰시는 분이 계신데 그때마다 미운 감정과 내가 잘 알아야하는데,, 하는 감정 둘..
    - 범근) 코틀린 처음 써보는 시절에 저렇게 코틀린 함수 남발하다가,,,
- 75p) 물론 어떤 것이 비용을 지불할 만한 코드인지 아닌지는 항상 논란이 있을 수 있습니다.
    - 보배) 경험이 참 중요. 경험에서 이런 노하우를 깨닫고 무기로 가져가야하는 듯
    - 범근) 22, 하지만 이 비용은 지불할 만한 가치가 있으므로 → 어떤 가치가 있을까요??
- 76p) `infix`
    - 정민) 많이들 쓰시나요 **두 개의 객체 중간에 들어가게 되는 함수 형태를 `Infix Function` 라고 하는군요**
    - 예원) 직접 정의해본 적은 없지만, 라이브러리로 존재하는걸 잘 씀 (특히 QueryBuilder 같은거에서..)
    - 범근) 오늘 책 읽으면서 찾아봤습니다…
    
- kotlin DSL 이란
    DSL은 Domain Specific Language의 약자로, 특정 분야나 도메인에 특화된 프로그래밍 언어를 의미합니다.
    Kotlin DSL은 Kotlin 언어를 사용하여 DSL을 작성하는 것을 말합니다. 이를 통해 더욱 간결하고 읽기 쉬운 코드를 작성할 수 있습니다. Kotlin DSL은 Gradle 스크립트, HTML 또는 XML 생성, 테스트 코드 작성 등 다양한 곳에서 사용됩니다.
    예를 들어, Gradle에서는 Groovy를 기반으로 스크립트를 작성했지만, Kotlin DSL을 사용하면 Kotlin으로 Gradle 스크립트를 작성할 수 있습니다. 이렇게 하면 코드가 더욱 간결해지고, IDE의 지원을 더 잘 받을 수 있습니다.
    
- QueryBuilder와 ORM 의 차이
    QueryBuilder와 ORM(Object-Relational Mapping)은 데이터베이스와 상호작용하는 두 가지 다른 방법입니다.
    
    1. QueryBuilder: 이것은 데이터베이스 쿼리를 작성하는 데 사용되는 프로그래밍 인터페이스입니다. QueryBuilder를 사용하면 SQL 쿼리를 문자열로 작성하는 대신 메서드 체인을 사용하여 쿼리를 작성하고 실행할 수 있습니다. 이 방법은 코드를 더 읽기 쉽고 유지 관리하기 쉽게 만들어주며, SQL 쿼리를 작성하는 데 필요한 구문을 완전히 이해하지 못해도 쿼리를 작성할 수 있게 해줍니다.
    
    2. ORM: 이것은 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환성을 높이는 프로그래밍 기술입니다. ORM을 사용하면 데이터베이스 테이블을 클래스로, 테이블의 행을 클래스의 인스턴스로, 테이블의 열을 클래스의 속성으로 매핑할 수 있습니다. 이 방법은 데이터베이스와 상호작용하는 코드를 더욱 간결하고 이해하기 쉽게 만들어주며, SQL 쿼리를 거의 또는 전혀 작성하지 않고도 데이터베이스와 상호작용할 수 있게 해줍니다.
    따라서, QueryBuilder와 ORM은 비슷한 목표를 가지고 있지만, 그 방법과 사용되는 경우가 다릅니다. QueryBuilder는 SQL 쿼리를 작성하는 데 초점을 맞추고 있으며, ORM은 객체 지향 프로그래밍과 데이터베이스 간의 간극을 줄이는 데 초점을 맞추고 있습니다.

## Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라

- 78p)
    - 보배) 연산자가 특정 함수로 대응되고 있으며 대체될 수 있는 것을 이번에 알았음
- 톱레벨 함수?
    - 예원) 클래스 내부에 선언된 것이 아닌, 파일의 최상위 레벨에 선언된 함수
        - 뭐지.. 했는데, 클래스 밖에다 함수를 선언하고 이걸 활용할 수 있게 하는걸 말하는거였음
        - 자바는 이게 없구나.
        - ~~나는 확장함수의 형태로 많이 썼던 것 같음.~~
            - 확장함수 ≠ 톱레벨 함수 ??
            - 지피티샘 대답
                
                코틀린의 확장 함수는 톱 레벨 함수로 선언될 수 있지만, 반드시 그렇게 선언될 필요는 없습니다. 확장 함수는 클래스의 멤버 함수처럼 호출할 수 있지만, 실제로는 그 클래스의 일부가 아닌 외부에 선언된 함수입니다. 이는 클래스의 내부 상태를 변경할 수 없다는 것을 의미합니다.
                확장 함수는 클래스 밖에서 선언되므로, 그 함수가 선언된 범위 내에서만 사용할 수 있습니다. 이 범위는 톱 레벨(파일 레벨), 클래스 내부, 컴패니언 오브젝트 등이 될 수 있습니다. 따라서 확장 함수는 톱 레벨 함수일 수도 있고, 그렇지 않을 수도 있습니다.
                
        - 보배) 좀 위험할듯
- 범근) 평소에 연산자 오버로딩을 사용하진 않아서, 내용은 이해가 되는데 음… 그치 이런 느낌

## Item 13. Unit?을 리턴하지 말라

- 범근) Unit? 리턴타입인건 한번도 못보기도하고, 써보지도 않은듯?!
- 정민) `Unit?`  저걸 저렇게 쓸 수도 있구나. 22 시도 조차안하고 보지도 못함
    - 222222예원 난생첨보네

## Item 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라

- 범근) 저는 웬만하면 다 타입 지정하는 편…
- 정민) 타입을 지정하자!
    - 예원) 22
- 84p) 코드를 읽으면서 함수 정의를 보며 타입을 확인하면 되지 않나? 라고 생각할 수 있지만, 이는 곧 가독성이 떨어진다는 의미입니다.
    - 보배) 프로젝트가 커지면 커질 수록 이런 것들은 크게 다가오는 듯. PR 같은 것도 Pull 안받고 머릿속에서 계산이 되고…
        - 범근) Pull 안받고도 PR 코드가 머릿속에서 다 연산이 된다는?!
    - 예원) 요 부분 읽고 뼈맞음

## Item 15. 리시버를 명시적으로 참조하라

- 정민)  `also`, `let` , `apply`, `run`, with 많이 들 쓰십니까?
    - 보배) 코드 하나씩 다 깔필요 없이 간결하게 쓸 수 있어서 보기 좋다고 생각해서 전 많이 사용했었습니다. 근데 과사용은 역시 안좋은 듯… 아직 어색하다면 일단 사용안하고 나중에 리팩터링하는 게 좋아보임
        
        ```kotlin
        // 종합 선물세트 같지만, 종합 쓰레기 세트다.
        val result = Person.withDefaultName()
            .apply { name = "매시업" }
            .run { name.length }
            .also { println("이름의 길이는? $it") }
            .let { name -> name + 1 }
        ```
        
    - 예원) 체이닝 형태에서 유용하게 그리고 꽤 자주 쓰긴하는데, 막 여러개 이어서 써보진 않은듯…
    - 범근) 저도 특정 상황에서 한두개씩 사용한 것 같아요
- 정민)  `@` (레이블)는 scope return 때만 썼네요
    - 예원) 저는 가끔 매핑코드에서도 썼던 것 같아요.
    - 범근) 전 기존 코드에서만 return에 붙어있는것만 보고, 직접 사용해본적은..
- 88p) 이를 사용하려면 unpack 해야합니다.
    - 정민) 기존 `this`(Node 클래스) 를 Node? 로 언팩한다는 얘긴가요?
    보통 pack 은 감쌀 수 있는 클래스로 감싸는 걸 의미하는데, 
    Node? > Node 아닌가
    - 보배) 그러게. 뭔가 말이 이상하네. 아무튼 저렇게 짜는거 겁나게 복잡하다.
    - 예원) this 를 붙여주는게 언팩인가보다 했는데.. 언팩이뭘까요 여러분
    - 범근) 제가 이해하기로는 create함수의 리턴값이 Node?이라서 코드 내부에서 this.name할때 this를 안전호출 (?.)로 꺼내서 name을 호출해야한다고 이해했는데 아닌가요??
- 88p) 일반적으로 also, let을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택지 입니다.
    - 보배) scope function들은 맨날 지칭하는게 뭐였지, 각자의 역할이 어떻게 달랐지?가 헷갈림
        - [https://kotlinlang.org/docs/scope-functions.html](https://kotlinlang.org/docs/scope-functions.html)
        - [https://hyeon9mak.github.io/using-kotlin-scope-function-correctly/](https://hyeon9mak.github.io/using-kotlin-scope-function-correctly/)
        - 찾아보니 아래와 같은 것들이 있음
            
            <img width="1392" alt="image" src="https://github.com/mash-up-kr/S3A/assets/66156531/6fae3a4a-9985-4bf7-9fbb-d30f84b8306b">
            
            <img width="1412" alt="image" src="https://github.com/mash-up-kr/S3A/assets/66156531/9fe7e93f-f076-4cd4-8ec4-241ab9881ca9">
            
            <img width="1466" alt="image" src="https://github.com/mash-up-kr/S3A/assets/66156531/0c5d2ee0-8338-4f4f-8e2d-0f826cf3a3dc">
            
             - 예원) ^ 요거 괜찬네 / 나는 람다 결과값을 리턴하냐 안하냐 정도로만 구분하고 뭔가 이해 더 잘되는 리시버 함수를 쓰는 ㅍ편..
            
            - 범근) 저도 맨날 헷갈려요.
- 91p) DSL 마커는 가장 가까운 리시버만을 사용하게 하거나, 명시적으로 외부 리시버를 사용하지 못하게 할 때 활용할 수 있는 굉장히 중요한 메커니즘입니다.
    - 예원) 첨보는데 써보신분..?