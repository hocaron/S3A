# Item [16 ~ 20]

일자: 2024년 5월 7일
MC: 김보배
참석자: 예원 오, 한정민, 김보배, 박범근

## Item16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다

- 93p) var를 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있고, 이를 파생 프로퍼티(derived property) 라고 부른다.
    - 예원) val, var 모두 포함인건가
    - 정민) val 도 포함인듯 그냥 의미자체가 **다른 프로퍼티에서 가져오는 프로퍼티 느낌**
    
    ```kotlin
    class A(var a: String, var b: String, var c: String) {
    	val aPlusB
        	get() = "$a $b"
    }
    ```
    
    - 보배) 정민 의견 공감. 책에선 나도 이해안됬는데 검색해보니 **그냥 다른 프로퍼티를 이용해 또 다른 프로퍼티를 구성한다는 개념**으로 보임.
    - 범근) 아하 이 글 보고 이해함. 그냥 그런가보다하고 넘어갈뻔
- 93p) Date 사용하던 객체 바꿀때.. 어쩌고.
    - 예원) ~~이해가 안감~~ 이해 완료 (예원이 신남)
    
    ```kotlin
    // [Date를 사용하는데 인풋은 millis인 상황]
    // needs: DB millis가 있어서 매핑이 되는데, 
    // 이를 코드 단에서 활용할 땐 Date로 이용할 수 있게 구성하고 싶다.
    
    var millis: Long
    var date: Date
    	get() = Date(millis) // wrap
    	set(value) {
    		millis = value.time
    	}
    	
    --------------
    // 예원 이해 버전
    import java.util.Date
    
    var millis: Long = 0 // 쓰고싶은 것
    var date: Date
        get() = Date(millis)
        set(value) { // date를 넣어라. (value가 date타입)
            millis = value.time
        }
    
    // 기존에 사용하던 것
    var origin = Date(34253632)
    
    // date 에 origin을 넣었을 때
    date = origin
    
    /// millis 값이 바뀜
    print(millis)
    
    ```
    
- 93p) 프로퍼티는 필드가 필요 없습니다.
    - 정민) 뭔말이야
    - 보배) 프로퍼티, 필드의 개념이 헷갈림; 이 둘의 차이가 뭐야? 나는 이 둘을 혼재되게 사용했던 것 같음. 그래서 더 헷갈림.
    - 범근) 코틀린인 액션에서는 “**자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부른다.** val은 읽기 전용 프로퍼티로 (비공개) 필드와 필드를 읽는 단순 (공개) 게터를 만들어낸다” 라고 되어있는데..
- 93p) 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있는 것이다.
    - 정민) 나도 서비스 클래스를 요렇게 인터페이스로 정의해서 동일하게 Injection 해야하는 프로퍼티 
    `override val` 로 구현체에서 쓰고 있습니다.
    - 보배) 이렇게 해도 DI가 되는구나.
- 93 -94p) 프로퍼티는 개념적으로 접근자를 나타냄. 본질적으로 함수임 (→ 확장 프로퍼티 만들 수 있음)
    - 예원) 확장 프로퍼티를 만들어본적이 없는데 해보신 분?
    - 정민) 없습니다. 첨 알았음..ㅋ 이런식으로 쓰나보네요
      
        ```kotlin
        val String.lastChar: Char
            get() = get(length - 1)
        var StringBuilder.lastChar: Char
            get() = get(length - 1)
            set(value: Char) {
                this.setCharAt(length - 1, value)
            }
        
        fun main(args: Array<String>) {
            println("Kotlin".lastChar)
            val sb = StringBuilder("Kotlin?")
            sb.lastChar = '!'
            println(sb)
        }
        
        // n
        // Kotlin!
        ```
        
    - 범근) 이런거 안써요. 안삽니다
- 95p) ~ 프로퍼티 대신 함수를 사용하는 것이 좋은 경우 ~ 경험적으로 프로퍼티는 상태 집합을 나타내고, 함수는 행동을 나타낸다고 생각한다.
    - 예원) 종종 고민하곤 하는데 좋은 지표가 되어줌.
        - 문제: `isDeleted` 라는 데이터를 프로퍼티로 할래 함수로 할래! ⇒ **상태값이라 프로퍼티**
          
            ```kotlin
            // property
            val isDeleted = deletedAt != null // 일종의 파생 프로퍼티고
            
            // getter
            fun isDeleted() = deletedAt != null // 이 둘중에 하나에서 고르라햇던거
            ```
            
            - 보배) delete 불린 값. `is` → method에 붙이는거지 변수에 들어가는게 아니다. (이펙티브 자바 변수명)
        - 범근) 옳소 프로퍼티에서 제공해주는 접근자를 사용할땐 get은 해당 프로퍼티의 데이터나 값을 꺼내고, set은 정말 값을 설정하는 용도로만. **특정 로직이 포함되는 순간 get, set 의 기대가 무너질 수 있을듯**
- 95p) 변환의 경우: 변환은 관습적으로 Int.toDouble()과 같은 변환함수로 이루어집니다. 따라서 이러한 변환을 프로퍼티로 만들면, 오해를 불러 일으킬 수 있습니다.
    - 보배) 이거 93p Date 예제 아닌가? 이런 변환도 함수로 해야하는건가? 라는 생각에 머리 지진.
      
        ```kotlin
        var date: Date
        	get() = Date(millis) // 호출할 때마다 Wrapping 변환
        	set(value) {
        		millis = value.time
        	}
        ```
        

## Item 17. 이름 있는 아규먼트(named argument)를 사용하라

- 보배) 이름 있는 아규먼트는 무조건 사용하는게 좋을까?
    - 여러 같은 타입의 아규먼트를 구성하는 경우엔 필수 인 것 같음 (또는 빌더 패턴, 이펙티브 자바에서도 나왔던 듯)
    - 예원) 헷갈릴 것 같으면 사용
    - 정민) caller에서 callee랑 어규먼트/파라미터 변수 이름이 같은 경우엔 사용안함. 데이터 클래스에서 필드가 엄청 많다보니 활용.
    - 범근) 왠만하면 다 쓴다. 코드를 친절하게 짜는 것을 좋아함. 리턴 타입도 다 적어주는 편
- 예원) 의미를 명확하게 하고, 헷갈리지 않게 하는 named argument는 개꿀이다
- 정민) data class (BO) 에 프로퍼티가 많기도 하고 nullable 인 애들이 많아서(default Argument = null), named argument 요긴하게 사용중
- 범근) 저는 이름 웬만하면 다 붙이는중. 가물가물한데 옛날에 파라미터가 많은 함수가 다 string 형태라 파라미터 순서 잘못 넣어서 계속 테스트가 실패했던 기억이 있습니다. 이름 있는 아규먼트 붙이면 파라미터 순서 상관 안쓰고 각 파라미터에 맞는 값이 들어가니까.. (p.99 같은 타입의 파라미터가 많은 경우)
- 자바 함수를 호출할 때는 이름 있는 파라미터를 사용할 수 없기 때문입니다.
    - 보배) 처음 알았음. 자바 함수는 못하는 군…



## Item 18. 코딩 컨벤션을 지켜라

- 103p) **코틀린은 굉장히 잘 정리된 코딩 컨벤션을 갖고 있습니다.**
    - 예원) 다들 컨벤션 어떻게 하고 계신가여? 우리는 ktlint
    - 정민) 저희도 ktlint 사용중. 다만 불편한 점이  함수 혹은 클래스 시그니처 정의시 마지막 `,` 랑 
    아규먼트 2개 이상 시 무조건 줄 바꿈인 점은 아직 불편함. → 우리 리뷰에서도 시니어분이 무리한 개행 아닌가요 하면서 리뷰달렸음.
    - 보배) ktlint랑 editorconfig가 공존하나 싶어 찾아봤더니 default로 ktlint를 사용하고, disable하고 싶은 경우 editorconfig로 명시해서 처리할 수 있는 듯?
        - [https://beaniejoy.tistory.com/108](https://beaniejoy.tistory.com/108)
    - 범근)  `./gradlew ktlintCheck`
- 103p) 그렇다면 java formatting 은 무엇을 기준으로 하시나요? 툴이나?
    - 정민) 우리는 사내 컨벤션 formatter 넣어서 iDE에 쓰긴 합니다. (XML)
    - 보배) 요즘은 코틀린이나 자바나 editorconfig가 다 지원하는 듯?
- ktlint 파일 이름 무시하는거..
    - [https://stackoverflow.com/questions/57395287/how-to-disable-filename-in-ktlint](https://stackoverflow.com/questions/57395287/how-to-disable-filename-in-ktlint)

```kotlin
// ktlint-disable filename
```

- 105p) 프로젝트의 모든 코드는 여러 사람이 싸우는 느낌으로 작성되면 안 되며, **마치 한 사람이 작성한 것처럼 작성**되어야 합니다.
    - 보배) 좋은 내용 같음. 무조건 한 사람처럼 보여야 됩니다는 아니지만, 거의 그렇게 보여야 읽거나 개발 중에 짜증나는 일이 없지 않을까? (괜히 뭔가 고치고 싶고 이런 마음 안들게…)
        - 이전에 대화 중 “이건 누구님 코드 같아요”라는 이야기를 들었는데(부정적인 질문이 아닌 그냥 누가 코드 짰나 궁금해할 때/blame 안해보고 봤을 때), 그런 경우엔 컨벤션이 없거나 잘 안지켜진 경우라고 볼 수 있지 않을까?
        - 범근) 오 이런 얘기는 첨 들어본다 ㄷㄷ 잘 짠건지, 못 짠건진 모르겠지만 그 사람의 스타일이 리뷰할때 튄다는 것 같네
- 보배) 질문 - lint와 formatter의 차이가 무엇인지 아시나요?
    - 예원) 그러게요?
    - lint : 코드의 (잠재적)오류/버그 찾아주기
    - formatter: 코드의 서식 맞춰주기
    
    ```kotlin
    Lint:
    Lint는 코드에서 잠재적인 오류나 버그를 찾아내는 도구입니다.
    주로 코드 스타일, 문법 오류, 잠재적인 버그 등을 검사합니다.
    예를 들어, 사용하지 않는 변수, 잘못된 변수 범위, 누락된 세미콜론 등을 감지할 수 있습니다.
    Lint는 코드의 품질을 높이고 버그를 줄이는 데 도움을 줍니다.
    예시: JavaScript에서는 ESLint, Python에서는 Pylint 등이 널리 사용됩니다.
    
    Formatter:
    Formatter는 코드의 서식을 일관되게 만들어주는 도구입니다.
    코드의 들여쓰기, 줄 바꿈, 공백 등을 자동으로 조정하여 일관된 형식으로 만들어줍니다.
    주로 팀원들 간에 일관된 코드 스타일을 유지하고 코드 리뷰를 쉽게 만들어줍니다.
    예시: Python의 경우, Black, YAPF 등이 널리 사용되며, JavaScript의 경우 Prettier가 많이 사용됩니다.
    ```
    

# 3장. 재사용성

## Item 19. knowledge 를 반복하여 사용하지 말라

- 그렇다
- 여러분들은 진행하시는 프로젝트에서 반복이 있는 경우가 있나요? 있다면 왜? , 리팩토링 혹은 반복 제거 계획?
- 115p) 얼핏보면 knowledge 반복처럼 보이지만, **실질적으로 다른 Knowledge 를 나타내는 경우 추출해선 안된다.**
- 115p) **“함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?”**
    - 정민 - 저도 이것과 책임을 기준으로 리팩토링합니다! 여러분들은 어떠하신가요?
    - 예원 숙제 → 느낀 점만 느끼지 않기
- 115p) 두 액터가 같은 클래스를 변경하는 일은 없어야 한다
    - 보배) SRP, modulith 공부할 때 배우던 것. **“우발적 중복”**
    - 그리고 이 중에서 유스케이스는 공통 모듈에 담지 않기로 결정했다. 유스케이스를 공통 코드로 뺐더니, 사이드 이펙트가 발생하기 쉬울 뿐만 아니라 예외 케이스를 위한 분기 처리도 들어가게 되면서 많은 문제가 발생하였다. 이는 서로 다른 액터를 위한 로직들이 혼용되기 때문이며, 결국 SRP를 위반하기 때문이다. 따라서 공통 모듈에는 유스케이스가 아닌 **도메인 엔티티와 관련된 코드만을 추가**하기로 하였다.
    - 이렇게 하면 비슷해 보이는 코드들이 여럿 생기는데, 코드가 비슷하다고 해서 모두 중복은 아니다. **예를 들어 비슷한 코드라고 하더라도 서로 다른 액터를 처리하고 있다면 이것은 “진짜 중복”이 아니므로 이를 “우발적 중복”이라고 부른다. 따라서 중복이 발생했다면 이것이 “진짜 중복”인지 고민해볼 필요가 있다.**
    - [https://mangkyu.tistory.com/304](https://mangkyu.tistory.com/304)
- 117p) 확장함수를 통해 하나의 클래스를 두고 모듈별로 기능 중복되지 않게 구현
    - 보배) 근데 확장함수를 쓰면 그 위치가 특정이 안되서 더 헷갈리지 않나? 코드가 너무 분산된달까?
        - 현업에서 어떻게 쓰는지 궁금. 확장함수도 모아두나?
        - 범근) 일단 나는 확장함수를 사용하는 곳에 선언하는 정도라 코드가 분산되어 있을 순 있지만! **사실상 사용하는 곳에 의존적인 로직을 선언하는터라 오히려 관리의 책임이 있는 클래스에 있다고 해야하나.** 물론 common성이나 util성은 한 클래스에 다 모아두는 것 같긴함!
            - http 모듈에서 get이나 post 확장함수 선언해두고 안에서 중복으로 들어가는 보일러 플레이트성 (`.accept(MediaType.APPLICATION_JSON`과 같은 것들)을 매번 호출되게끔 하는듯
        - 예원) 사용하는 곳에서만 정의하기도하고 (보통은 mapping 코드가 대부분이라..)
            - 완전히 공통 모듈 내에만 정의하는 케이스가 많아서. 오히려 이득 이런걸 만들어놨따고? ㅋ개꿀
        - 정민) 22.. 사용하는 곳에서만 정의 + private

## Item 20. 일반적인 알고리즘을 반복해서 구현하지 말라

- 119p) `coerceIn`
    - 정민) 잘 쓸게요 첨 알았음.
    - 범근) 이거 뭐라읽어요?
    - 예원) 오늘 쓴 함수 : coerceAtMost
- 121p) 자바빈 패턴
    - 예원) 실제로 이 자바빈 패턴을 많이 쓰나요? 자바님들
        - 121 예시 코드 뭔가 이상하다 싶었는데 내부적으로 setter를 사용하고 있나봄다.
        - 정민) ㅇㅇ. 열려 있는 듯
        - 보배) 버리세요 그냥
- 122p) 확장 함수의 장점 (행위 나타내기 좋다. 구체적 타입을 제한해서 좋다. 가독성 좋다)
    - 굿
    - 정민) 실제로 가독성이 좋은 이유는 어떠한 이유에서 일까요? 주체(타입)이 이어져있어서 그런가? 
      `주체.동사()`  순이라?
        - 보배) 난 그런듯. 더욱이 책에도 나오지만 함수를 찾기 좋음. 주체에서 `.` 만 찍어도 사용가능한 행위들이 주루룩 노출되니…
            - 자바는 확장 함수가 없으니 기존 Java 컬렉션 기능을 확장할 때 특정 유틸성 메서드로 하고 컬렉션 인스턴스들을 넣는게 보기 좋지는 않음. 이럴 빠엔 오히려 composition해서 가리는게 나은 듯.
        - 범근) 저도 그런 것 같습니다. 메서드(파라미터) 보다 **파라미터.행위 가 뭔가 더 정이 간달까**
        - 예원) 사용할 때 좀 더 간지남. **`“yaewon”.isLink()` / `StringUtil.isLink(”yaewon”)`**
- 123p) `stdlib`를 공부해두면 좋습니다.
    - 심심하면 보러가세요. .. 자주 쓰는 순위라도 잇으면 재밋게 구경할텐데 모르겠ㄷ.ㅏ
    
    [kotlin-stdlib - Kotlin Programming Language](https://kotlinlang.org/api/latest/jvm/stdlib/)
    
    - 보배) 잘 보고 갑니다 ^^* 근데 이거 다봐도 다 까먹을 듯. 대충 GPT보고 구현해야할 것 있는데…. 이런거 stdlib에 없을까?…. 이런 정도로 활용하는 것도?
        - 시도해봤는데 정확도가 좋지 않다. 프롬프트 엔지니어링을 잘하는 것이 중요할 듯;
    - 그냥 지피티에게 물어보자

---

예원) 이펙티브 코틀린.. 편안해.. 좋아…

- 보배) 아주 … 좋아….