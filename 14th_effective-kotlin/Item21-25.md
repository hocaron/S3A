# Item [21 ~ 25]

일자: 2024년 5월 15일
MC: 예원 오
참석자: 예원 오, 박범근, 한정민, 김보배



## Item21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라 # 교육적인

- 124p) 지연 프로퍼티가 있습니다.
    - 정민) 저는 사실 코틀린으로 파이프라인 컴포넌트들을 만들면서 lazy init 을 쓴 적이 없기도해서 좋은 예시 좀 보여주시면 감사하겠심더
    - 범근) 저도 프로퍼티 지연은 사용해본적이 없네용;;
        - 특정 프로퍼티들에 중복된 로직을 적용할 때 커스텀 위임 프로퍼티를 만들어서 적용하면 코드의 중복도 줄이고, 캡슐화도 된다고 하네요~?
    - 보배) 저도 궁금. lazy하게 구성해야하는 경우가 있을까? 적합한 경우가 무엇일까?
    
    ```kotlin
    data class Example(
     private val loader: Loader
    ) {
      // 안쓰이는 상황이 있지만, init 하기엔 무거울 수 있을 때 사용할 수 있다고 생각함..
      val lazyValue by lazy { loader.load() } 
    }
    ```
    
- 126p) 정민: get /set 은 연산자로 취급하는 군요. `operator fun`
    - get / set 연산자 오버로딩 시 `thisRef: Any?` 와 `prop: KProperty<*>` 는 반드시 있어야 하나보네요
    - 보배) getValue, setValue를 연산자로 취급하는 듯?
- 126p) 프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자를 만드는 방식입니다.
    - 예원: 오우,, 예시보니 신기한데 실제로 한 번도 안써봐서 어색함.
    - 보배) 이전까지 읽을 땐 조금 어색했는데, 위 문장으로 생각하니 조금 쉬워졌음.
    - 경험 있으신 분 ? : 없다.
- 126p) 범근: 프로퍼티 위임의 개념이 정확하게 안서서 찾아봤는데, 위임한 프로퍼티의 getValue와 setValue를 사용하는 것을 뜻하네요. (프로퍼티의 접근자 호출을 위임한다는 것?)
- 128p) 컨텍스트의 종류에 따라 적절한 메시드가 선택된다는 예시 코드
    - 예원: 어떤 부분을 의미하는건지 모르겠음. 이 SwipeRefreshBinderDelegate 가 선택된 메소드 예시인건가.
    - 보배) 나도 여기서 컨텍스트의 의미가 조금 헷갈림.
    - 범근) getValue 가 두 개 정의되어있는데, 여기서 activity 를 쓰냐, fragment를 쓰냐의 차이인 듯?
- 129p) 프로퍼티 델리게이트로 처리시, 프로퍼티를 더 다양하게 조작할 수 있어서 좋고 재사용에도 좋다고 한다. 그 예시로 일반적인 패턴 추출 / 더 좋은 API 만들 수 있음
    - 정민) 더 와닿는 필요한 용례를 모르겠음. 기냥 그렇구나..하는정도
    - 범근) 저도. 안드로이드 예제가 많이 나오네요? 그래서 공감이 잘 안되나
    - 예원) 저도 안드로이드 진영쪽에서 유용하게 사용하나 ? 생각
    - 보배) 도메인 객체의 프로퍼티에 대해 뭔가 변경되는 액션에 따라 전파/추가변경 해야하는게 있으면 유용하게 사용할 수 있다는건가…? 나도 그 의미가 조금 헷갈림.
- 129p) 코틀린 개발자라면 프로퍼티 위임이라는 강력한 도구와 관련된 내용을 잘 알고 있어야합니다.
    - 예송합니다.

## Item22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라.

- 131p) 제네릭은 컴파일 과정에서 최종적으로 이러한 타입 정보는 사라지지만, 개발 중 특정 타입을 강제할 수 있음.
    - 보배) 더 자세히 설명해보시오. (면접 문제)
        - [https://inpa.tistory.com/entry/JAVA-☕-제네릭-타입-소거-컴파일-과정-알아보기](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85-%EC%86%8C%EA%B1%B0-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)
        - 다음에 퀴즈하겠습니다.
- 많은 코틀린 개발자가 variance 한정자를 어떤 형태로 사용하는 지 잘 몰랐다.
    - 정민) 하하 어렵다 공변/무공변/반공변
    - 범근) ㄹㅇ 볼때마다 헷갈림
- 132p) 아래 코드 `where`
    - 정민) 첨보고 신기했음.
    - 예원) 신기 22
    - 보) 신3 아직도 이해 안감
        - [https://kotlinlang.org/docs/generics.html](https://kotlinlang.org/docs/generics.html)
        - [https://readystory.tistory.com/201](https://readystory.tistory.com/201)
    - 범) 신4
- 기냥 퀴즈 : `List<Any>` 와 `List<*>` 의 차이를 아시나요
    - 범근) Any와 와일드카드의 차이점?
    - 보배) 이거 Java List<Object>, List<?> 차이와 같지 않나
        - `Effective java, item 26< ? 로 타입은 사용하지 말라>`
    - 스크래치 파일 만들기 : 커맨트 + 쉬프트 + N
- 정답
  
    *는 어떤 타입이 들어올지 미리 알 수 없어도 그 타입을 안전하게 사용하고 싶을 때 사용한다. 
    
    언제든지 모든 타입을 받을 수 있는 Any와 달리 한번 구체적인 타입이 정해지고 나면 해당 타입만 받을 수 있다.
    
    둘 다 모두 받을 수 있지만, *는 한 번 정해지고 나면 해당 타입만 받을 수 있음.
    
    Any는 서브타입 여러개 받을 수 있음.
    
- 지피티
  
    `List<Any>`는 어떤 타입의 요소도 추가하거나 변경할 수 있는 리스트를 의미하고, `List<*>`는 요소의 타입이 알려지지 않거나 중요하지 않은 읽기 전용 리스트를 의미
    

⇒ “ * “ 이거쓰자. 

## Item23. 타입 파라미터의 섀도잉을 피하라

섀도잉 : 프로퍼티와 파라미터가 같은 이름을 가질 수 있는데, 지역 파라미터가 외부 스코프에 있는 프로퍼티를 가리기는 것.

```kotlin
class Forest(val name: String) {
	fun addTree(name: String) { } 
}

// 독립적 파라미터 의도시, 요래 이름을 달리해라. 
class Forest<T: Tree> {
	fun <ST: T> addTree(name: ST) {}
} 
```

정민) 갑자기 궁금한 거 kotlin 작성하시면서 fun 내부 fun 작성해서 많이들 쓰시나요? 

- 범근) fun 내부 fun?! 저는 안써본거같은데…  써본적이 없어서 개념이 안잡히는데 그러면 그 fun 안에서만 사용할 수 있는 fun이 생기는건가?! data class 안에 해당 객체에서만 사용하는 data class는 선언해봤는데
- 예원) fun 내부 fun 나는 사용 안해봤지만, 어떤 분이 쓰신건 봤음. 그 안에서만 사용된다는 의미에서 쓰신걸까?
    - 근데 읽기가 좀 어려운것 같아서, 나는 앞으로도 쓰지 않을듯 하다
- 정민) 썼던 경험 있을 유. 굳이 밖에서 사용되지 않음. 파이썬은 꽤 자주 그렇게 쓰는디
    - 접근은??? 다른 곳에서도 접근 가능해?????
    - 그 함수 내부 스콥에서만 접근 가능
    - 보배) 함수 안에서 반복되는 패턴이 있다면 함수를 변수로 만들어서 적용하기도함 (람다식).

보배) 타입 파라미터를 2개 다 사용해서 독립적으로 동작한다는게 신기했음. 내가 이렇게 짤까 싶기도 하지만, 타인이 짠걸 본다면 이상함을 눈치 못챌 것 같음.

- 예원) 22222

## Item24. 제네릭 타입과 variance 한정자를 활용하라

- 보배) 맨날 공부해야하지 했다가 넘겼던 것… 너무 헷갈림
    - 참고하면 좋을 것 같음
    - [https://grey920.github.io/server/java-covariant/](https://grey920.github.io/server/java-covariant/)
- p136) 이 책에서 읽기 가장 어려운 부분이 될 수 있겠지만, 너무 어렵게 느껴져도 포기하지 말기 바랍니다! ^^
    - 범근) 아직도 제네릭 코드에 대해 친숙하지 않습니다… 라이브러리 볼때 코드 읽기도 어려워..
- class Cup<T> 불공변
- class Cup<out T> 공변
    - A가 B의 서브 타입일 때, Cup<A>가 Cup<B>의 서브타입
- class Cup<in T> 반공변
    - A가 B의 서브 타입일 때, Cup<A>가 Cup<B>의 슈퍼타입
- 예원: out(공변)은 자기 + 하위 타입만을 받아들이고, in(무공변)은 자기 + 상위 타입만을 받아들인다 고 만 이해중..
- 예원)  타입 제한을 명시하면 프로그래머의 의도치 않은 실수를 컴파일 타임에 막을 수 있다.
- 138p)정민 - 타이핑 시스템 계층이 뭐야. 그냥 타입 계층 인가
- 139p) 예원 - 계층구조?는 이해못하겠음 ㅎ
    - 138, 139 화살표 그림 이해한사람???
        - 이렇게 가능하다라는 뜻 아닐지..
        - 모르겠다..
- 139p) **코틀린 함수 타입의 모든 파라미터 타입은 contravariant(in) / 모든 리턴 타입은 covariant(out)**
- 140p) Dog / Puppy 예시
    - 이는 convariant 하지 않습니다 ⇒ 이게 왜 covariant가 아닌지 궁금함. 서브타입이 들어간거아닌가..?
        - covariant 라고 써있습니다! 근데 왜 covariant 하지 않다는 거지 서브 타입 들어가잖아 out 이 선언 안되어서야?
    - covariant 타입 파라미터(out 한정자)가 in 한정자 위치(예를 들어 타입 파라미터)에 있다면, covariant 와 업캐스팅을 연결해서 우리가 원하는 타입을 아무것이나 전달할 수 있습니다.
        - 정민) 아니 in 이랑 out 위치 하는 곳은 동일한 곳 아냐? in 한정자가 코드에서 어디있는가
- 140p ~ 141p ) 이해못함..ㅋ
- 144p) convariance 예제 요소가 public일땐 에러나고, private일땐 에러 안남.
    - 예원: public일땐 어떤 타입이 상위 타입인지 모르니까 에러나는거고, Private은 내부에서만 쓰니까 타입 핸들링(예상)이 가능하단거겠지?
    - 
      
        ```kotlin
        // 에러 (public)
        class Box<in T> {
            var value: T? = null // 외부에서 소비 가능 => 에러남
        }
        
        // 에러 X (private)
        class Box<in T> {
            private var value: T? = null // 외부에서 소비 불가능 => 에러 안남
        }
        ```
        
        코틀린에서 `in` 키워드는 타입 파라미터가 소비 위치에서만 사용되도록 제한합니다. 이를 공변성(covariance)이라고 합니다. **이는 클래스 내부에서 타입 파라미터가 메서드의 매개변수로 사용되지 않고, 메서드의 반환 타입으로만 사용되도록 합니다.**
        
        `private` 필드의 경우 클래스 외부에서 접근할 수 없으므로, 이 필드를 통해 타입 파라미터가 소비 위치에서 사용되는 것을 막을 수 있습니다. 따라서 필드의 경우 클래스 외부에서 접근할 수 없으므로, 이 필드를 통해 타입 파라미터가 소비 위치에서 사용되는 것을 막을 수 있습니다. 따라서 `private`필드에는 `in` 키워드를 사용할 수 있습니다. 반면 `public` 필드의 경우 클래스 외부에서 접근할 수 있으므로, 이 필드를 통해 타입 파라미터가 소비 위치에서 사용될 수 있습니다. 따라서 `public`필드에는 `in`키워드를 사용할 수 없습니다. 이것이 `public`필드에 `in` 키워드를 사용하면 에러가 발생하는 이유입니다.
    
- 보배) 왜 특출나게 in, out을 사용해야하는가?
- 지피티 답변
  
    ```kotlin
    inline fun <T> Array<out T>.firstOrDefault(default: T, predicate: (T) -> Boolean): T { return this.firstOrNull(predicate) ?: default }
    ```
    
    > 지피티야 이 함수는 왜 out T 로 공변으로서 타입을 활용해야했을까?
    > 
    
    이 함수에서 `out T`를 사용하는 이유는 공변성(covariance)을 허용하기 위해서입니다.
    
    **Dog : Animal 일때,**
    
    공변성은 하위 타입의 배열을 상위 타입의 배열로 처리할 수 있게 해줍니다. 예를 들어, `Array<Animal>` 타입의 변수에 `Array<Dog>` 타입의 값을 할당할 수 있게 해줍니다.
    
    이 함수에서 `Array<out T>`를 사용하면, 예를 들어 `Array<Dog>` 타입의 배열을 이 함수에 전달하고 결과를 `Animal` 타입으로 받을 수 있습니다. 이렇게 하면 더 유연한 프로그래밍이 가능해집니다.
    
    (무공변)
    
    만약 `Array<T>`를 사용했다면, 이 함수는 정확히 T 타입의 배열만 받을 수 있습니다. 즉, `Array<Dog>`를 전달하려면 결과도 `Dog` 타입으로 받아야 합니다. 이는 일부 상황에서는 제한적일 수 있습니다.
    
    따라서, 이 함수에서는 `Array<out T>`를 사용하여 공변성을 허용하고, **더 많은 타입의 배열을 이 함수에 전달할 수 있게(결과로 받을 수도 있고)** 하였습니다.
    
    익스텐션의 일종으로 사용하면 유용할지도
    
- 예원) in, out한정자를 제네릭과 같이 사용하는 것
    - 공변, 반공변과 같은 개념은 언어 전반적인 부분에서 활용이 되는 것.

## Item25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

- 148p) 범근) Ktor 많이 쓰나요??
    - 예원: 첨들어봅니다.
    - 정민 : 정원이형이 얘기 몇번해준 거만 들어봄
    - 보배) 카카오에서 사용한다고 기술 영상을 봤던 것 같음
        - 카카오페이네요 ^^* [https://tech.kakaopay.com/post/spring-and-ktor/](https://tech.kakaopay.com/post/spring-and-ktor/)
    - 페이에서 쓰나요? 범근짱
        - 기술블로그에서 어렴풋이만 알게됨.
- 149p) 코틀린이 자바스크립트로 컴파일될 수 있다는 것입니다.
    - 정민 ) 와우
    - 범근) 마법인데?
    - 보배) 그렇지만, 이걸 누가 사용할 것인가… (아직까진 멀었다고 생각)
    - 예원) 코틀린 멀티플랫폼~ 쓰면된다.
- 보배) 최근에 Wasm도 지원하는걸 알게되서 살짝 살펴봤던 기억이 있음.
    - [https://kotlinlang.org/docs/wasm-overview.html#browser-api-support](https://kotlinlang.org/docs/wasm-overview.html#browser-api-support)
    - 근데 이렇게 여러가지 지원하는게 계속 뜨겁게 지원될까? 하는 생각이 든다. 사용자가 없다면 관심도 줄어들텐데 말이야….
    



범근) 안드로이드에선 위임프로퍼티 많이 쓴다. 커스텀 위임을 쓰진 않고, 많이 쓰는건 잘 만들어져있음..아하