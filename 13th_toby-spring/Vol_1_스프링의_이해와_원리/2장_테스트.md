## 2.1 UserDaoTest 다시보기
### 2.1.1 테스트의 유용성
- 내가 예상하고 의도했던 대로 코드가 정확히 동작하는가
- 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 확인
- 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치는 작업

### 2.1.2 UserDaoTest의 특징
아래는 main() 메소드를 이용해서 작성한 테스트 코드이다.

```java
public class UserDaoTest (
	public static void main(String[] args) throws SQLException (
		ApplicationContext context =new GenericXmlApplicationContext("applicationContext.xml");
		
		UserDao dao =context.getBean("userDao", UserDao.class);
		User user =new User(); 
		user.setld("user"); 
		user.setName("백기선"); 
		user.setPassword("married");
		
		dao .add(user);
		
		System.out.println(user.getId() + " 등록 성공“);
		User user2 =dao.get(user.getld()); 
		System.out.println(user2.getName()); 
		System.out.println(user2.getPassword());
		System.out.println(user2.getld() + " 조회 성공");
	}
}
```

- 자바에서 가장 손쉽게 실행 가능한 `main()` 메소드를 이용한다.
- 테스트 할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.

#### 작은 단위의 테스트
테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 관심사의 분리라는 원리가 여기에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.

#### 자동 수행 테스트 코드
테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다는 건 매우 중요하다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해볼 수있다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트

테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있다.

### 2.1.3 UserDaoTest의 문제점
#### 수동 확인 작업의 번거로움
테스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트 되는 방법이라고 말할 수가 없다.

#### 실행 작업의 번거로움
만약 DAO가 수백 개가 되고 그에 대한 `main()` 메소드도 그만큼 만들어진다면. 전체 기능을 테스트해보기 위해 `main()` 메소드를 수백 번 실행하는 수고가 필요하다.

## 2.2 UserDaoTest 개선

### 2.2.1 ~ 2.2.2 테스트 검증의 자동화 ~ 테스트의 효율적인 수행과 결과 관리
#### Junit 테스트로 전환
새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두가지를 따라야 한다. 첫째는 메소드가 public으로 선언돼야 하는 것이고, 다른 하나는 메소드에 `@Test`라는 애노태이션을 붙여주는 것이다.

아래 코드는 Junit 프레임워크에서 동작하도록 코드를 재구성 한 것이다.
```java
class UserDaoTest {
    
    @Test
    void addAndGet() throws Exception {
        ApplicationContext context =new GenericXmlApplicationContext("applicationContext.xml");		
		UserDao dao =context.getBean("userDao", UserDao.class);
        
        ...
    
    }
}
```


> 🙋‍♀️ JUnit의 진화 과정과 public 접근 제어자
JDK 1.1에서는 리플렉션에서 public 메소드만 접근을 허용했다. JDK 1.5에 애노테이션이 들어오게 되면서 JUnit에도 큰 변화가 하나 생겼는데, 바로 @Test 어노테이션을 활용하는 것이다. JUnit4도 마찬가지로 독립적인 테스트를 보장하기 위해 각각의 테스트 클래스 객체를 생성하는데, 테스트 메소드를 선별하는 과정에서 `@Test`가 붙은 메소드 만을 테스트로 인식하면 되었다. 그래서 테스트 메소드가 test로 시작할 필요가 없어져 이러한 부분이 개선되었다. JUnit5 부터는 public으로 만드는 전통을 풀어버렸다. 그래서 private 외의 접근제어자는 모두 사용할 수 있고, 일반적으로 default 접근자를 통해 손쉽게 타이핑할 수 있게 되었다.
하지만 여전히 테스트 클래스와 메소드는 반드시 public 이여야 한다. JDK1.2부터는 리플렉션 API을 통해 모든 접근레벨을 다 허용하기 시작했다. 그럼에도 불구하고 JUni4까지는 테스트 클래스와 메소드에 public을 붙여주어야 하는데, JUnit 개발자들이 밝히기를 기존의 전통을 유지하기 위함이였다고 한다.

#### 검증 코드 & Junit 테스트 실행
Junit4에는 `assertThat`이라는 스태틱 메소드를 제공하는데, 이 메소드를 이용하면 값을 검증할 수 있다. `assertThat()`을 이용해 검증을 했을 때 기대한 결과가 아니면 AssertionError를 던진다. 따라서 `assertThat()`의 조건을 만족하지 못하면 테스트는 더 이상 진행되지 않고 Junit4는 테스트가 실패했음을 알게 된다.

> 🙋‍♀️ Junit4 와 Junit5 차이
Junit5에서 assertAll 메서드가 없어지면서 assertAll, assertThrows 새로운 메서드가 생겼다.

#### AssertJ
```java
assertEquals(expected, actual); // Junit 
assertThat(actual).isEqualTo(expected); // AssertJ
```
`assertThat(result).isTrue()`를 읽으면 result변수 값이 true라고 주장한다가 된다.
junit에서 `assertEquals(expected, actual)`로 작성해야하며 앞에 있는 변수가 예상 값이고 뒤가 실제 값임을 알아야 한다.
반면 `assertThat(actual).isEqualTo(expected)`로 작성해서 읽는다면 영어 그대로 actual이 expected와 같다고 주장한다가 되므로 조금 더 명확하게 읽을 수 있다는 점이 있다.

## 2.3 개발자를 위한 테스팅 프레임워크 Junit
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.

### 2.3.2 테스트 결과의 일관성
지금까지 테스트를 실행하면서 가장 불편했던 일은, 매번 UserDaoTest 테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 할 때였다.

#### 동일한 결과를 보장하는 테스트
단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안된다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

### 2.3.3 포괄적인 테스트

#### 테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.

JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘 못 만든 것이다. 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야한다.

#### 포괄적인 테스트
테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다. `get()` 메소드의 경우라면, 존재하는 id가 주어졌을 때 해당 레코드를 정확히 가져오는가를 테스트하는 것도 중요하지만, 존재하지 않는 id가 주어졌을 때는 어떻게 반응할 지를 먼저 결정하고, 이를 확인할 수 있는 테스트를 먼저 만들려고 한다면 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다.

### 2.3.4 테스트가 이끄는 개발
#### 기능 설계를 위한 테스트
테스트에는 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있다. 이렇게 비교해보면 테스트 코드는 마치 잘 작성된 하나의 기능 정의서처럼 보인다.

- 조건 : 어떤 조건을 가지고
- 행위 : 무엇을 할 때
- 결과 : 어떤 결과가 나온다.

#### 테스트 주도 개발
만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다. 이를 테스트 주도 개발(TDD. Test Driven Development)이라고 한다. 또는 테스트를 코드보다 먼저 작성한다고 해서 테스트 우선 개발(Test First Development)이라고도 한다.

TDD는 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다. 또한 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다.

### 2.3.5 테스트 코드 개선

#### @Before (JUnit 4), @BeforeEach (JUnit 5)
클래스 내에 존재하는 각각의 @Test 를 실행하기 전에 매번 실행돼야 하는 메소드를 정의한다.

#### @BeforeClass (JUnit 4), @BeforeAll (JUnit 5)
모든 테스트를 실행하기 전 딱 한번만 실행돼야 하는 메소드를 정의한다. static 으로 선언해야 한다.

#### 테스트 실행 흐름
JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.
![](https://velog.velcdn.com/images/haron/post/026f817c-55b6-458d-b24f-d47f300f0c4a/image.png)

1. 테스트 클래스에서 @Test가 void형인 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. `@Before`가 붙은 메소드가 있으면 실행한다.
4. `@Test`가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. `@After`가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
   모든 테스트의 결과를 종합해서 돌려준다.

`@Before`, `@After`가 붙은 메소드에 넣어두면 JUnit이 자동으로 메소드를 실행해주니 매우 편리하다. 각 테스트 메소드에서 직접 `setUp( )`과 같은 메소드를 호출할 필요도 없다.

한 가지 꼭 기억해야 할 사항은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다. 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 테스트 클래스가 @Test 테스트 메소드를 두 개 갖고 있다면, 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만들 것이다.

JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다. 덕분에 인스턴스 변수도 부담 없이 사용할 수 있다. 어차피 다음 테스트 메소드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화 될 것이다.

#### 픽스처
테스트를 수행히는 데 펼요한 정보나 오브젝트를 픽스처(fixture)라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 `@Before` 메소드를 이용해 생성해두면 편리하다. UserDaoTest에서라면 dao가 대표적인 픽스처다. 테스트 중에 `add()` 메소드에 전달히는 User 오브젝트들도 픽스처라고 볼 수 었다.

> 🙋‍♀️ 픽스처 몽키
Fixture Monkey는 테스트 객체를 편하게 자동으로 생성해주는 자바 라이브러리 입니다.
https://naver.github.io/fixture-monkey/kr/

## 2.4 스프링 테스트 적용

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 히는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

#### 스프링 테스트 컨텍스트 프레임워크
`@RunWith`, `@ExtendWith`는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용히는 애노테이션이다. SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.

`@ContextConfiguration`은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.

#### 테스트 메소드의 컨텍스트 공유
스프링의 JUnit 확장 기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다. 일종의 DI라고 볼 수 있는데, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 조금 성격이 다르다.

하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있다.

#### 테스트 클래스의 컨텍스트 공유
두 개의 테스트 클래스가 같은 설정 파일을 사용하는 경우에는 테스트 수행 중에 단 한 개의 애플리케이션 컨텍스트만 만들어진다. 두 테스트 클래스의 모든 메소드가 하나의 애플리케이션 컨텍스트 공유할 수 있다.

수백 개의 테스트 클래스를 만들었는데 모두 같은 설정 파일을 사용한다고 하면 테스트 전체에 걸쳐 단 한 개의 애플리케이션 컨텍스트만 만들어져 사용된다. 이 덕분에 테스트 성능이 대폭 향상됨은 더 설명할 필요도 없을 것이다.
![](https://velog.velcdn.com/images/haron/post/d75063bf-fb5c-4155-bd3b-79806246387a/image.png)


#### @Autowired
`@Autowired`는 스프링의 DI에 사용되는 특별한 애노테이션이다.

`@Autowired`가 붙은 인스턴스 변수가 있으면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.

스프링 애플리케이션 컨텍스트는 초기화 할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능하다.

`@Autowired`는 타입으로 가져올 빈 하나를 선택 할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.

테스트는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관없다. 개발자가 만드는 테스트는 코드 내부구조와 설정 등을 알고 있고 의도적으로 그 내용을 검증해야 할 필요가 있기 때문이다. 하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이좋다.

#### 2.4.2 DI와 테스트
구현 클래스가 절대 바뀌지 않는다면, 굳이 인터페이스를 이용해서 DI를 받지 않아도 될까? 그렇지 않다. 구현 클래스가 절대로 바뀌지 않을거 같더라도, 가능하면 인터페이스를 이용해서 DI를 받는게 좋다. 그래야 하는 이유는 아래와 같다.

첫째 : 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
둘째 : 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
셋째 : 테스트 때문이다. 단지 효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용해야 한다. 테스트를 잘 활용하려면 자동으로 실행 가능하며 빠르게 동작 하도록 테스트 코드를 만들어야 한다. 그러기 위해서는 가능한 한 작은 단위의 대상에 국한해서 테스트해야 한다. 테스트 할 대상의 범위가 넓어지면 테스트를 작성하기가 어려워진다.DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 한다.

> 인터페이스를 이용해서 DI를 받을 때, 장점
https://www.youtube.com/watch?v=bJfbPWEMj_c

#### 테스트를 위한 별도의 DI 설정
테스트 코드에서 빈 오브젝트에 수동으로 DI 하는 방법은 장점보다 단점이 많다. 코드가 많아져 번거롭기도 하고 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이 있다.

아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법을 이용해도 된다. 즉 두 가지 종류의 설정파일을 만들어서 하나에는 서버에서 운영용으로 사용할 DataSource를 빈으로 등록해두고, 다른 하나에는 테스트에 적합하게 준비된 DB를 사용히는 가벼운 DataSource가 빈으로 등록되게 만드는 것이다. 그리고 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해주면 된다.

#### 컨테이너 없는 DI 테스트
DI를 테스트에 이용하는 방법은 아예 스프링 컨테이너를 사용하지 않고 테스트를 만드는 것이다. 구현 클래스 어디에도 스프링의 API를 직접 사용한다거나 애플리케이션 컨텍스트를 이용하는 코드가 존재하지 않는다면 굳이 스프링을 이용해서 테스트를 진행할 필요가 없다.

즉, 테스트하려는 클래스가 스프링 컨테이너에 의존하지 않는다면 스프링 컨테이너를 이용해서 IoC 방식으로 생성되고 DI 되도록 하는 대신, 테스트 코드에서 직접 오브젝트를 만들고 DI 해서 사용해도 된다.

> 🙋‍♀️ 모듈별 테스트 병렬 실행 : ./gradlew test -parallel
모듈 내 클래스 / 메서드 병렬 실행 : junit.jupiter.execution.parallel.enabled=true...
https://yeon-kr.tistory.com/212

#### DI를 이용한 테스트 방법 선택
그렇다면 DI를 테스트에 이용하는 세 가지 방법 중 어떤 것을 선택해야 할까? 세 가지 방법 모두 장단점이 있고 상황에 따라 유용하게 쓸 수 있다.

항상 스프링 컨테이너 없이 테스트 할 수 있는 방법을 가장 우선적으로 고려하자. 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다. 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.

여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우가 있다. 이 때는 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다. 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정 파일을 따로 만들어 사용하는 편이 좋다. 보통 개발 환경과 테스트 환경, 운영 환경이 차이가 있기 때문에 각각 다른 설정 파일을 만들어 사용히는 경우가 일반적이다.

테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 었다. 이 때는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다. 테스트 메소드나 클래스에 `@DirtiesContext` 애노테이션을 붙이는 것을 잊지 말자.

## 2.5 학습 테스트로 배우는 스프링

### 2.5.1 학습 테스트의 장점
#### 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다
학습 테스트는 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인할 수 있다.

#### 학습 테스트 코드를 개발 중에 참고 할 수 있다
학습 테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고 남겨둘 수 있다. 이렇게 테스트로 새로운 기술의 다양한 기능을 사용하는 코드를 만들어두면 실제 개발에서 샘플 코드로 참고할 수 있다. 아직 익숙하지 않은 기술을 사용해야 하는 개발자에게는 이렇게 미리 만들어진 다양한 기능에 대한 테스트 코드가 좋은 참고 자료가 된다.

#### 프레임워크나 제품을 업그레이드 할 때 호환성 검증을 도와준다
학습 테스트에 애플리케이션에서 자주 사용히는 기능에 대한 테스트를 만들어 놓았다면 새로운 버전의 프레임워크나 제품을 학습 테스트에만 먼저 적용해본다. 기존에 사용했던 API나 기능에 변화가 있거나 업데이트된 제품에 버그가 있다면, 학습 테스트를 통해 미리 확인할 수가 있다. 버그가 있어서 테스트가 실패하면 업그레이드 일정을 늦추거나. API의 사용 방법에 변화가 발생한 경우라면 그에 맞춰서 애플리케이션 코드를 수정할 계획을 세울 수 있을 것이다.

#### 테스트 작성의 좋은 훈련이 된다
학습 테스트를 테스트 작성의 훈련 기회로 삼는 것도 좋다. 또는 새로운 테스트 방법을 연구하는데도 도움이 된다. 기술에 따라서 테스트가 까다로운 것도 있는데 이럴 때 먼저 학습 테스트를 만들어보면서 간결한 테스트 작성 방법을 연구해보면 도움이 된다.

#### 새로운 기술을 공부하는 과정이 즐거워진다
스프링 학습 테스트를 만들 때 참고할 수 있는 가장 좋은 소스는 바로 스프링 자신에 대한 테스트 코드다. 스프링은 꼼꼼하게 테스트를 만들어가며 개발해 온 프레임워크다. 거의 모든 기능에 대해 방대한 양의 테스트가 만들어져 있다. 스프링 배포판의 압축을 풀어보면 프레임워크 소스코드와 함께 테스트 코드도 발견할 수 있을 것이다. 스프링 테스트를 잘 살펴보면 레퍼런스 문서에서는 미처 설명되지 않았던 중요한 정보도 많이 얻을 수 있다. 또, 테스트 작성 방법에 대한 좋은 팁을 얻을 수 있을 것이다.

### 2.5.3 버그 테스트
버그 테스트(bug test)란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.

#### 테스트의 완성도를 높여준다
기존 테스트에서는 미처 검증하지 못했던 부분이 있기 때문에 오류가 발생한 것이다. 이에 대해 테스트를 만들면 불충분했던 테스트를 보완해준다.

#### 버그의 내용을 명확하게 분석하게 해준다
버그가 있을 때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유 때문에 문제가 생겼는지 명확히 알아야 한다. 따라서 버그를 좀 더 효과적으로 분석할 수 있다. 그 과정에서 그 버그로 인해 발생할 수 있는 다른 오류를 함께 발견할 수도 있다. 예를 들어 예외적인 상황이나 입력 값 때문에 발생히는 오류였다면, 테스트 코드를 만들면서 오류를 발생시키는 값의 범위가 어떤 것인지 분석해볼 기회가 주어진다. 테스트의 중요한 기법 중의 하나인 동등분할이나 경계값 분석을 적용해볼 수도 있다.

#### 기술적인 문제를 해결하는 데 도움이 된다
때로는 버그가 있다는 건 알겠지만 그 원인이 무엇인지 정확하게 파악하기 힘들 때가 있다. 아무리 코드와 설정 등을 살펴봐도 별다른 문제가 없는 것 같이 느껴지거나 또는 기술적으로 다루기 힘든 버그를 발견하는 경우도 었다. 이럴 때는 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.

- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- `main()` 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정 파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.

### 유익한 잡담
#### 슬라이스 테스트 적용해봐도 좋을 것 같아요
```java
@SpringBootApplication
@EnableJpaAuditing
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}
```
- `@WebMvcTest` 슬라이스 테스트 도중 JPA metamodel must not be empty!
- Spring 컨테이너를 요구하는 테스트는 가장 기본이되는 --Application 클래스가 항상 로드되는데, `@EnableJpaAuditing`이 해당 클래스에 등록되어 있어 모든 테스트들이 항상 JPA 관련 Bean들을 필요
- `@EnableJpaAuditing` 이 붙은 bootstrapping 클래스가 스프링 부트에 의해 로딩되는데 `@WebMvcTest`같은 테스트 전용 애너테이션은 JPA 관련 빈들을 로딩하지 않음

1. 별도의 configuration 클래스를 생성해서 @EnableJpaAuditing
2. @MockBean(JpaMetamodelMappingContext.class)

TO-BE
```java
@Import({QuerydslConfig.class, JpaAuditingConfig.class})
@DataJpaTest
@ActiveProfiles("test")
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ServiceTest {
}
```

```java
@Import({SecurityConfig.class, ApiResponseAdvisor.class, DefaultApiResponseTranslator.class})
@AutoConfigureRestDocs
@ActiveProfiles("test")
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ControllerTest {
}
```

#### service, serviceImpl 구현하시나요?
- 고전적인 MVC 패턴에서는 변경될 일이 없기 때문에 구현하지 않는 편
- 헥사고날 아키텍쳐에서는 의존성을 낮추기 위해 구현
- 아키텍쳐마다 다를 수 있다

#### References
- https://mangkyu.tistory.com/280
