# [DDD] 박재민 5 ~ 6장

# 05. 간단한 비즈니스 로직 구현

## 트랜잭션 스크립트

트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스를 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현한다.

> “프레젠테이션으로부터 단일 요청을 처리하는 여러 프로시저를 모아서 비즈니스 로직을 구현하라” - 마틴 파울러
> 

### 구현

- 간단하고 쉬운 절차지향 스크립트로 구현
- 구현해야 하는 유일한 요구사항은 트랜잭션 동작
- 각 작업은 성공하거나 실패할 수 있지만 유효하지 않은 상태를 만들면 안 됨
- 트랜잭션 스크립트 실행이 실패하더라도 시스템은 오류가 발생할 때까지 변경사항을 롤백 혹은 보상 조치를 실행하여 일관성 유지
- 겉보기에는 단순한데 가장 틀리기 쉬운 패턴

### 트랜잭션 동작 구현 실패

- users 테이블의 레코드를 업데이트하고 visitsLog 테이블에 레코드를 삽입하는 경우가 있다
- users 테이블의 레코드는 업데이트가 됐지만 visitsLog테이블에 레코드 삽입하는 것이 실패한다면, 시스템이 일관되지 않는 상태가 된다
- 이 문제는 네트워크 중단, 디비 시간 초과 혹은 교착 상태, 프로세스를 실행하는 서버의 충돌로도 발생할 수 있다
- 두 데이터 변경을 모두 포함하는 트랜잭션을 만들어서 해결할 수 있다
- 다중 레코드 트랜잭션을 지원하지 않는 디비에서 다중 업데이트를 하거나 분산 트랜잭션에서 통합할 수 없는 여러 개의 저장 장치로 작업하는 경우에는 상황이 더 복잡해진다

### 분산 트랜잭션

- 최신 분산 시스템에서는 디비의 데이터를 변경한 다음 메시지 버스에서 메시지를 발행하여 시스템의 다른 컴포넌트에 변경사항을 알리는 것이 일반적 다만, 이 방식에서도 시스템의 일관적인 상태를 유지하는 것은 어려운 일이다

### 암시적 분산 트랜잭션

```csharp
public void Execute(Guid userId) {
	_db.Execute("UPDATE users SET visits=visits+1 WHERE user_id=1")
}
```

- 위 메서드는 하나의 디비에 있는 하나의 테이블에서 하나의 값을 업데이트 하는 것이다. 그러나, 이것은 여전히 잠재적으로 일관성 없는 상태로 이어질 수 있는 분산 트랜잭션이다.
- 쿼리를 호출한 외부 프로세스와 디비에 정보를 전달하기 때문에 분산 트랜잭션을 구성한다
- 쿼리는 성공했지만 호출자에게 결과를 전달하는 데 실패하면 어떻게 될까?
    
    → 호출자는 실패를 가정하고 다시 호출하게 된다. 그러면 카운터 값이 잘못 증가한다
    
- 트랜잭션 동작을 보장하는 한 가지 방법은 작업을 멱등성으로 만드는 것이다
    - 사용자에게 업데이트할 카운터 값을 전달하도록 요청할 수 있다
- 문제를 해결하는 또 다른 방법은 낙관성 동시성 제어를 사용하는 것이다
    - 사용자에게 전달 받은 값과 현재 값이 동일할 경우에만 카운터 값을 업데이트 한다

### 트랜잭션 스크립트를 사용하는 경우

- 단순한 장점을 갖고 있어 간단한 문제 도메인에 효과적 (복잡한 도메인에는 X)
- 정의상 비즈니스 로직이 단순한 지원 하위 도메인에 적합하며 일반 하위 도메인같이 3rd party와 연동하기 위한 어답터 내지는 ACL의 일부로 사용가능
- 최소한의 추상화를 도입하여 런타임 성능을 최적화하고, 비즈니스 로직을 이해하기 위한 시간을 최소화한다.
- 결과적으로 핵심 하위 도메인에는 트랜잭션 스크립트를 사용하면 안된다.

---

## 액티브 레코드

- 비즈니스 로직이 단순한 경우 사용한다
- 더 복잡한 자료구조에서도 비즈니스 로직이 작동할 수 있다

### 구현

- 액티브 레코드라고 하는 전용 객체를 사용하여 복잡한 자료구조를 표현한다
- 액티브 레코드 객체는 객체 관계 매핑(ORM) 또는 다른 데이터 접근 프레임워크와도 관련이 있다
- 자료구조 외에도 이러한 객체는 CRUD 작업도 구현한다
- 트랜잭션 스크립트로 시스템의 비즈니스 로직을 만든다
- 디비에 직접 접근하는 대신 트랜잭션 스크립트가 액티브 레코드 객체를 조작한다는 것이다.
- 액티브 레코드 패턴의 목적은 메모리 상의 객체를 디비 스키마에 매핑하는 복잡성을 숨기는 것이다.
- 액티브 레코드 객체의 고유한 기능은 자료구조와 동작(비즈니스 로직)의 분리다.
- 일반적으로 액티브 레코드의 필드에는 외부 프로시저가 상태를 수정할 수 있게 하는 퍼블릭 게터, 세터가 있다.

### 액티브 레코드를 사용하는 경우

- 액티브 레코드는 본질적으로 디비에 대한 접근을 최적화하는 트랜잭션 스크립트이기 때문에 이 패턴은 기껏해야 사용자 입력의 유효성을 검사하는 CRUD 작업과 같은 비교적 간단한 비즈니스 로직만 지원할 수 있다.
- 지원 하위 도메인, 일반 하위 도메인과 외부 솔루션의 연동, 모델 변환 작업에 적합하다
- 빈약한 도메인 모델 안티패턴이라고도 하며, 다시 말하면 부적절하게 설계된 도메인 모델이다
- 잘못된 컨텍스트에 적용하면 잠재적으로 득보다 실이 많을 수 있다
- 이러한 맥락에서 액티브 레코드는 프레임워크가 아니라 디자인 패턴을 의미한다는 점이 중요하다

---

## 실용적인 접근 방식

- 비즈니스 데이터가 중요하고 설계 및 개발되는 코드의 무결성도 보호해야 하지만 실용적인 접근 방식이 더 바람직한 몇 가지 경우가 있다
- 대규모로 데이터를 다루는 시스템에서는 데이터의 일관성 보장이 덜 염격할 수 있다
- 보편적인 것은 없다. 작업 중인 비즈니스 도메인에 달려 있다.

---

# 6장. 복잡한 비즈니스 로직 다루기

## 배경

에릭 에반스가 소개한 패턴 **전술적 도메인 주도 설계**에 대해 다루지만 이러한 패턴을 필수로 사용해야 한다는 오류를 피하기 위해 마틴 파울러의 원래 용어를 사용한다. 이 패턴이 ‘도메인 모델’이고 그 구성요소로 애그리게이트, 밸류 오브젝트가 있다.

---

## 도메인 모델

도메인 모델 패턴은 CRUD 인터페이스 같이 단순한 로직 보다 복잡한 비즈니스 로직을 다루기 위한 것이다. 비즈니스 로직의 요구사항을 구현하다 보면 다양한 규칙 간에 그물 같은 의존성을 형성하게 되는데, 잘못 구현되면 시스템의 상태를 손상시키기 쉽다.

### 구현

도메인 모델은 행동과 데이터 모두를 포함하는 도메인의 객체 모델이다. DDD의 전술 패턴인 **애그리게이트, 밸류 오브젝트, 도메인 이벤트, 도메인 서비스**는 모두 객체모델의 구성요소이다.

### 복잡성

도메인 비즈니스 로직은 이미 본질적으로 복잡해 모델링에 사용되는 객체가 복잡성을 추가하면 안된다. 모델에는 DB나 외부 시스템의 관심사를 피해 어떠한 프레임워크나 인프라 구성요소에 의지 하지 않는 플레인 올드 오브젝트여야 한다.

### 유비쿼터스 언어

도메인 모델의 객체가 기술이 아닌 비즈니스 로직에 집중하게 하면 유비쿼터스 언어의 용어를 따르기 쉬워진다.

### 구성요소

1. 밸류 오브젝트
    - 복합적인 값에 의해 식별되는 객체
    - 복합적인 값 중 하나가 변경되면 완전히 새로 다른 인스턴스가 된다
    - 코드의 표현력을 높여주고 분산되기 쉬운 비즈니스 로직을 한 데 묶어줄 수 있어 코드를 더욱 안전하게 유지할 수 있다
    - 밸류 오브젝트는 불변이기 때문에 부작용 및 동시성 문제가 없다.
2. 엔티티 
    - 밸류 오브젝트와 정반대의 개념
    - 객체를 식별하기 위해 식별 필드가 필요하다 (Ex, Person의 Id)
    - 불변이 아니고 변할 것으로 예상된다.
    - 엔티티의 속성을 밸류 오브젝트로 설명하는 관계
3. 애그리게이트
    - **엔티티** 이지만 단순한 엔티티가 아닌 그 이상의 개념
    - 패턴의 목적은 데이터의 일관성을 보호하는 데 있는데 애그리게이트의 데이터는 변할 수 있기에 이를 해결하기 위한 과제가 있음을 내포함
    - 일관성을 강화하는 경계다
        - 모든 들어오는 변경 요청을 검사해서 그 변경이 애그리게이트의 비즈니스 규칙에 위배되지 않게 해야 한다
        - 비즈니스 로직을 통해서만 애그리게이트의 상태를 변경해야 일관성이 강화된다
        - 퍼블릭 인터페이스를 노출해 상태 변경을 하는데 이 때 변경하는 메서드를 **커맨드** 라고 한다
        - 커맨드의 구현 방식
            - 애그리게이트 객체에 평범한 퍼블릭 메서드로 구현
            - 커맨드의 실행에 필요한 모든 입력값을 포함하는 파라미터 객체로 표현
    - 애그리게이트의 퍼블릭 인터페이스는 입력값의 유효성을 검사하고 모든 비즈니스 규칙과 불변성을 강화하는 것을 담당한다. 또한 이와 같은 경계는 애그리게이트와 관련된 모든 비즈니스 로직이 해당 애그리게이트에 제한되게 구현된다.
    - 모든 애그리게이트의 상태 변경은 원자적인 단일 오퍼레이션으로 트랜잭션 처리돼야 한다
    - 애그리게이트의 상태 변경은 DB 트랜잭션 하나당 한 개의 애그리게이트로, 개별적으로 커밋될 수 있다
    - 엔티티와 밸류 오브젝트는 애그리게이트의 구성 요소이며, 애그리게이트는 비즈니스 로직에 따라 동일한 트랜잭션 경계에 속한 객체들을 한데 묶을 수 있다
    - 애그리게이트가 너무 커지면 성능과 확장에 문제가 생길 수 있으므로 강력한 일관성이 필요한 객체만 하나의 애그리게이트의 포함해야 한다. 애그리게이트는 가능한 한 작게 유지하는게 좋다.
    - 애그리게이트의 상태는 커맨드를 통해서만 수행되며 여러 객체를 포함하기에 이 중 대표되는 엔티티를 퍼블릭 인터페이스, 즉 **애그리게이트 루트**로 지정해야 한다.
    - 도메인 이벤트
        - 외부에서 애그리게이트와 커뮤니케이션 할 수 있는 메커니즘
        - 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지
        - 애그리게이트의 퍼블릭 인터페이스의 일부임.
        - 애그리게이트는 자신의 도메인 이벤트를 발행하며 외부에서 이 도메인 이벤트를 구독할 수 있고 그에 해당하는 자신만의 로직을 실행할 수 있다.
    - 애그리게이트 또한 유비쿼터스 언어를 사용해 비 개발자 또는 도메인 전문가와 소통할 때도 동일한 언어를 기반으로 의사소통해야 한다.
4. 도메인 서비스
    - 복수의 애그리게이트에 관련된 비즈니스 로직을 다루게 될 경우 도메인 서비스로 로직을 구현
    - 비즈니스 로직을 구현한 **상태가 없는 객체**다
    - 여러 애그리게이트의 작업을 쉽게 조율해주는 장점이 있다.
    - 다만, 한 개의 DB 트랜잭션에서 한 개의 애그리게이트 인스턴스만 수정할 수 있다는 애그리게이트 패턴의 한계를 명심해야 함.
    - 도메인 서비스는 위의 한계를 극복해주는 것이 아닌 여러 애그리게이트의 데이터를 **읽는 것**이 필요한 계산 로직을 구현하는 데 도움을 줄 뿐이다.

---

## 복잡성 관리

시스템의 복잡성을 논의할 때 제어와 동작 예측의 어려움을 평가하는데 관심이 있고 이 두 가지 관점이 시스템의 자유도를 반영한다.

복잡한 것을 불변성으로 감싸서 복잡성을 낮추는 패턴이며 이 역할은 애그리게이트와 밸류 오브젝트 패턴이 한다. 애그리게이트 및 밸류 오브젝트는 자신이 담당하는 비즈니스 영역이 있고 해당 영역에서 비즈니스 불변성으로 감싸고 보호해서 결국 자유도(자유도는 시스템의 상태를 설명하는 데 필요한 데이터 요소의 개수)를 줄인다.