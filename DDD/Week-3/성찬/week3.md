# Part 2. 전술적 설계
* BC의 비즈니스 로직을 구현하는 패턴 소개 (유비쿼터스 언어 사용법)
* BC 아키텍처 구현 패턴 소개

## 05. 간단한 비즈니스 로직 구현

### 트랜잭션 스크립트
* 시스템 퍼블릭 인터페이스는 비즈니스 트랜잭션의 모음
* 프로시저를 기반으로 비즈니스 로직구성
* 프로시저는 퍼블릭 인터페이스의 구현체
* 프로시저 구현체는 반드시 원자성 보장해야함
> note.  
프로시저란?  
퍼블릭 오퍼레이션은 뭐지?

#### 분산 트랜잭션
* DB 저장 후 메세지를 큐잉하는 작업이 순차적으로 정의 되어 있다면?
  * DB 저장 성공 / 큐잉 실패 하게 된다면?
    * outbox pattern
  * 여러 저장장치(DB / Queue)에 걸친 분산 트랜잭션의 원자성 보장은 어렵다.
    * CQRS 아키텍처 패턴
* 해결
  * 멱등성 있는 작업으로 만든다.
    * 이건 항상 습관으로 가져가면 좋은 것 같다.
  * 낙관적 락 걸기

##### 트랜잭션 스크립트
* 절차지향 스크립트로 구현
* DB를 직접 핸들링
* 언제 사용?
  * 단순한 일반 하위 도메인 작업
  * 쉽게 복잡해지고 유지보수하기 어려워짐

##### 액티브 레코드
* JPA 처럼 동작
  * 트랜잭션이 끝나면 오브젝트를 분석해서 쿼리 수행 후 성공/실패에 따라 커밋
* 언제사용?
  * 비즈니스 로직이 단순할 때 (CRUD / Validate) 
    * 트랜잭션 스크립트 보다는 쪼금 더 복잡한 자료구조에 사용 가능
    * 계층을 가진 오브젝트 트리에도 가능
    * 중복 코드 제거 가능

위험과 비즈니스 중요도에 따라서 패턴을 잘 선택하자

## 06. 복잡한 비즈니스 로직 다루기
### 도메인 모델
* 복잡한 상태 전환, 항상 보호해야 하는 규칙, 비즈니스 규칙, 불변성을 다룬다.
* 구현
  * 행동과 데이터를 모두 포함하는 객체이다.
  * Aggregate, Value Object, Domain Object, Domain Service가 객체 모델의 구성요소이다.
  * 비즈니스 로직을 최우선으로 둔다.
* 복잡성
  * 모델링에 사용되는 객체(?)가 모델에 조금이라도 우발성 복잡성을 추가하면 안된다.
  * 모델에서는 외부 구성요소(DB...) 호출 을 피해야한다.
  * 모델은 결국 POJO가 되는 것이 바람직하다.

#### VO
```java
// AS-IS
class Person {
    private String id;
    private String firstName;
    private String lastName;
    
    public boolean validateId() {
        return this.id == 0; // .....
    }
    
    public String getName() {
        return firstName + " " + lastName;
    }
}

// TO-BE
class Person {
    private PersonId id;
    private Name name;
    
    private static class PersonId {
        private String id;
        
        public PersonId(String s) {
            validate(s);
            // else throw...
        }
    }
    
    private static class Name {
        private String firstName;
        private String lastName;
        
        public String getName() {
            return firstName + " " + lastName;
        }
    }
}
```
* AS-IS
  * 유효성 검사 로직 중복
  * 유효성 검사 로직 호출 시점 모호
  * 유지보수 어려움
* TO-BE
  * 변수명 간략화
  * 생성 시점에 유효성 검사
  * 비즈니스 로직 응집도 향상
  * 테스트하기 좋음
  * 코드에서 도메인 개념 표현하기 좋음 << OOP 와 다른점

* 주의점
  * equals() 정책을 잘 정의해야함 (객체 비교 시 발생하는 문제) 
* 언제 쓸까?
  * 항상 써라

#### Entity
* 가변적이다.
* 식별 필드가 필요하다.
* ag의 일부로서 사용된다.

#### Aggregate
* 가변적이다.
* Entity 와 비슷하지만 그 이상의 개념
* 데이터의 일관성을 보장하는 것이 목적
  * ag 주변 경계를 명확하게 설정하여 일관성 강화
  * 모든 변경 요청을 검사해서 비즈니스 규칙에 위배하는지 체크
  * ag 비즈니스 로직에 의해서만 상태 변경 가능
  * ag 외부의 모든 프로세스와 객체는 ag의 값을 수정하려면 ag 퍼블릭 인터페이스 메서드를 통해야 한다. (읽기는 가능)
  * 퍼블릭 인터페이스에 노출된 ag의 상태 변경 메서드는 커맨드 라고 부른다.
    * 퍼블릭 메서드를 정의하거나 다형성을 가진 파라미터를 통해 단일 메서드에서 해결한다 (?)
* 1트랜잭션당 1ag
  * 말이 되는건가??
    * ag == entity 인 줄 알았는데 그게 아니라서 가능한듯
* ag를 가능한 작게 유지하자.
  * 작게 유지하는 기준: 강력하게 일관적으로 상태를 유지할 필요 있는 객체들만 포함
* aggregate root
  * 애플리케이션 계층에 노출된다.
  * 루트가 수정되면 하위 계층의 엔티티들이 수정된다.


#### 도메인 이벤트
* 퍼블릭 인터페이스 외에 외부에서 ag와 소통할 수 있는 매커니즘
* 비즈니스 도메인에서 발생한 중요한 이벤트
  * 발생한 이니까 항상 과거형

#### 도메인 서비스
* 비즈니스 로직을 구현한 상태가 없는 객체
* 다양한 시스템 구성요소의 호출을 조율