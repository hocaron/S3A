# [DDD] 박재민 13~14장

# 13장. 실무에서의 도메인 주도 설계

코드베이스가 항상 훌륭한 상태로 유지되고 유비쿼터스 언어를 사용해 모델의 복잡성을 수용하는 디자인 패턴을 구현하는 코드베이스 프로젝트 ‘그린필드 프로젝트’에 참여하는 일은 꿈과 같다. 많은 개발자들은 대부분의 경력을 브라운필드, 레거시, 커다란 진흙 덩어리 코드베이스에서 보낸다. 브라운필드와 이상적이지 않은 환경에서 실제로 도메인 주도 설계 도구와 패턴을 적용하기 위한 전략에 대해 배워보자.

## 전략적 분석

DDD를 도입하는 가장 좋은 출발점은 조직의 비즈니스 전략과 시스템 아키텍처의 현 상황을 이해하는 데 시간을 투자하는 것이다

### 비즈니스 도메인 이해하기

- 조직의 비즈니스 도메인은 무엇인가?
- 고객은 누구인가?
- 조직이 고객에게 제공하는 서비스 또는 가치는 무엇인가?
- 경쟁 회사 또는 그들의 제품은 무엇인가?

위의 질문들을 통해 회사의 전반적인 목표에 대한 조감도를 얻을 수 있다.

다음으로 도메인을 확대해서 조직이 상위 목표인 하위 도메인을 달성하기 위해 사용하는 비즈니스 구성요소를 찾는다

- 가장 먼저 활용할 만한 휴리스틱은 회사의 조직도, 즉 부서와 기타 조직 단위다. 조직 단위들이 어떻게 협력하는지 조사하라
- 특정한 유형의 하위 도메인의 신호를 찾아라
    - 핵심 하위 도메인
        - 회사의 핵심 하위 도메인을 식별하려면 경쟁업체와의 차별점을 찾자
            - 경쟁업체에 없는 회사의 ‘비법 소스’는 무엇인가?
            - 경쟁 우위인 핵심 하위 도메인이 반드시 기술적인 것은 아니라는 점을 명심하라. 회사가 비기술적 경쟁 우위를 가지고 있는가?
        - 최악으로 설계된 소프트웨어 컴포넌트인 커다란 진흙 덩어리를 찾아라
            - 레거시 시스템을 상용 시스템으로 대체할 수 없으며, 이를 수정하면 비즈니스 위험이 수반된다
    - 일반 하위 도메인
        - 상용 솔루션이나 구독 서비스, 또는 연동할 수 있는 오픈소스 소프트웨어를 찾아라
    - 지원 하위 도메인
        - 상용 솔루션으로 대체할 수 없지만 직접 경쟁 우위를 제공하지 않는 나머지 소프트웨어 컴포넌트를 찾아라.
- 모든 핵심 하위 도메인을 식별할 필요는 없다. 전체 구조를 식별하되, 개발 중인 소프트웨어 시스템과 가장 관련 있는 하위 도메인에 더 주의를 기울여라

### 현재 설계 탐색

- 문제 도메인에 한 번 익숙해지면 그것의 솔루션 및 설계와 관련된 결정을 계속 살펴볼 수 있다
    - 먼저 상위 수준 컴포넌트부터 시작하라. BC일 필요는 없으며 비즈니스 도메인을 하위 시스템으로 분해하는 데 사용하는 경계를 의믜한다
    - 수명주기를 분리할 수 있는지 찾아라
    - 전술적 설계 평가
        - 각 상위 수준 컴포넌트에 대해 어느 비즈니스 하위 도메인을 포함하고 어떤 기술적 설계 의사결정을 내렸는지 확인하라
        - 비즈니스 로직을 구현하고 컴포넌트의 아키텍처를 정의하는 데 어느 패턴을 사용했는가?
        - 해당 솔루션이 문제가 갖고 있는 복잡성을 해결하기에 적합한가?
        - 더 정교한 설계 패턴이 필요한 영역이 있는가?
        - 비용을 절약할 수 있는 방법이나 기존 상용 솔루션을 사용할 수 있는 하위 도메인이 있는가?
    - 전략적 설계 평가
        - 현재 설계의 컨텍스트 맵을 차트로 표시하라
        - BC 연동 패턴 관점에서 컴포넌트 간의 관계를 식별하고 추적하라
        - 컨텍스트 맵을 분석하고 도메인 주도 설계 관점에서 아키텍처를 평가하라
            - 동일한 상위 수준의 컴포넌트에 대해 작업하는 여러 팀
            - 핵심 하위 도메인의 중복 구현
            - 하청 회사가 핵심 하위 도메인을 구현
            - 자주 실패하는 연동으로 인한 마찰
            - 외부 서비스와 레거시 시스템에서 확산되는 어색한 모델
        - 문제와 솔루션 영역 모두에 대한 더욱 심층적인 지식이 주어지면 손실된 도메인 지식을 복구할 수 있다. 이 때 이벤트스토밍이 도움이 될 수 있다.

---

## 현대화 전략

- 시스템을 처음부터 다시 작성하는 ‘대대적인 재작성’ 노력은 거의 성공하지 못한다
- 크게 생각하되 작게 시작하자
    - 시스템의 하위 도메인을 나누는 경계를 찾고 각 하위 도메인을 제대로 된 BC로 나눈다. 논리적 경계가 하위 도메인의 경계와 일치하는지 확인하는 것부터 시작하라
- 시스템의 모듈 조정은 안전한 형태의 리팩터링이다.
- 데이터베이스의 저장 프로시저, 서버리스 함수 등 다른 코드베이스에서 구현된 하위 도메인의 비즈니스 로직을 관리하는데 이런 플랫폼에서도 새 경계를 도입해야 한다

### 전략적 현대화

- 시스템을 초기부터 가능한 한 작은 BC로 분해하는것은 위험할 수 있다
- 논리적 경계를 물리적 경계로 바꿔 BC를 추출하는 과정
    - 여러 팀이 동일한 코드베이스에서 작업하고 있는가? 그렇다면 각 팀에 대한 BC를 정의해 개발 수명주기를 분리하라
    - 서로 다른 컴포넌트에서 충돌하는 모델을 사용하고 있는가? 그렇다면 충돌하는 모델을 별도의 BC로 재배치하라
- 필요한 최소 BC가 있으면 이들 간의 관계와 연동 패턴을 조사하라
- 서로 다른 BC에서 작업하는 팀이 어떻게 의사소통하고 협업하는지 확인하라
- 컨텍스트 통합 패턴이 해결할 수 있는 문제에 주목하라
    - 사용자-제공자 관계
        - 조직의 성장은 이전의 커뮤니케이션과 협업 패턴을 무효화할 수 있다. 파트너십이 더 이상 유지되지 않는 컴포넌트를 찾아 적절한 유형의 사용자-제공자 관계로 리팩터링하라
    - 충돌 방지 계층
        - 사용하는 업스트림 서비스의 퍼블릭 인터페이스에 대한 잦은 변경으로부터 BC를 보호하기 위해 사용하라
    - 오픈 호스트 서비스
        - 한 컴포넌트의 구현 상세의 잦은 변경으로 사용자에게 영향을 미치는 경우 OHS로 만드는것을 고려하라
    - 분리형 노선
        - 공동 개발하는 엔지니어링 팀간의 마찰이 발생한 경우 분리형 노선 패턴을 적용해 자체 솔루션을 구현하라

### 전술적 현대화

- 전술적 관점에서 비즈니스 가치와 구현 전략에서 가장 고통스러운 부조화를 찾아내야 한다
- 비즈니스의 성공에 직접적인 영향을 미치는 시스템 컴포넌트는 자주 변경되는데 좋지 않은 설계 때문에 유지보수와 개선이 어렵다.

### 유비쿼터스 언어 육성

- 성공적인 현대화 설계의 전제조건은 비즈니스 도메인 지식과 비즈니스 도메인의 효과적인 모델을 만드는 것이다
- 도메인 지식 수집을 위해 이벤트스토밍해라. 이는 도메인 지식을 복구하기 위한 환상적인 도구다
- 도메인 지식과 해당 모델을 갖췄다면 논의 중인 비즈니스 기능에 가장 적합한 비즈니스 로직 구현 패턴을 결정하라
- 시스템의 전체 컴포넌트를 점진적으로 교체하거나 기존 솔루션을 점진적으로 리팩터링하라!

**스트랭글러 패턴**

- 숙주 나무의 위쪽 가지에서 씨앗으로 삶을 시작해 커가면서 숙주를 죽게하는 스트랭글러 무화가에서 이름을 따옴
- 새로운 BC를 만들어 레거시 BC로부터 마이그레이션 이후 레거시 BC를 삭제하는 패턴
- 일반적으로 Facade pattern을 사용해 마이그레이션 중에는 파사드를 사용해 적절히 라우팅해주고 마이그레이션 이후에는 파사드를 삭제한다
- DB 또한 초기 마이그레이션에서는 두 BC에서 접근을 허용하지만 마이그레이션 이후에는 레거시 BC에서의 접근을 없앤다.

**전술적 설계 의사결정 리팩터링**

- 레거시 코드베이스르 현대화 할 때는 두 가지 미묘한 차이점이 있다
    - 작은 점진적인 조치가 대규모 재작성보다 안전하다
    - 작은 점진적인 조치를 수행하는 것과 동일한 이유로 도메인 모델로의 리팩터링이 한 번에 이루어질 필요는 없다
- 가능한 밸류 오브젝트를 찾는 것부터 시작하라. 불변 객체를 사용함으로써 솔루션의 복잡성을 크게 줄일 수 있다
- 관련 비즈니스 로직을 수집하는 것부터 시작해 트랜잭션 경계를 분석하라. 그 후 애그리게이트의 경계를 설계하라
- 레거시 시스템을 리팩터링하는 것처럼 필요시 ACL나 OHS를 사용해 사용자를 보호해라

## 실용적인 도메인 주도 설계

- 도메인 주도 설계를 적용하는 것은 ‘모 아니면 도’가 아니며 DDD가 제공하는 도구를 모두 적용할 필요 없다!
- 애그리게이트나 밸류 오브젝트는 도구일 뿐 필수사항이 아님. DDD는 결국 비즈니스 도메인이 소프트웨어 설계 의사결정을 주도하게 하는것이다!

---

## 도메인 주도 설계 확산

- 엔지니어가 팀이나 경영진을 설득할 수 있을까?
    
    → 매우 어렵다!
    

### 실무에 활용하는 도메인 주도 설계

- DDD를 조직 전략이 아닌 실무에 활용하는 전문 도구 상자의 일부로 만들어라

### 유비쿼터스 언어

- 이해관계자가 비즈니스 도메인에 대해 말할 떄 사용하는 언어에 주의 깊게 귀를 기울여라. 전문 용어에서 벗어나 비즈니스 의미를 반영하는 용어를 사용하자
- 일치하지 않는 용어를 찾고 설명을 요청하라
- 도메인 전문가와 많이 소통해 그들의 언어를 사용하라
- 인내심을 가져라

### 바운디드 컨텍스트

- 가능한 분해 방법을 탐색할 때 BC 패턴의 기반이 되는 원칙을 확인하라
    - 모든 유슼케이스에 대해 단일 모델 대신 문제 지향 모델을 설계하는 것이 더 나은 이유는? 올인원 솔루션이 거의 효과가 없기 때문
    - BC가 충돌하는 모델을 관리할 수 없는 이유는? 인지 부하가 증가하고 솔루션이 복잡해짐
    - 여러 팀이 동일한 코드베이스에서 작업하는 게 왜 나쁠까? 팀 간의 마찰이 발생하고 협업에 방해됨

### 전술적 설계 의사결정

- 전술적 설계 패턴에 대해 논의할 떄 권위자에게 호소하지 말고 논리에 호소하라!
    - 명시적 트랜잭션 경계가 중요한 이유는? 데이터의 일관성 보호를 위해
    - 데이터베이스 트랜잭션이 애그리게이트 둘 이상의 인스턴스를 수정할 수 없는 이유는? 일관성 경계과 올바른지 확인하기 위해
    - 외부 컴포넌트에서 애그리게이트 상태를 직접 수정불가한 이유는? 모든 관련 비즈니스 로직을 함께 배치하고 중복되지 않게 하기 위해
    - 애그리게이트 기능 중 일부를 저장 프로시저로 넘길 수 없는 이유는? 로직이 중복되지 않게 하기 위해. 중복된 로직은 특히 논리적, 물리적으로 멀리 떨어진 시스템과 동기화되지 않고 데이터 손상을 초래
    - 왜 우리는 작은 애그리게이트 경계를 위해 노력해야 하는가? 넓은 트랜잭션 범위는 애그리게이트의 복잡성을 증가시키고 성능에 부정적인 영향을 준다
    - 이벤트 소싱 대신 이벤트를 로그 파일에 기록할 수 없는 이유는? 장기적으로 데이터 일관성이 보장되지 않는다

### 이벤트 소싱 도메인 모델

- 이벤트 소싱은 많은 사람에게 너무 급진적으로 들린다
    - 도메인 전문가와 이야기를 많이 나눠 상태 기반 모델과, 이벤트 기반 모델을 보여주고 시간 차원에 관해 이벤트 소싱이 제공하는 차이점과 이점을 설명하라
- 도메인 전문가와 상호작용하는 동안 유비쿼터스 언어를 사용하라!

---

# 14장. 마이크로 서비스

많은 사람은 BC와 마이크로 서비스를 혼용한다. 이번 장에서 도메인 주도 설계 방법론과 마이크로서비스 아키텍처 패턴의 관계를 탐구한다. 마이크로서비스 기반 시스템을 효과적으로 설계하는 데 DDD를 활용하는 방법을 배워보자

## 서비스란 무엇인가?

- 미리 정의된 인터페이스를 사용해 하나 이상의 역량에 접근하기 위한 메커니즘
    - 미리 정의된 인터페이스란 서비스로부터 데이터를 넣고 빼는 모든 메커니즘
    - 요청/응답 모델의 동기식, 이벤트 방식의 비동기식이 있음

## 마이크로서비스란 무엇인가?

- 자신의 마이크로 퍼블릭 인터페이스, 즉 마이크로 프런트 도어에 의해 정의되는 서비스
- 마이크로 퍼블릭 인터페이스가 있으면 단일 서비스의 기능과 그 서비스가 연동하는 다른 시스템 구성요소를 쉽게 이해할 수 있다. 또한 서비스의 기능을 줄이면 변경될 이유가 줄어들고 개발, 관리, 확장에 자율적이다
- 자신의 데이터 베이스를 노출하지 않을 수 있다

### 서비스형 메서드: 완벽한 마이크로서비스?

- 서비스 인터페이스를 단일 메서드로 제한한다면 완벽한 마이크로서비스가 될 수 있을까? → 그렇지 않다!
- 너무 잘게 쪼개진 마이크로 서비스는 전체적인 서비스에 대한 복잡성, 글로벌 복잡성을 증가시킨다.

### 설계 목표

- 각 서비스가 단일 메서드만 갖도록 분해하는것은 불가능하다. 서비스는 서로 협력해야 하므로 연동에 관련된 퍼블릭 메서드를 가진 퍼블릭 인터페이스를 만들어야 한다
- 단일 메서드 서비스를 만들 때 각 서비스는 훨씬 간단해졌지만 전체 시스템은 더 복잡해졌다. 이는 다음과 같은 시스템의 정의에 부합하지 않는다
    - 함께 작동하는 연동된 것 또는 디바이스
    - 특정 목적을 위해 함께 사용되는 컴퓨터 장비 및 프로그램
- 시스템은 독집적인 컴포넌트로 구축될 수 없다

### 시스템의 복잡성

- 로컬 복잡성
    - 각각의 개별 마이크로서비스의 복잡성
- 글로벌 복잡성
    - 전체 시스템의 복잡성
- 글로벌 복잡성을 줄이는 것은 쉽다. 각 서비스의 상호작용을 없애면 된다
- 적절한 MSA 기반 시스템 설계를 위해 글로벌 복잡성, 로컬 복잡성 모두 최적화 해야 한다

### 깊은 서비스로서의 마이크로서비스

- 모듈은 자신의 함수와 로직에 의해 정의된다
- 함수는 모듈이 해야 하는 일, 로직은 모듈의 비즈니스 로직, 즉 구현하는 방법이다
- 모듈화의 개념에 대해 논의하고 설계를 평가하기 위해 ‘깊이’를 파악해야 한다
- 모듈을 사각형으로 시각화해 사각형의 상단 끝은 모듈의 기능, 면적은 기능의 구현을 나타낸다
- 효과적인 모듈은 깊이가 깊고 기능은 적다.
- 극단적으로 얕은 모듈의 예가 단일 메서드 서비스이며, 이 같은 모듈은 수많은 유동적인 부분을 만들어내 전체 시스템에 우발적 복잡성을 발생시킨다. (유동적인 부분이란??)

### 깊은 모듈로서의 마이크로서비스

- 마이크로 서비스 패턴과 깊은 모듈의 개념은 다르다. 마이크로 서비스는 엄밀히 물리적인 경계를 나타내지만 모듈은 논리적 경계과 물리적 경계 모두 나타낼 수 있기 때문. 두 개념과 하부의 설계 원칙은 동일하다
- 시스템의 복ㅈ바성 관점에서 보면 깊은 모듈은 시스템의 글로벌 복잡성을 줄여주는 반면, 얇은 모듈은 로컬 복잡성을 감싸지 않는 구성요소를 도입해야 해 글로블 복잡성을 증가시킨다(??)
- 시스템을 MSA로 분해할 댸 임계치는 MSA를 시스템의 일부로 사용하려고 하는 유즈케이스에 의해 정의된다. 얇은 서비스는 통합하는 과정에서 비용이 커지기에 넓게 분산된 MSA 아키텍처는 커다란 진흙 덩어리로 변한다.

---

## 도메인 주도 설계와 마이크로서비스의 경계

DDD의 대부분 내용은 경계에 관한것이다. 어떤 경계가 MSA의 개념에 도움을 줄까?

### 바운디드 컨텍스트

- 마이크로서비스가 사실상 바운디드 컨텍스트다. But, 반대는 불가
- 다양한 요구사항은 바운디드 컨텍스트를 여러 형태로 분해하게 한다
    - 팀의 크기, 구조, 수명주기 의존성 등이 그런 요구사항이다
- MSA와 BC의 관계는 비대칭이다. BC는 유효한 거대한 모놀리식의 경계다. 모놀리식은 비즈니스 도메인 모델의 일관성을 보호하는 유효한 설계 옵션이다

### 애그리게이트

- 애그리게이트 패턴은 BC와는 반대로 가능한 한 좁게 경계를 설정한다
- 애그리게이트는 내부 비즈니스 규칙과 불변성, 로직의 복잡성을 감싸는 개별적인 비즈니스 기능 단위지만 MSA는 그렇지 않다. 개별 서비스는 시스템의 다른 구성요소와 상호작용하는 컨텍스트에서 고려돼야 한다.
- 문제의 애그리게이트가 자신의 하위 도메인에 있는 다른 애그리게이트와 통신하는가?
    - 다른 애그리게이트에 자신의 밸류 오브젝트를 공유하는가?
    - 애그리게이트의 비즈니스 로직이 변경되면 하위 도메인의 다른 구성요소에 영향을 주는가?
- 애그리게이트와 바신의 하위 도메인에 있는 다른 비즈니스 엔티티와의 관계가 강할수록 얕은 개별 서비스가 된다

### 하위 도메인

- 하위 도메인의 크기와 ‘어떻게’ 보다는 ‘무엇을’에 중점을 둔 기능이 하위 도메인을 깊은 모듈로 만든다
- 하위 도메인을 MSA로 만드는 것은 대부분의 MSA를 위한 최적의 솔루션을 만드는 안전한 휴리스틱이다

---

## 마이크로서비스의 퍼블릭 인터페이스 압축하기

DDD는 서비스의 경계를 찾는데 쓰일 뿐 아니라 서비스를 깊게 만드는 데도 도움을 준다

### 오픈 호스트 서비스

- OHS는 BC 모델을 시스템의 다른 구성요소와 연동하는 데 사용되는 모델과 분리해준다
- 서비스 사용자에게 영향을 미치지 않고 서비스의 구현을 발전시킬 수 있다
- 공표된 언어는 좀 더 제한된 모델을 노출한다
- 동일한 로직에 대한 더 간단한 퍼블릭 인터페이스를 갖게 되면 서비스가 더 깊어지고 더 효과적으로 MSA 설계가 가능함

### 충돌 방지 계층

- 서비스를 다른 BC와 연동할 때 복잡성을 줄여준다
- ACL 서비스는 로컬 복잡성과 글로벌 복잡성을 모두 줄여준다
- ACL 덕분에 BC를 사용할 때 비즈니스 복잡성과 연동할 떄의 복잡성이 분리되고 ACL은 연동의 복잡성을 담당한다
- 연동 지향적인 모델로서 BC의 사용자는 압축된 퍼블릭 인터페이스와 좀 더 편리하게 동작한다.