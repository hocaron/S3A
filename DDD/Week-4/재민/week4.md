# [DDD] 박재민 7~8장

# 7. 시간 차원의 모델링

이벤트 소싱 도메인 모델 패턴은 도메인 모델 패턴과 **동일한 전제를 기반**으로 한다. 동일한 **전술적 패턴** (밸류 오브젝트, 애그리게이트, 도메인 이벤트)을 사용며, 두 패턴은 **애그리게이트의 상태를 저장하는 방식에 차이**가 있다. 이벤트 소싱 도메인 모델은 이벤트 소싱 패턴을 사용해 애그리게이트 상태를 관리한다. 즉, 애그리게이트의 상태를 유지하는 대신 **각 변경사항을 설명하는 도메인 이벤트를 생성**하고 애그리게이트 데이터에 대한 **원천 데이터**로 사용한다.

## 이벤트 소싱

**문제 상황**

- 상태에 기반한 모델링을 할 경우 비즈니스 관점에서 각 리드의 현재 상태만 알 수 있다. 현재 상태가 되기 까지 어떠한 비즈니스적 활동이 있었는지에 대한 정보는 모두 유실된다.

**해결 방안**

- 데이터 모델에 시간 차원을 도입한다.
- 애그리게이트의 수명 주기의 모든 변경사항을 문서화 하는 이벤트를 유지한다.
- 각 이벤트는 버저닝을 하여 모든 변경의 횟수를 나타낸다. 이런 경우 **시간 여행**이 가능해져 예를 들어, 버전 5에서 엔티티의 상태가 필요한 경우 처음 5개 이벤트를 프로젝션 할 수 있다.

### 검색

**문제 상황**

- 현재 상태에 기반한 모델링을 하는 경우 과거 정보를 프로젝션할 수 없다. 예를 들어 고객이 연락처를 변경했을 경우 과거 연락처와 관련이 있는 정보를 프로젝션 할 수 없다.

**해결 방안**

- 각 세부 사항의 변경 또한 이벤트로 관리한다. 위와 똑같이 변경사항 이벤트를 정의하고 버전을 하나 올린다.

### 분석

**문제 상황**

- 영어 프로세스 최적화를 위해 후속 전화 이벤트가 리드 이벤트에 나타난 횟수를 프로젝션 하고 싶다.

**해결 방안**

- 후석 전화 이벤트가 발생할 때 Followups 라는 변수에 +1 하여 카운팅한다.

> 이벤트에 기반한 모델링의 중요성에 대해 얘기하는 듯!
> 

### 원천 데이터

이러한 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장되어야 한다. 여기서 사용된 이 이벤트가 시스템의 **원천 데이터**가 된다. 이 이벤트를 저장하는 데 사용되는 데이터베이스는 유일하고 강력하게 일관되어야 하며 이를 지칭하는 이름이 **이벤트 스토어**다.

### 이벤트 스토어

이벤트 스토어는 추가만 가능한 저장소이므로 이벤트를 수정하거나 삭제할 수 없다. 이벤트 소싱 패턴을 구현하려면 이벤트 스토어가 Fetch(가져오기), Append(추가) 기능을 지원해야 한다. 추가 기능에는 expenctedVersion을 두어 동시성 체크를 할 수 있다. 더불어 entityVersion을 두어 엔티티에 대한 동시성 체크 또한 가능하다. 이를 통해 낙관적 동시성 제어를 구현할 수 있다.

## 이벤트 소싱 도메인 모델

이벤트 소싱 도메인 모델은 애그리게이트의 수명주기를 모델링하기 위해 독점적으로 도메인 이벤트를 사용한다. 애그리게이트 상태에 대한 모든 변경사항은 **도메인 이벤트**로 표현된다.

### **이벤트 소싱 애그리게이트에 대한 작업 순서**

1. 애그리게이트의 도메인 이벤트를 로드
2. 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성
3. 애그리게이트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 도메인 이벤트를 생성
4. 새 도메인 이벤트를 이벤트 스토어에 커밋

### 장점

- 시간 여행
    - 애그리게이트의 모든 과거 상태를 복원할 수 있다. 시스템의 동작을 분석하고, 시스템의 의사결정을 검사하고, 비즈니스 로직을 최적화할 때 필요하다.
    - 소급 디버깅이라는 유스케이스로 애그리게이트에서 버그가 관측됐을 때의 상태로 정확히 되돌릴 수 있다.
- 심오한 통찰력
    - 시스템의 상태와 동작에 대한 깊은 통찰력을 제공한다
- 감사 로그
    - 법률에 따라 일부 비즈니스 도메인에서는 감사 로그가 필수인데 영속적인 도메인 이벤트는 애그리게이트 상태에 대한 강력하게 일관된 감사 로그이다.
- 고급 낙관적 동시성 제어
    - 데이터가 덮여 쓰여질 수 없으며 새로운 이벤트가 시도된 작업과 충돌하는지, 계속 진행하는게 안전할 지에 대한 비즈니스 도메인 주도 의사결정을 내릴 수 있다.

### 단점

- 학습 곡선
    - 기존 기술과 사고 방식에 차이가 있기에 시스템 구현에 학습 곡선을 고려해야 한다
- 모델의 진화
    - 이벤트는 변경할 수 없기에 이벤트의 스키마 조정 또한 어렵다.
- 아키텍처 복잡성
    - 아키텍처의 ‘유동적인 부분’이 도입되어 전체 설계가 더 복잡해질 수 있다.

## 자주 묻는 질문

### 성능

**이벤트에서 애그리게이트 상태를 재구성하면 시스템 성능에 부정적 영향을 주고 이벤트가 추가되면서 성능이 저하된다. 어떻게 작동할 수 있을까?**

Answer: 애그리게이트당 10,000 개 이상의 이벤트를 구현할 경우 성능 저하가 일어나지만 대부분의 시스템에서는 100개 이벤트를 초과하지 않는다.

상태를 프로젝션 하는 것이 성능에 문제가 되는 경우는 드물지만, 스냅샷 패턴을 통해 해결할 수 있다. 프로세스는 이벤트 스토어에서 새 이벤트를 지속적으로 순회하며 프로젝션을 생성하고 캐시에 저장한다. 애그리게이트 작업 중 프로젝션이 필요한 경우 프로세스는 캐시에서 현재 상태의 프로젝션을 가져와 스냅샷 버전 이후에 발생한 이벤트를 가져와 스냅샷에 적용한다. 스냅샷 패턴은 10,000개 이상의 이벤트를 갖는 시스템에서만 사용하자. 오히려 시스템을 더 복잡하게 만든다!

**이 모델은 엄청난 양의 데이터를 생성한다. 확장 할 수 있을까?**

Answer: 확장이 용이하다. 모든 애그리게이트 관련 작업은 단일 애그리게이트 컨텍스트에서 수행되므로 이벤트 스토어는 애그리게이트 ID 분할이 가능하다. 애그리게이트의 인스턴스에 속하는 모든 이벤트는 단일 샤드에 있어야 한다.

### 데이터 삭제

**물리적으로 데이터 삭제가 필요한 경우가 있을 수 있다. 가능한가?**

Answer: **페이로드 패턴**을 사용할 수 있다. 민감 정보를 암호화된 형식으로 이벤트에 포함시킨다. 키는 특정 애그리게이트의 ID고 값은 암호화 키이다. 민감 데이터를 삭제하는 경우 암호화 키를 삭제시켜 버리면 된다!

### 그 외

**텍스트 파일에 로그를 작성해 감사 로그로 사용할 수 없는 이유는?**

- 실시간 데이터 처리 DB와 텍스트 파일에 동시에 쓰는 경우 오류가 발생하기 쉽다. 두 개의 작업은 하나의 트랜잭션에서 처리되어야 하며, DB에서 쓰기가 실패한 경우 텍스트 파일의 이전 로그도 사라져야 하는데 그렇지 않다. 이런 경우 일관성이 없어진다.

**상태 기반 모델을 계속 사용할 수 없지만 동일한 데이터베이스 트랜잭션에서 로그를 로그 테이블에 추가할 수 없는 이유는?**

- 인프라 관점에서 상태와 로그 레코드 간의 일관된 동기화를 제공할 수 있지만, Human error로 추후 작업할 엔지니어가 적절한 로그 레코드를 추가하는 것을 잊어 버릴 수 있다 (뭔 말?)
- 일반적으로 모든 필수 정보가 올바른 형식으로 작성되도록 강제할 방법은 없다. (뭐래니 ?)

**상태 기반 모델을 계속 사용할 수 없지만 레코드의 스냅샷을 만들어 전용 ‘이력’ 테이블에 복사하는 데이터베이스 트리거를 추가할 수 없는 이유는? (질문 부터 난해..)**

- 진짜 모르겠다.. PASS!!

---

# 8. 아키텍처 패턴

시스템의 구성요소 간의 상호작용과 의존성을 조율하는 방법에 대해 알아보자

## 비즈니스 로직과 아키텍처 패턴

**코드베이스가 처리해야할 다양한 관심사**

1. 기능 또는 비기능 요구사항을 구현하기 위한 많은 책임을 담당
2. 사용자와 상호작용해서 입력을 받고 결과를 제공
3. 다양한 저장소에 상태를 저장하고 외부 시스템 및 정보 제공자와 연동

**위의 관심사로 인해 발생할 수 있는 문제점**

1. 비즈니스 로직이 다양한 구성요소에 흩어지기 쉽다
2. 관심사를 구현할 때 엄격하게 구성하지 않으면 코드베이스의 변경이 어려워진다
3. 비즈니스 로직이 변경될 때 코드베이스의 어떤 부분이 영향을 받는지 분명하지 않을 수 있다
4. 보기에 관련 없는 부분에 기대치 않게 변경이 영향을 미칠 수 있다
5. 변경해야 할 부분을 놓치기 쉽다

→ 위 모든 문제점은 코드베이스의 유지보수 비용을 크게 증가시킨다

즉, 코드베이스를 조직하는 적절한 방법 혹은 올바른 아키텍처 패턴을 선택하는 것은 1. 비즈니스 로직 구현을 지원하고 2. 유지보수를 돕기 위해 매우 중요하다.

## 계층형 아키텍처

코드베이스를 수평 계층으로 조직하고, 각 계층은 

1. 사용자와 상호작용 (PL; Presentation Layer)
2. 비즈니스 로직의 구현 (BLL; Business Logic Layer)
3. 데이터의 저장과 같은 기술적 관심사  (DAL; Data Access Layer)

중 하나를 다룬다.

### 프레젠테이션 계층 (PL; Presentation Layer)

사용자와 상호작용을 하기 위한 프로그램의 사용자 인터페이스를 구현하며 다음의 범주를 포함한다.

1. 그래픽 사용자 인터페이스
2. 커맨드 라인 인터페이스
3. 다른 시스템과 연동하는 프로그래밍 API
4. 메시지 브로커에서 이벤트에 대한 구독
5. 나가는 이벤트를 발행하는 메시지 토픽

즉, PL 은 프로그램의 **퍼블릭 인터페이스** 이다.

### 비즈니스 로직 계층(BLL; Business Logic Layer)

프로그램의 비즈니스 로직을 구현하고 묶는 것음 담당하며 비즈니스 의사결정을 구현한다.

### 데이터 접근 계층 (DAL; Data Access Layer)

영속성 메커니즘에 접근할 수 있게 해주며 다음과 같은 좀 더 넓은 범위의 책임을 진다.

1. 혁신적인 NoSQL이 출현한 이래로 여러 데이터베이스를 사용하는 시스템이 보편화됨
2. 정보 저장용으로 전통적인 데이터베이스뿐만 아니라 다양한 매체가 있음
3. 프로그램의 기능을 구현하는 데 필요한 다양한 외부 정보 제공자와 연동의 책임

### 계층 간 커뮤니케이션

톱다운 커뮤니케이션 모델에 따라 연동 되며 각 계층은 하위 계층에만 의존해 구현 관심사의 결합성을 낮추고 계층 간에 공유할 지식을 줄인다. (PL → BLL → DAL)

### 변종

계층형 아키텍처 패턴을 확장해 서비스 계층을 추가할 수 있음

**서비스 계층**

- 프레젠테이션 계층과 비즈니스 로직 계층 사잉의 중간 역할
- 프레젠테이션 계층과 하위 비즈니스 로직의 결합을 제거하기 위해 이런 조율로직들을 서비스 계층에 위치시킬 수 있다.
- 논리적 경계라는 것이 중요. 절대 물리적 서비스가 아니다!!
- 서비스 계층을 명시적으로 갖추면 생기는 장점
    1. 동일한 서비스 계층을 여러 퍼블릭 인터페이스에서 재사용할 수 있다
    2. 모든 관련 메서드를 한곳에 모으면 모듈화가 개선된다
    3. 프레젠테이션 계층과 비즈니스 로직 계층의 결합도를 낮춘다
    4. 비즈니스 기능 테스트가 쉬워진다

### 용어

프레젠테이션 계층 → 사용자 인터페이스 계층

서비스 계층 → 애플리케이션 계층

비즈니스 로직 계층 → 도메인 계층 → 모델 계층

데이터 접근 계층 → 인프라스트럭처 계층

### 계층형 아키텍처를 사용하는 경우

비즈니스 로직이 트랜잭션 스크립트 혹은 액티브 레코드 패턴을 사용하여 구현된 시스템에 적합

도메인 모델을 구현하는 데 적용하기는 어려움. (비즈니스 엔티티가 하부 인프라스터럭처에 대한 의존성이 없어야 하고 이를 몰라야 하기 때문)

## 포트와 어댑터

계층형 아키텍처의 단점을 극복하고 좀 더 복잡한 비즈니스 로직을 구현하는 데 적합

### 용어

프레젠테이션 계층과 데이터 접근 계층을 인프라스트럭처 계층으로 통합!

### 의존성 역전 원칙

의존성 역전 원칙 (DPI; Dependency inversion principle) 은 비즈니스 로직을 구현하는 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다고 말한다. 

전통적인 계층형 아키텍처에서 비즈니스 로직 계층이 인프라스트럭처 계층을 의존하는 것이 아닌 관계를 반대로 하고 그 중간에 애플리케이션 계층을 넣자! 이렇게 한 경우 비즈니스 로직을 작성할 때 어떠한 하위 계층에도 의지하지 않을 수 있다.

### 인프라 구성요소의 연동

포트와 어댑터 아키텍처의 핵심은 인프라스트럭처 구성요소로부터 시스템의 비즈니스 로직을 분리하는 것이다. 비즈니스 로직 계층은 인프라스트럭처 계층이 구현해야 할 ‘포트’를 **정의** 하고 인프라 스트럭처는 정의된 포트를 **어댑터로 구현**한다!

### 변형

이 패턴은 헥사고날, 어니언, 클린 아키텍처로 알려졌다. 

애플리케이션 계층 = 서비스 계층 = 유스케이스 계층

비즈니스 로직 계층 = 도메인 계층 = 핵심 계층

유비쿼터스 언어의 중요성을 보여주는 예시다!!

### 포트와 어댑터를 사용하는 경우

모든 기술적 관심사로부터 비즈니스 로직을 분리하는 것이 목적이므로 도메인 모델 패턴을 사용해 구현한 비즈니스 로직에 매우 적합하다!

## CQRS (Command-Query Responsibility Segregation)

포트와 어댑터와 동일한 비즈니스 로직과 인프라스트럭처 관심사에 기반한다. 하지만 시스템의 데이터 관리하는 방식에 차이가 있다. 이 패턴을 사용하면 여러 영속 모델 시스템의 데이터를 표현할 수 있다.

### 폴리글랏 모델링

우리는 시스템 데이터의 다양한 표현이 있을 수 있으며 완벽한 데이터 베이스는 존재하지 않는다는 것을 인지해야 한다. 여러 모델을 통해 여러 표현이 만들어질 수 있으며 각 모델을 저장하는 영속성 모델이 다 다를 수 있다. 이 때 폴리글랏 영속성 모델을 사용해 다양한 데이터 관련 요구사항을 여러 데이터베이스를 사용해 구현할 수 있다.

### 구현

이 패턴은 시스템 모델의 책임을 분리시킨다. 여기엔 커맨드 실행 모델과 일기 모델 두 유형이 있다.

### 커맨드 실행 모델

CQRS에는 시스템의 상태를 수정하는 오퍼레이션을 전담으로 수행하는 단일 모델이 있다. 커맨드 실행 모델은 시스템의 원천인 강력한 일관성을 가진 데이터를 표현하는 유일한 모델이며 비즈니스 엔티티의 일관적 상태를 읽과 갱신할 때 낙관적 동시성을 지원해야 한다.

### 읽기 모델

다양한 방식으로 사용자에게 데이터를 보여주는 모델을 정의할 수 있다. 잘 구현된 CQRS에는 모든 프로젝션의 모든 데이터를 삭제해도 처음부터 다시 생성이 가능하며, 새로운 프로젝션을 시스템에 확장하는 것도 가능하다. 읽기 모델은 읽기 전용이며, 시스템의 어떤 오퍼레이션도 읽기 모델의 데이터를 직접 수정할 수 없다.

### 읽기 모델의 프로젝션

읽기 모델이 작동하려면 시스템은 커맨드 실행 모델에서 변경을 모든 읽기 모델로 프로젝션해야 한다. 읽기 모델의 프로젝션은 머터리얼라이트 뷰의 개념과 유사해 원천 테이블이 갱신되면 변경사항이 해당 뷰에 반영되어야 한다. 프로젝션을 생성하는 방식은 동기식, 비동기식 방식이 있다.

### 동기식 프로젝션

체크포인트를 두어 프로젝션 엔진이 OLTP 데이터베이스로부터 추가되거나 갱신된 레코드를 조회해 시스템의 읽기 모델을 재생성 또는 갱신한다. 이후 마지막으로 처리 레코드의 체크포인트를 저장하고 다음 변경 혹은 갱신 때 해당 체크포인트를 사용한다. 처음부터 재생성할 경우 체크포인트를 0으로 만들면 된다!

### 비동기식 프로젝션

커맨드 실행 모델은 모든 커밋된 변경사항을 메시지 버스에 던진다. 시스템의 프로젝션 엔진은 메시지를 구독해 읽기 모델에 바로바로 갱신한다.

### 도전과제

비동기식 프로젝션은 순서가 잘못되거나 중복의 오류가 있을 수 있으며 프로젝션을 처음부터 재생성하기 어렵다. 그러니 동기식 프로젝션을 기반으로 하고 비동기식 프로젝션을 추가하는 것을 권장한다!

### 모델 분리

CQRS 아키텍처는 시스템 모델이 담당하는 책임은 그 타입에 따라 분리된다(?? 무슨 말). 커맨드는 강한 일관성을 가진 커맨드 실행 모델에서만 동작하고 질의는 읽기 모델과 커맨드 실행 모델을 포함해 그 어떤 시스템의 영속 상태를 직접 수정할 수 없다.

커맨드는 실행시 성공/실패 여부를 호출자에게 알려야 한다. 즉, **대부분의 커맨드는 데이터를 반환**해야 한다!

유일한 단점은 반환 데이터가 강한 일관성 모델에서 비롯되어야 한다는 것이다. 즉, 데이터가 궁극적으로 일관성을 갖는 프로젝션의 경우에는 데이터에 대한 즉각적인 갱신을 기대할 수 없다. (뭥미?, 무슨말이징.. ? ㅎㅎ;)

### CQRS를 사용해야 하는 경우

여러 모델, 다양한 종류의 데이터베이스에 저장된 동일한 데이터와 작동할 필요가 있는 애플리케이션에 유용하며, 이벤트 소싱 도메인 모델에도 적합하다. CQRS를 통해 상태에 기반한 프로젝션이 가능해진다.

## 범위

위에서 설명한 아키텍처가 전체 바운디드 컨텍스트를 위한 고수준 아키텍처 패턴도 아니니 시스템 전체에 적용하는 구성 원칙으로 취급하면 안된다.

하위 도메인에는 여러 다입이 있고 동일 타입의 하위 도메인도 다양한 비즈니스 로직과 아키텍처 패턴이 필요할 수 있다. 바운디드 컨텍스트에 단일 아키텍처를 강요하며 의도치않는 우발적 복잡성을 유발할 수 있다.

우리의 목적은 실제 필요성과 비즈니스 전략에 따라 설계 의사결정을 나누는 것이며 수평으로 나누는 것 외에도 수직으로 나눌 수 있다.

비즈니스 하위 도메인을 묶는 모델의 논리적 경계를 분명하게 정의하고 각각에 맞는 도구를 선택하는 것이 중요하다.

적적한 수직 경계는 모놀리식 바운디는 컨텍스트를 모듈화할 수 있다.