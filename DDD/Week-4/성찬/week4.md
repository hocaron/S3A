# 7 시간 차원의 모델링

## 이벤트 소싱
아래와 같은 테이블을 분석하면 많은 정보를 어등ㄹ 수 있다.

  | lead-id | status    | created-on              | updated-on              |
  |---------|-----------|-------------------------|-------------------------|
  | 1       | CONVERTED | 2023-03-29T10:00:00.00Z | 2023-03-29T10:00:00.00Z |
  | 2       | CLOSED    | 2023-03-29T10:00:00.00Z | 2023-03-29T10:00:00.00Z |
  | 3       | NEW_LEAD  | 2023-03-29T10:00:00.00Z | 2023-03-29T10:00:00.00Z |

lead의 현재 status를 분석하여 잠재 고객의 처리 주기를 가정할 수 있다.

* 판매 흐름은 NEW_LEAD 상태의 잠재 고객과 함께 한다.
* 판매 제안에 관심 없는 사람은 CLOSED
* 결제가 성공하면 고객으로 전환되어 CONVERTED

이 테이블엔 현재 상태는 문서화하지만 현재 상태에 도달하기까지가 누락되어 있다.

* 상태를 변경하기 위해 얼마나 많은 전화를 걸었는지?
* 구매가 바로 이루어졌는지?

등등을 알기 어렵다. 이렇게 누락된 정보를 채우는 방법 중 하나가 이벤트 소싱을 사용하는 것이다.    
이벤트 소싱 패턴은 데이터 모델에 시간 차원을 도입한다. 애그리게이트의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지한다.  

예제를 살펴보자

```json
{
  "lead-id": 12,
  "event-id": 0,
  "event-type": "lead-initialized",
  "timestamp": "..."
},
{
"lead-id": 12,
"event-id": 1,
"event-type": "contacted",
"timestamp": "..."
},
{
"lead-id": 12,
"event-id": 2,
"event-type": "followup-set",
"timestamp": "..."
}
```

이벤트 id를 남겨서 어떤 이벤트인지 확인하자. 그리고 이벤트에는항상 버전을 남겨서 변경의 횟수를 나타낸다.  
이렇게 되면 이벤트의 특정 시점으로 엔티티의 상태를 프로젝션 할 수 있다. 버전 5가 필요하면 처음 5개의 이벤트만 적용하면 된다.  

