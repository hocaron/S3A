# 0. 컨슈머의 내부 동작 원리와 구현 요약

- 컨슈머는 반드시 컨슈머 그룹에 속한다.
- 컨슈머 그룹은 그룹 코디네이터에게 관리받는다.
- 그룹 코디네이터는 컨슈머 그룹의 상태를 트래킹하여 리밸런싱할 준비를 하고 있는다.
- 이 때 그룹 코디네이터와 컨슈머 그룹 내 컨슈머들은 상호간의 하트비트를 주고받으며 서로의 상태를 알린다.
- 스태틱 멤버쉽을 이용하면 컨슈머를 재시작하는 등 일시적으로 운용을 중단할 때 리밸런싱을 수행하지 않도록 할 수 있다.


# 1. 컨슈머의 오프셋 관리

오프셋은 카프카의 메세지 위치를 가리킨다.

오프셋은 숫자로 나타내며 `__consumer_offsets`라는 컨슈머 그룹의 토픽에 저장된다.

컨슈머들은 지정된 토픽의 메세지를 읽은 후 읽어온 위치의 오프셋 정보를 `__consumer_offsets`에 기록한다. 이 때 기록하는 오프셋의 숫자는 다음에 읽어야할 오프셋의 수로 지정한다.

또한 오프셋만을 기록하는 것이 아니라 컨슈머 그룹, 토픽, 파티션의 내용을 통합해서 기록한다.

---

# 2. 그룹 코디네이터

컨슈머들은 하나의 컨슈머 그룹에 반드시 속한다. 또한 해당 그룹내의 컨슈머들은 서로의 상태 및 정보를 공유하고 있다.

컨슈머 그룹에는 컨슈머가 추가/삭제가 제한이 없기 때문에 이러한 변화에 대해 대응하여 작업을 적절히 분배해야한다.

이 과정을 `컨슈머 리밸런싱`이라고 말한다.

컨슈머 리밸런싱을 관리하기 위해 별도의 코디네이터가 존재하는데 이를 `그룹 코디네이터`라고 한다. 

이 `코디네이터의 목적`은 `컨슈머 그룹이 구독한 토픽의 파티션`, `그룹의 멤버`를 `트래킹`하고 있는 것이다.

이 그룹 코디네이터는 카프카 클러스터 내의 브로커 중 하나에 속한다.

## 2.1 그룹 코디네이터 생성 시점

컨슈머 그룹이 브로커에 최초 연결 요청을 보내면 브로커 중 하나(리더 브로커)에 그룹 코디네이터가 생성된다.

## 2.2 그룹 코디네이터에 컨슈머 그룹이 등록되는 과정

1. 컨슈머 설정 값으로 `bootstrap.brokers`리스트에 있는 브로커에 초키 커넥션을 연결하기 위한 요청을 보낸다.
2. 요청받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에 응답을 보낸다.
   3. 단, 컨슈머 그룹의 첫 컨슈머가 등록될때까지 아무런 작업도 하지 않는다.
4. 그룹 코디네이터는 `group.initail.rebalance.delay.ms`시간 동안 컨슈머의 요청을 기다린다.
5. 컨슈머가 컨슈머 등록 요청을 그룹 코디네이터에게 보낸다. 이 때 가장 먼저 요청을 보낸 컨슈머가 컨슈머 그룹의 리더가 된다.
6. 그룹 코디네이터가 해당 컨슈머 그룹이 구독하는 토픽, 파티션 리스트 등을 리더 컨슈머의 요청에 응답을 보낸다.
7. 리더 컨슈머는 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당한 후 그룹 코디네이터에 이 내용을 알린다.
8. 그룹 코디네티어는 이 정보들을 캐시한 후 각 그룹의 모든 컨슈머들에게 성공을 알린다.
9. 각 컨슈머들은 각자 지정된 토픽 파티션에 메세지를 가져온다.

## 2.3 컨슈머 그룹 내 컨슈머가 예기치 못한 이유로 종료된다면 어떻게 대응할까?

컨슈머를 사용하는 입장에서는 `bootstrap.brokers`, `group.id`만 등록하면 알아서 사용이 가능했다. 이 뒷단에서는 컨슈머 그룹과 그룹 코디네이터가 상호 통신하면서 컨슈머 그룹이 안정적으로 메세지를 읽을 수 있도록 하는 것이었다.

그런데 만약 컨슈머 그룹 내 컨슈머가 예기치 못한 이유로 종료된다면 어떻게 대응할까?

그룹 코디네이터와 컨슈머들은 서로간의 `하트비트`를 주고 받는다. 따라서 코디네이터와 컨슈머가 서로간의 상태를 확인하며 특정 컨슈머가 문제가 발생했다고 판단되면 컨슈머 리밸런싱을 통해 이 문제를 해결하고자 한다.

## 2.4 만약 그룹 코디네이터가 예기치 못하게 종료되었다면?

그룹 코디네이터는 브로커 중 하나에게 위임되는 것이라고 했다. 그 브로커는 리더인 브로커일 가능성이 높기 때문에 그룹 코디네이터가 불용상태로 되었다면 카프카 클러스터 내의 `Election`등의 과정을 통해 새로운 리더를 선출한다.

그리고 그 리더에게 그룹 코디네이터의 정보를 전달하여 클러스터링을 유지하는 것으로 장애 허용을 처리한다.

하지만 이 비용(시간적인)이 꽤나 크기 때문에 이를 최소화 하기 위해 [KRaft Craft하기](https://k-diger.github.io/posts/KRaft/)이 자료를 참고하면 좋을듯 하다. ^^

---

# 3. 컨슈머 하트비트 옵션

## 3.1 `headrtbeart.interval.ms`

`기본값은 3000`이며, 그룹 코디네이터와 하트비트를 주고 받는 간격이다. `session.timeout.ms`보다 낮게 설정해야 세션이 끊기지 않고 하트비트를 주고 받을 수 있다.

## 3.2 `session.timeout.ms`

`기본값은 10000`이며, 컨슈머의 하트비트를 이 시간 내에 받지 못하면 컨슈머 그룹에서 해당 컨슈머는 제거되고 리밸런싱을 수행한다.

## 3.3 `max.poll.interval.ms`

`기본값은 300000`이며, 컨슈머가 주기적으로 `poll()`을 호출하여 토픽의 레코드들을 가져오는데, `poll()`호출 후 지정한 시간동안 `poll()`호출이 없다면 컨슈머 장애로 판단하여 리밸런싱을 수행한다. 

---

# 4. 컨슈머 리밸런싱 고려해야할 점

컨슈머 리밸런싱은 매우 높은 비용이 든다. (CPU, Time)따라서 리밸런싱이 자주 발생하지 않도록 관리해야할 필요가 있다.

즉, 컨슈머 하트비트 옵션을 적절히 조정해가는 것이 중요한데, 

컨슈머의 장애를 빠르게 감지하도록 `ms`값들을 낮게 설정하면 일시적인 컨슈머의 타임아웃이나 TCP패킷 손실로 인해 원하지 않게 리밸런싱이 동작할 수 있고

컨슈머의 장애를 여유있게 감지하도록 `ms`값들을 높게 설정하면 실제로 장애가 발생했을 때 그 시간만큼 파티션의 메세지를 읽지 못하는 현상이 발생한다.

따라서 이 값들을 DevOps한테 잘 맡겨서 효율적으로 운용해야한다.

---

# 5. 스태틱 멤버쉽

컨슈머 그룹 내의 컨슈머들을 의도적으로 하나씩 재시작 하는 경우가 있을 수 있다. 하지만 위에서 살펴본대로 하트비트 주기, 세션 타임아웃 등의 설정으로 하나의 컨슈머를 재시작할 때마다 리밸런싱이 일어나게 된다.

컨슈머 그룹 내의 컨슈머들이 몇개 없다면 괜찮겠지만 10개 ... 100개가 되는 순간 곤란해진다.

`스태틱 멤버쉽`은 컨슈머 재시작 등 그룹에서 나갔다 들어오는 중 리밸런싱을 수행하지 않게 도와준다. 즉, 컨슈머마다의 동적인 ID가 아닌 정적인 ID를 부여하여 기존 구성원임을 인식할 수 있도록 한다.

## 5.1 스태틱 멤버쉽 적용방법

`group.instance.id`옵션을 설정하면 된다. 기본값은 `"null"`로 지정되어있다. 이 옵션의 실제 값으로는 그룹 코디네이터가 컨슈머를 식별할 수 있는 고유한 값으로 지정해야한다.

즉, `consumer-123.456.678`, `consumer-234.567.89` 등과 같이 호스트 네임이나 서버 IP로 지정해도 좋다.

## 5.2 스태틱 멤버쉽 적용 후 고려해야할 점, `session.timeout.ms`

스태틱 멤버쉽 기능을 적용하면 `session.timeout.ms`을 기본값보다는 크게 설정하는 것이 좋다. 

컨슈머를 재시작한 후 `session.timeout.ms`값에 지정된 시간동안 하트비트를 못받으면 리밸런싱을 수행해버리기 때문이다.

컨슈머 재시작까지 2분이 걸린다면 2분보다 큰 값으로 하는게 안전하고 스태틱 멤버쉽을 활용하는 의미가 있게 되는 것이다.

---

# 6. 파티션 할당 전략

프로듀서의 파티셔너는 레코드를 토픽의 어느 파티션으로 전송할지 결정하는 역할을 한다.

컨슈머도 토픽의 어느 파티션으로부터 레코드를 읽어올지에 대한 결정을 수행하는 파티션 할당 전략이 있다.

할당 전략으로는 컨슈머 옵션의 `partition.assignment.strategy`를 활용하고 그 값으로 `RangeAssignor`, `RoundRobinAssignor`, `StickyAssignor`, `CooperativeSticyAssignor`가 있다.

## 6.1 4가지 파티션 할당 전략 요약

![img.png](https://github.com/mash-up-kr/S3A/blob/master/14th_kafka/dohyeon/image/5_1.png?raw=true)

- `RangeAssignor`
  - 기본값으로 토픽별로 할당 전략을 사용한다. 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 좋다.
- `RoundRobinAssignor`
  - 사용 가능한 파티션과 컨슈머들을 라운드 로빈으로 할당한다. 균등 분배가 가능한 장점이 있다.
- `StickyAssignor`
  - 컨슈머가 컨슘하고 있는 파티션을 계속 유지할 수 있다.
- `CooperativeStickyAssignor`
  - 스티키 방식과 유사하지만, 전체 일시 정지가 아닌 연속적인 재조정 방식을 사용한다.

## 6.2 파티션은 누가 할당해주나?

컨슈머 그룹의 리더 컨슈머가 정해진 파티션 할당 전략에 따라 각 컨슈머와 토픽의 파티션을 매칭시켜준다.

## 6.3 레인지 파티션 할당 전략

각 토픽별로 할당 전략을 사용하여 먼저 구독하는 토픽에 대한 파티션을 순서대로 나열한 후 컨슈머를 순서대로 정렬한다.

즉, `토픽 1`의 `파티션`이 `3개`, `토픽 2`의 `파티션`이 `3개`, `컨슈머`가 `2개`일때

`컨슈머 1`에게 `토픽 1의 파티션 0, 1` + `토픽 2의 파티션 0, 1`를 할당할 수 있고

`컨슈머 2`에게 `토픽 1의 파티션 2` + `토픽 2의 파티션 2`를 할당할 수 있다.

### 이런 단순한 전략을 왜 사용할까?

동일한 레코드(메세지)키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용할 수 있다.

## 6.4 라운드 로빈 파티션 할당 전략

우리가 흔히 아는 라운드 로빈 방식으로 파티션을 할당한다.

### 6.4.1 컨슈머 그룹 내 컨슈머 이탈

1. 컨슈머 1, 2, 3 중 컨슈머 2가 이탈했다.
2. 리밸런싱을 수행한다.
3. 모든 파티션을 순서대로 배치한다.(토픽, 파티션의 번호 오름차순으로)
4. 컨슈머를 순서대로 배치한다. (컨슈머 번호를 오름차순으로)
5. 라운드 로빈 파티션 전략에 따라서 하나씩 매핑한다.

## 6.5 스티키 파티션 할당 전략

컨슈머 그룹에 리밸런싱이 발생하여 파티션이 재할당된다면 기존에 지정되어있던 파티션 또한 변경될 수도 있다.

그래서 리밸런싱되어도 파티션을 최대한 기존과 가깝게 매핑시키는 전략이 스티키 파티션 할당 전략이며, 또한 균형잡힌 파티션 할당을 위한 목적도 있다.

초기에는 라운드 로빈과 유사한 방식으로 각 컨슈머에 파티션을 할당하며, 리밸런싱이 일어난 후에는 기존 파티션을 유지하고 리밸런싱이 발생해도 현재 매핑된 파티션은 유지한채 매핑 공백이 된 파티션을 그대로 위임받도록 하는 흐름이다.

이 과정에서 고려하는 점이 몇가지 있다.

- 컨슈머들의 최대 할당된 파티션의 수의 차이는 1이여야한다.
- 기존 존재하는 파티션 할당은 최대한 유지해야한다.
- 재할당 동작 시 유효하지 않은 모든 파티션 할당은 제거한다.
- 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머에 할당한다.

기존 라운드로빈은 리밸런싱이 일어나면 모든 파티션을 대상으로 파티션을 재할당해줘야했지만 스티키 파티션 할당 전략은 그렇지 않기 때문에 효율적으로 동작한다.

## 6.6 협력적 스티키 파티션 할당 전략

컨슈머 리밸런싱 동작에서는 `EAGER`라는 리밸런스 프로토콜을 사용했다. 이 프로토콜은 컨슈머 리밸런싱 동작 시 컨슈머의 할당된 모든 파티션을 할당 해제했다.

할당을 해제하는 이유는 컨슈머들의 파티션 소유권 변경 때문이다.

A컨슈머가 가진 0번 파티션을 B컨슈머에게 넘겨야하는 상황일 때, 하나의 컨슈머 그룹에 속한 여러 컨슈머들은 동일한 파티션을 바라볼 수 없다.

따라서 모든 파티션 할당을 해제하고 B컨슈머에게 0번 파티션의 소유권을 넘긴다.

이 방식의 장점으로는 모든 컨슈머와 파티션을 한 번의 리밸런싱으로 다시 매핑할 수 있다는 것인데, 리밸런싱 중 모든 파티션의 할당을 취소하는 것은 생각보다 비용이 비싸다.

그 모든 컨슈머-파티션의 매핑이 할당해제된 시간동안 메세지들이 소비되고 있지 않기 때문이다. (DownTime -> STW랑 비슷한 느낌인듯)

그래서 내부 리밸런싱 프로토콜인 `COOPERATIVE`프로토콜이 등장하여 리밸런싱이 동작하기 전의 컨슈머 상태를 유지할 수 있게 되었다.

이미 동작중인 파티션은 계속 매핑을 유지한 채, 리밸런싱을 수행하여 새로운 컨슈머의 추가/삭제에 대응한다. 

여러 번의 리밸런싱이 일어난다는 점이 있지만 유휴상태인 파티션과 컨슈머만이 리밸런싱에 참여하기 때문에 리밸런싱 과정에서 발생하는 처리량 저하를 크게 보완할 수 있게 되었다.

---

# 7. 정확히 한 번 컨슈머 동작

프로듀서츠의 정확히 한 번 전송 동작은 `트랜잭션 코디네이터`를 통해 트랜잭션의 성공 여부에 따라

이 과정에서 `트랜잭션 코디네이터`는 정확히 한 번 전송이 성공하면 해당 레코드의 트랜잭션이 성공했다는 특수한 메세지를 추가한다.

따라서 컨슈머는 `트랜잭션 코디네이터`가 표시한 메세지만을 읽는다면 정확히 한 번 읽게되는 것이다.

## 7.1 코드로 알아보기

```java
import java.util.Properties;

public class ExactlyOnceConsumer {
   public static void main(String[] args) {
      String bootstrapServers = "diger-kafka01.hello.world:9092";
      Properties properties = new Properties();
      properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
      properties.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
      
      properties.setProperty(ConsumerConfig.GROUP_ID_CONFIG, "diger-consumer-01");
      properties.setProperty(ConsumerConfig.AUTO_OFFSET_REST_CONFIG, " earliest");
      properties.setProperty(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "false");
      properties.setProperty(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed"); // 정확히 한 번 읽기
   }
}
```

## 7.2 정확히 한 번 컨슈머 반드시 알아야할 내용

### 오프셋

프로듀서 측에서 트랜잭션 프로듀서를 통해 메세지를 보냈다면 하나의 메세지를 보냈음에도 오프셋은 2가 될 수 있다. 

이렇게 오프셋이 하나가 더 추가되는 이유는, 트랜잭션의 종료를 표시하기 위해 메세지 전송/커밋/중단 에 관한 표시를 남기는 트랜잭션 메세지가 추가되기 때문이다.

컨슈머는 일반적인 토픽의 메세지를 읽지만, 트랜잭션 메세지같은 경우 트랜잭션 성공 여부를 확인하는 목적으로만 읽는다.

### 사실 정확히 한 번만 가져오는게 아닐수도 있다.

프로듀서는 트랜잭션 코디네이터와 통신하면서 정확히 한 번 전송할 수 있지만 컨슈머는 트랜잭션 프로듀서가 보낸 메세지만 가져올 수 있도록 옵션으로 지정할 수 있다.

따라서 100% 정확히 한 번 컨슘하는 것은 아닐 수 있다.

또한 컨슈머가 가져온 메세지를 다른 애플리케이션에 저장하는 과정에서 중복처리 될 수 있으며 다른 저장소로 중복저장된다는 결과를 알 수 없으므로 애플리케이션 전체적으로 보면 정확히 한 번 컨슘했다고 보기 어려울 수도 있다.

컨슈머의 컨슘 후 동작까지 정확히 한 번 처리로 묶으려면 

- `컨슘-메세지 처리-프로듀싱`동작이 하나의 트랜잭션으로 묶어야하며 
- `sendOffsetsToTransaction()`메서드를 이용하여 컨슈머 그룹의 오프셋 커밋을 트랜잭션에 포함시켜야한다.

이로인해 컨슘 후 내부 처리과정에서 실패하면 해당 컨슈머 그룹의 오프셋이 증가하지 않게됨으로써 실패한 트랜잭션을 다시 시작할 수 있다.

### Appendix 카프카 커넥트

HDFS 커넥터는 `프로듀서->카프카`, `카프카-->컨슈머`과정을 정확히 한 번 HDFS에 저장되도록 지원한다. 사용하고자 하는 컨슈머 애플리케이션이 양 종단 간 정확히 한 번 메시지 전송을 지원하는지 확인하는 것도 중요하다.