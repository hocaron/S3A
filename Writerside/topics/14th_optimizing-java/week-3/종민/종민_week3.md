# 3. 하드웨어와 운영체제

자바 개발자가 하드웨어에 관심을 가져야 하는 이유
- 과거에는 오랫동안 무어의 법칙(마이크로칩 집적할 수 있는 트랜지스터 수는 18개월마다 2배씩 증가한다. -> 저장할 수 있는 데이터 용량이 18개월마다 2배)
- 소프트웨어가 복잡해짐 -> 성능 향상을 위해서는 기반기술에 의지

## 3.1 최신 하드웨어 소개
하드웨어 아키텍처를 단순히 레지스터 기반의 오퍼레이션을 수행하는 머신으로 보기에는 많은 변화가 있었음

### 3.2 메모리
- 증가한 트랜지스터는 처음에는 clock 스피드를 올리는데 쓰임 -> 초당 더 많은 명령어 처리 위함
- 클록 속도가 증가하면서 칩은 빨라지는데 데이터의 속도인 메인 메모리가 따라가기 어려워짐

### 3.2.1 메모리 캐시
- 3.2의 문제로 메모리 캐시가 고안됨. 
- 속도: 레지스터 > 메모리 캐시 > 메인 메모리
- 액세스 빈도에 따라 프로세서 코어와 더 가까이 위치함 L1, L2 (프라이빗), L3 캐시 (코어가 공유하는 퍼블릭)
- 완성된 설계
  - cpu 코어마다 L1, L2 캐시가 있고, 모든 코어가 공유하는 L3 캐시가 있음
  - 메인 메모리는 NorthBridge(cpu, 램, 바이오스, ...) 컴포넌트로 액세스
  - SouthBridge는 IDE 컨트롤러 등 주변 장치와의 입출력
- 성능은 좋아졌는데 이제 문제는 데이터를 어떻게 캐시로 가져오고 어떻게 write back해야하는지. "캐시일관성프로토콜"
- MESI 프로토콜
  - Modified: 데이터가 수정된 상태
  - Exclusive: 이 캐시에만 존재하고 메인 메모리 내용과 동일
  - Shared: 둘 이상의 캐시에 데이터가 들어있고 메모리 내용과 동일
  - Invalid: 다른 프로세스가 데이터를 수정하여 무효한 상태
- 프로세서가 처음 나왔을 때는 매번 캐시 연산 결과를 바로 메모리에 기록함
  - write through
  - 메모리 대역폭을 너무 많이 소모
- 나중에는 write back 방식을 채용
  - 더티 캐시 블록만 메모리에 기록
- +) ddr이 최대 전송률이 2배란 얘기 -> 클럭이 올라갈때만 신호전달하는게 아니라 올라갈때 내려갈때 양방향으로 전달해서 2배
- 단순히 operation이 많다고 성능이 더 느릴거란것은 X -> 가장 많이 차지하는 부분은 메모리

### 3.3 최신 프로세서의 특징
### 3.3.1 TLB
- 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행
### 3.3.2 분기 예측과 추측 실행
- 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지
- 가장 발생 가능성이 큰 브랜치를 미리 결정

### 3.3.3. 하드웨어 메모리 모델
- 어떻게 하면 서로 다른 여러 cpu가 일관되게 동일한 메모리 주소를 액세스 할 수 있을까?
- cpu마다 다름. 그래서 멀티스레드에서 순서가 바뀔 수 있으니 lock과 volatile을 잘 알고 사용하자.

### 3.4 운영체제
- 주 임무는 여러 실행 프로세스가 공유하는 리소스 액세스를 관장
  - 메모리 관리 유닛 mmu 를 통한 버츄얼 어드레싱곽 페이지 테이블은 매모리 액세스 제어의 핵심. 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손하지 못하게함
  - TLB

### 3.4.1 스케줄러
- cpu 액세스를 통제
- 실행 큐를 이용
- 자신의 할당 시간을 다 쓴 프로세스는 다시 실행큐 맨 앞으로 갈 때까지 복귀하지 않음
- 다른 프로세스에 영향 받음

### 3.4.2 시간 문제
- OS에 따라 시간 측정이 다름

### 3.4.3 컨텍스트 교환
- 커널모드로 컨텍스트 스위칭이 발생하면 TLB나 다른 캐시들도 무효화됨. 
- 리눅스는 이를 위해 vDSO, 가상 동적 공유 객체를 사

### 3.5 단순 시스템 모델
- 성능 문제를 일으키는 근원을 알아보기 위함
- 기본 컴포넌트 
  - 애플리케이션이 실행되는 하드웨어와 OS
  - 애플리케이션이 실행되는 JVM/컨테이너
  - 애플리케이션 코드 자체
  - 애플리케이션이 호출하는 외부 시스템
  - 애플리케이션이 유입되는 트래픽

### 3.6 기본 감지 전략
### 3.6.1 CPU 사용률
- vmstat, iostat를 사용할 줄 알아야 함. 
- cpu 사용률이 100%에 가까워야함
- 100%를 못갔는데 컨텍스트 교환 비율이 높다면 블로킹이나 스레드 락 경합

### 3.6.2 가비지 수집
- jvm 프로세스가 유저 공간에서 cpu를 100%가까이 사용한다면 gc를 의심. 
- jvm에서 gc로깅은 거의 공짜이므로 꼭 남겨야 함

### 3.6.3 입출력
- 커널 바이패스 I/O
- 커널을 이용해서 데이터를 복사해 유저공간에 넣는것은 작업이 비싸다.
- 그래서 커널 대신 직접 네트워크 카드에서 유저가 접근 가능한 영역으로 데이터를 매핑
- RDMA.. dma: 컴퓨터 주변 장치들이 인터럽트 없이 메모리를 직접 접근

### 3.6.4 기계공감
- 성능을 쥐어짜려면 하드웨어를 이해하고 공감...
- 회사에서 jvm 웜업이나 라이브러리 하단까지 알아야하는..

### 3.7 가상화
- 가상화 os에서 실행하는 프로그램은 비가상화 os에서 실행할때와 동일하게 동작해야함
- 하이퍼바이저는 모든 하드웨어리소스 액세스를 조정해야함
- 가상화 오버헤드는 가급적 작아야 하며 실행 시간의 상당부분을 차지해서는 안된다
- 프리빌리지드 명령어를 언프리빌리지드로 고쳐씀
- tlb cache flush가 일어나지 않도록 자료구조는 새도우

### 3.8 jvm과 운영체제
- 기본적인 서비스조차 하부 os에 액세스해야하는데 이는 네이티브 메소드로 구현. 네이티브는 JNI 인터페이스를 통해 C나 cpp로 구현된 코드를 실행