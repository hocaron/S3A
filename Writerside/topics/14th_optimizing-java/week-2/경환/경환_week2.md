# JVM 이야기

## INTRO
- JVM은 블루컬러 언어로서, 저수준에서 다 알 필요가 없게끔 설계됐다.
- 그래도 성능에 관심이 있다면, 기본적인 JVM 작동원리는 이해하고 있어야 한다.

### 2.1 인터프리팅과 클래스로딩
- JVM은 스택 기반의 해석 머신 -> CPU 구조와 비슷함
- 코드를 실행시키는 JVM 인터프리터는 whil 루프 안의 switch 문과 비슷 -> 실제로는 더 복잡함
- JVM을 실행시키면 컴퓨터의 부트로더가 OS를 메모리에 올리는 것처럼 JVM의 부트스트랩 클래스가 런타임 코어 클래스를 로드한다.
    - 부트스트랩 클래스로더는 최소한의 필수 클래스만 로드한다.
- 확장 클래스로더가 잘 안쓰는 확장 기능을 제공하는 클래스를 로드
- 개발자가 짠 코드는 애플리케이션 클래스로더에 의해 로딩된다.
- 클래스를 나타내는 객체를 직접 로드하는 일은 잘 없지만...ClassNotFoundException을 피하기 위해 빌드프로세스 신경쓰자.
- 한 클래스를 여러 클래스로더가 로드할 수 있어서 클래스는 FQCN + 클래스로더 를 조합하여 식별된다.

### 2.2 바이트코드 실행
- 개발자가 작성한 코드는 javac 에 의해 .class 파일로 저장된 바이트코드로 생성된다.
- 바이트코드는 자바와, 특정 컴퓨터 아키텍처 모두에 독립적인 중간 표현형
- 바이트코드는 매직넘버, 상수풀, 필드, 메서드 속성 등 타입에 관한 정보를 다 가지고 있다.
- 암기 요령은 나와있는데...이걸 외울 일이 있을까?
- 팀에 물어본적이 있는데 10년에 한번 볼까말까한 케이스이지만, 이런 오류도 JVM 버전업하면 해결된다고 함.
- 바이트코드 실행 보면 어셈블리어와 비슷하게 되어있다

### 2.3 핫스팟 입문
- 1999년 핫스팟 가상머신으로 자바가 많이 빨라졌다.
- JAVA는 제로-오버헤드 추상화 철학(정직하게 실행한다)에 반대. 런타임에 동작을 분석하고 성능에 유리하게 최적화된다.
- JIT 컴파일 : 자주 사용되는 코드는 머신에 종속족으로 컴파일한다.
- JIT 외에도 동적 인라이닝 등 최적화 기법이 있다.
- 따라서 실제로 동작하는 방식을 상식적 추론으로 넘겨짓지 말아야...

### 2.4 JVM 메모리 관리
- GC는 언제 수행되고 언제 끝날지 명확하지 않은 불확정적 프로세스
- 뒤의 장에서 다시 보자

### 2.5 스레딩과 자바 메모리 모델
- 그린 스레드 별로였다
- 논그린 쓰레드 쓰는 중
- 스레드는 공용 힙 사용, 스레드간 객체 참조 가능, 객체는 변경 가능
- 락에 관련해서 12장에서 다시 보자

