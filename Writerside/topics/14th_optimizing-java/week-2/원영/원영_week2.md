# 2.1 인터프리팅과 클래스로딩
- JVM은 스택 기반의 해석 머신
- 레지스터는 없지만 일부 결과를 실행 스택에 보관
- **while 루프 안의 switch문**
- java HelloWorld 명령을 내려 자바 애플리케이션을 실행하면?
    - OS는 가상 머신 프로세스 구동
    - 자바 가상 환경 구성되고 스택 머신 초기화
    - 유저가 작성한 Helloword 클래스 파일 실행
    - 부트스트랩 클래스가 자바 런타임 코어 클래스 로드 ex) java.lang.Object, Class, Classloader
    - 확장 클래스로더 생성
    - 애플리케이션 클래스로더 생성: 클래스 패스에 위치한 유저 클래스 로드
    - 실행 중 처음 보는 새 클래스는 디펜던시에 로드
    - 클래스를 찾지 못한 클래스로더는 부모 클래스로더에게 대신 룩업 지시 → 없으면 ClassNotFound

# 2.2 바이트코드 실행
- 자바 컴파일러 javac을 이용한 컴파일: 소스 코드를 .class 파일(바이트 코드)로 바꾸는 것
- 바이트 코드는 특정 컴퓨터 아키텍처에 특정하지 않은 **중간 표현형**
- 이식성이 좋고, 컴파일된 SW는 어디서건 실행할 수 있고, 자바 언어에 대해 추상화되어 있음
- 컴파일러가 생성한 클래스 파일 구조

| 컴포넌트 | 설명 | 비고 |
| --- | --- | --- |
| 매직 넘버 | 0xCAFEBABE | “이 파일이 클래스 파일이다” |
| 클래스 파일 포맷 버전 | 클래스 파일의 메이저/마이너 버전 | 버전 에러 판단 |
| 상수 풀 | 클래스 상수들이 모여 있는 위치 | 상수값: 클래스명, 인페이스명, 필드명 |
| 액세스 클래스 | 추상 클래스, 정적 클래스 등 클래스 종류 표시 | public? final? 인터페이스? 추상클래스?인지 표시 |
| this 클래스 | 현재 클래스 명 | 클래스에 포함된 타입 계층, 상수 풀을 가리키는 인덱스로 표시 |
| 슈퍼 클래스 | 슈퍼 클래스(부모 클래스)명 | 위와 동일 |
| 인터페이스 | 클래스가 구현한 모든 인터페이스 | 위와 동일 |
| 필드 | 클래스에 들어 있는 모든 필드 | 시그니처 비슷한 구조를 정의하고, 수정자 포함 |
| 메서드 | 클래스에 들어 있는 모든 메서드 | 위와 동일 |
| 속성 | 클래스가 지닌 모든 속성 | 더 복잡하고 크기가 고정되지 않은 구조를 나타냄 |

# 2.3 핫스팟 입문
![image](https://github.com/mash-up-kr/S3A/assets/74983448/66b257f0-5143-4459-8236-3fdad56654cf)
- 제로 코스트 추상 사상에 근거한 **기계에 가까운 언어** ↔ 개발자의 생산성에 무게를 둔 **저수준 대행 언어**
- c++은 제로-오버헤드 원칙 준수하지만, 자바는 추상화 철학 동조 x
- 자바의 핫스팟: 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상 머신
- VM 틀에 맞는 프로그램x 바람직한 설계 원리 o

### 2.3.1 JIT 컴파일이란?

- 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작
- CPU 추상화 구조라 어디서건 실행 가능하지만, 성능을 최대로 내려면 CPU에 직접 프로그램 실행
- 이를 위해 핫스팟은 메서드와 루프를 인터프리티드 바이트코드에서 네이비트 코드로 컴파일 → JIT
- JIT 방식
    - 핫스팟은 인터프리티드 모드의 애플리케이션을 모니터링
    - 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일 수행
    - 분석하는 동안 미리 프로그래밍한 추적 정보가 취합 → 더 정교한 최적화
    - 임계점 넘어가면 프로파일러가 특정 코드 섹션을 컴파일/최적화

|  | C++  | Java |
| --- | --- | --- |
| 분류 | AOT 컴파일러 (목표 시스템에 맞는 컴파일) | 프로필 기반 최적화(PGO) |
| 장점 | 성능 예측 가능 | 수집한 추정 정보로 최적화 |
| 단점 | 프로세서에 특정한 기능 개선 불가 | 성능 예측 불가 |
| 개선 |  | 동적 인라이닝, 가상 호출 |

# 2.4 JVM 메모리 관리

- 자바는 가비지 수집이라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식으로 해결
- 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스
- 짧은 시간이지만 부하 고려한 다양한 알고리즘

# 2.5 스레딩과 자바 메모리 모델(JMM)

- Java는 1.0부터 멀티스레드 프로그래밍 기본 지원
- 자바 애플리케이션 스레드 ↔ 전용 OS 스레드
- 그린 스레드(공유 스레드 풀)도 있지만 복잡도만 증가
- 1990년 후반부터 자바의 멀티스레드 기본 설계 원칙
    - 자바 프로세스의 모든 스레드는 가바지가 수집되는 하나의 공용 힙을 가진다
    - 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다.
    - 기본적인 객체는 변경 가능한다. (Final 없으면 변경 가능)
- JMM은 서로 다른 실행 스레드가 객체 안에 변경되는 값을 어떻게 바라보는지를 기술한 공식 메모리 모델

# 2.6 JVM 구현체 종류

- OpenJDK: 기본 구현체를 제공하는 특별한 오픈 소스 프로젝트
- 오라클 자바(Oracle): OpenJDK 기반이지만 상용 라이선스
- 줄루(Zulu): Azul 시스템 제작, 무료, 자유로운 재배포
- 아이스티(IcedTea): 레드헷 제작, 재배포 가능, 오라클 제외 최초의 회사
- 징(Zing): Azul 제작한 고성능 상용 JVM, 64bit linux에서만 작동
- J9: IBM 제작, 상용이었다가 오픈소스, 이클립스 OMR 프로젝트 기반
- 애비안(Avian): 100% 인증 x, 학습용
- 안드로이드(Android): 여러 가지 자바 클래스 라이브러리 구현체와 교차 컴파일러

### 2.6.1 JVM 라이선스

- JVM 구현체는 대부분 핫스팟(GPL 라이선스)에서 비롯
- 오라클 자바는 OpenJDK 코드 베이스이지만 상용 제품
- 오라클이 주 브랜치에는 패치하지 않기 때문에 라이선스 외에 차이 없음
- 배포 환경 JDK 선택 조심하기~~~

# 2.7 JVM 모니터링과 툴링

JVM은 성숙한 실행 플랫폼으로 관측하는 다양한 기술 제공

- 자바 관리 확장 (Java Managmenr Extensions, JMX)
    - 동작하는 애플리케이션 제어 및 모니터링하는 강력한 범용 툴
- 자바 에이전트 (Java Agent)
    - 자바 언어로 작성된 툴 컴포넌트
    - `java.lang.instrument` 인터페이스로 메서드 바이트코드 조작
    - 에이전트 JAR 파일에서 매니페스트는 필수
    - Premain-Class 속성에 에이전트 클래스명을 반드시 지정해야 함 → 등록 후크 역할
- JVM 툴 인터페이스 (JVM Tool Interface, JVMTI)
    - 자바 인스트루먼테이션 API로도 부족하면 네이티브 인터페이스인 JVMTI 사용
    - 네이티브 에이전트가 JVM 이벤트를 모니터링하며 알림을 받을 수 있는 통신 인터페이스
- 서비서빌리티 에이전트(Serviceability Agent, SA)
    - 자바 객체, 핫스팟 자료 구조 모두 표출 가능한 API와 툴의 집합
    - 코드 실행 필요없이 코어 파일 및 생생한 자바 프로세스까지 디버깅 가능

### 2.7.1 VisualVM

- 넷빈즈 플랫폼 기반의 시각화 툴
- 어태치 매커니즘을 이용해 실행 프로세스를 실시간 모니터링
- 개요, 모니터, 스레드, 샘플러 및 프로파일러 탭 활용 가능

# 2.8 마치며

- 중요한 주제들은 뒤에서 자세히!

### +) 04/14 Study Comments
- JVM 웜업: JVM 최적화는 누적 정보로 이루어지기 때문에, 개발자가 미리 많이 호출되는 메서드를 실행할 때 먼저 여러 번 호출하는 경우도 있음(= JVM 웜업)
    
    [if(kakao) - JVM warm up](https://velog.io/@qwerty1434/ifkakao-JVM-warm-up)
    
- 옛날 책이기 때문에 JVM의 기본 동작 원리에 집중하기
- 클래스로더 역할: 바이트 읽어서 클래스 객체 만들어서 Java 네이티브에 코드에 던져주는 역할
- 확장 클래스 로더:

  [API reference for Java Platform, Standard Edition](https://docs.oracle.com/en/java/javase/11/docs/api/index.html)
