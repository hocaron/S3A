# 7장 스프링 핵심기술의 응용

## 7.5 DI를 이용해 다양한 구현 방법 적용하기

### 7.5.2 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기

#### 내장형 DB를 이용한 SqlRegistry 만들기

UpdatableSqlRegistry 테스트 코드의 재사용
ConcurrentHashMapSqlRegistry, EmbeddedDbSqlRegistry의 테스트 방법 차이 X  
-> 상속을 통한 테스트 코드 재사용(JUnit4.x 이상부터 테스트 클래스 상속구조 가능)

![image](https://user-images.githubusercontent.com/18495291/235968155-9dddc177-bbcd-4228-ab48-2f139b4c5b42.png)  
- UpdatableSqlRegistry 구현 클래스의 오브젝트 생성 부분만 분리되면 나머지 코드 공유 가능  
![image](https://user-images.githubusercontent.com/18495291/235968255-21d552ac-8af1-4d3e-8805-5c0bb60c3ab8.png) 

![image](https://user-images.githubusercontent.com/18495291/235969785-ff65e484-4192-4425-af66-94df31aeb458.png)
- createUpdatableSqlRegistry()만 EmbeddedDbSqlRegistry를 사용할 수 있도록 구현하면 모든 테스트 동일 수행 가능  

#### XML 설정을 통한 내장형 DB의 생성과 적용

![image](https://user-images.githubusercontent.com/18495291/235971080-156a66f3-3521-4b13-a6b3-31ca9cdd4669.png)
- 팩토리빈을 통한 embeddedDatabase 빈 생성  
![image](https://user-images.githubusercontent.com/18495291/235971312-fd315b1a-a790-4491-b0a3-6de7d96cc095.png)
- dataSource 프로퍼티로 embeddedDatabase DI  
-> DataSource 인터페이스의 기능만 사용할것이기 때문  
EmbeddedDatabase 타입의 빈은 스프링 컨테이너가 종료되는 시점에 자동으로 shutdown() 메소드 호출  

### 7.5.3 트랜잭션 적용  
#### 다중 SQL 수정에 대한 트랜잭션 테스트
수동 테스트로 트랜잭션의 적용을 검증하는 것은 어렵기 때문에 트랜잭션이 적용되면 성공하고 아니면 실패하는 테스트를 통해 검증  
![image](https://user-images.githubusercontent.com/18495291/236244280-f93d69a0-edc5-4419-bc10-5503cce45d70.png)

#### 코드를 이용한 트랜잭션 적용
![image](https://user-images.githubusercontent.com/18495291/236244775-d9e1a620-456f-4234-a4df-ce7867ade29a.png)

## 7.6 스프링 3.1의 DI
#### 자바 언어의 변화와 스프링
- 애노테이션의 메타정보 활용  
-> 애노테이션 자체로는 아무 기능이 없고, 핵심은 리플렉션 API를 이용해 애노테이션의 메타정보를 조회, 애노테이션 내 설정된 값을 참고하여 사용  
![image](https://user-images.githubusercontent.com/18495291/236248825-16e98115-3d80-4aba-ba1c-57c9a5d8f932.png)  
-> Special 애노테이션을 통한 메타데이터 접근  
![image](https://user-images.githubusercontent.com/18495291/236249000-65d27c5a-855b-4e32-a3db-b6632297bdb9.png)  
-> 동일한 기능을 XML을 통하여 작성  
애노테이션에 비해 작성해야할 정보가 많고 type-safe하지 않음  
내용 변경시에 재빌드를 하지 않아도 된다는 장점이 있음  

- 정책과 관례를 이용한 프로그래밍  
XML, 애노테이션 방식 모두 미리 정의한 정책을 이용하여서 특정 기능이 동작하도록 만들어짐  
-> 이러한 방식은 기존의 코드로 작성해야하는 것들을 간결하고 빠른 개발이 가능하도록 해줌  
-> 하지만 코드 자체에 기능들이 드러나지 않기 때문에 관례를 모른다면 해당 기능들을 예측, 이해하기 어렵기 때문에 관례 학습에 적지 않은 비용이 들음  

### 7.6.1 자바 코드를 이용한 빈 설정  
#### 테스트 컨텍스트의 변경 
#### \<bean\>의 전환  
@Bean <= 스프링 부트에서 주로 사용하는 여러분들이 모두아는 Bean 등록 방식 
메소드의 이름 <=> XML bean id 값
![image](https://user-images.githubusercontent.com/18495291/236257654-546d4a16-7d31-494a-80e2-712dc1651a09.png)  
-> XML의 property는 setter를 통해 대체
![image](https://user-images.githubusercontent.com/18495291/236258636-2fce5e60-aa1d-44d6-b001-1e75a981d5c2.png)  
-> 프로퍼티로 bean을 받는 bean은 bean의 메소드를 직접 호출 

