# 3. 카프카 디자인

## 3.1 카프카 디자인의 특징
- 처리량에 중점을 두었다. -> 중앙 데이터파이프라인이기 때문에
- HA를 위해 분산시스템으로 설계
- 페이지캐시와 배치 전송 처리 구현

## 3.2 카프카 데이터 모델
- 토픽: 메세지를 논리적으로 그룹핑한 개념
- 파티션: 토픽을 구성하는 데이터 저장소 (파티셔닝)
- 파티션을 늘리면 프로듀서와 컨슈머의 수도 늘려줘야 한다.
- 파티션 너무 많아지면 장애복구 시간 증가 및 리소스 과사용 등 문제
- 적은 파티션 개수로 시작해서 테스트해보면서 늘려보자.
- 파티션 수는 줄일 수 없다.
- 브로커당 파티션수 2000개 권장
- 오프셋: 파티션마다 메세지가 저장되는 위치
- 오프셋을 이용해 순서를 보장한다.

## 3.3 카프카의 고가용성과 리플리케이션
- 리플리케이션은 기본적으로 1 (복제 없음)
- 토픽별로 다른 리플리케이션 팩터를 지정할 수 있다.
- 기본값은 클러스터 내 모든 브로커에 동일하게 설정 필요
- 리플리케이션은 파티션를 복제하는 것.
- 모든 읽기와 쓰기는 리더를 통해서만 일어난다.
- 리플리케이션 팩터 2~3정도가 적당
- ISR: In Sync Replication, 동기 복제 단위
- 리더가 될 수 있는 팔로워는 ISR 내에서 동기식으로 복제가 이루어진 파티션

## 3.4 모든 브로커 다운 시
- 1번: 마지막 리더가 살아나길 기다린다.
- 2번: ISR 에서 추방되었지만 자동으로 리더가 된다.
- 1번의 경우 데이터 정합성 굿...근데 복구 안될수도 있음
- 2번의 경우 ISR이 아니기 때문에 정합성 떨어짐. 근데 빠른 복구
- 2번으로 되살아난 리더를 unclean leader 라고 한다.
- 현재는 1번이 기본값
- unclean.leader.election.enable로 설정한다.