# 9. JVM의 코드 실행
- JVM은 메모리 관리와 애플리케이션 코드 컨테이너 역할을 한다.
- 지금까지 메모리 관리였고 이번부터는 코드 실행에 대해 다룬다.
- JVM은 동적 컴파일로 인터프리터의 성능 문제를 해결한다. -> JIT

## 9.1 바이트코드 해석
- JVM은 루프안의 Switch 머신
- 레지스터 없고 스택 이용
    - 평가 스택, 로컬 변수, 객체 힙 -> 힙만 메서드, 스레드끼리 공유된다.
- 수직 구조와 각 계층에 연산자, 피연산자 -> 트리 구조
- 옵코드는 1바이트 -> 현재 200개 정도 사용 중
- 바이트코드는 빅엔디언 구조 사용
- 옵코드는 같은 연산에 대해 type별로 있고, 단축형이 있어서 파일 구조를 줄일 수 있다. -> 모뎀 시절 기억하시는 분?
- 바이트코드 무슨 종류 있는지 보면 어셈블리랑 비슷함...
    - load i1 : 지역 변수 i1 값을 스택에 로드한다.
    - store i1: 스택 상단을 지역변수 i1 에 저장한다 등등
    - add, sub, div, mul, cast, neg, rem, if, goto 등
    - invokevirtual, invokespecial, invoke 어쩌구저쩌구 등
    - new, newarray, ...
- invokedynamic
    - java7에서 jvm 동적 언어(JRuby 등) 을 지원하고자 했는데...
    - 뜬금없이 다른 객체의 메서드를 호출할 수 있는 기능이어서 람다 기능에서 유용하게 써먹음
- 대단위 vs 소단위 바이트코드
    - 소단위는 산술 연산처럼 간단한 것 -> 순수 어셈블리어로 구현됨
    - 대단위는 디스패치 처럼 복잡한 것 -> 핫스팟 VM 다시 호출
- 간단한 인터프리터 구현 보면 별거 없음... 그냥 돌면서 계산함
- 핫스팟에 특정한 내용
    - 핫스팟은 템플릿 인터프리터라도 동적으로 인터프리터를 구축
    - final 메서드 최적화
        - final 메서드는 상속 못하니까 invokespecial로 구현되어야 할것같지만
        - JVM 스펙 상 final 떼면 기존 바이너리와의 호환성을 깨뜨리지 않는다고 되어 있어서
        - invokespecial로 호출되는 메서드의 오버라이드 메서드가 호출되지 않는 문제가 생길 수 있음
        - 이런 문제를 해결하기 위해 final 디스패치용 전용 바이트코드가 있다.


## 9.2 AOT와 JIT
- AOT: 최적화 기회는 컴파일할때만
    - 어느 아키텍처에서 실행될지 모르므로 가장 보수적인 선택
- JIT: 인터프리터로 실행하다가 Profile Guided Optimization으로 알잘딱깔센 가능
- JIT 하면서 리소스 사용 vs 그냥 실행하면서 리소스 조금 더 사용 어느쪽이 유리한지 판단한다.
- 비주기적인 배치가 돌 경우 AOT보다 PGO가 압살함 -> 시스템이 한가한 날에 최적화 결과 저장했다가 월배치 도는 날에 성능이 뻗어버림
- 그렇다고 AOT를 못쓸 물건도 아니어서 AOT 지원하는 상용 VM이 있다고는 하네용

## 9.3 핫스팟 JIT 기초
- 핫스팟 기본 컴파일 단위는 전체 메서드
- 메서드 캐시에서 JIT 컴파일러 돌려서 코드 캐시에 메서드를 저장함
- 완료되면 klass의 vtable은 새로 컴파일된 코드를 가리키도록 수정됨
- -XX::+PrintCompilation으로 어느 메서드가 JIT 컴파일되는지 확인 가능, 등등 옵션 최신 doc 찾아보기
    - 지금 최신 자바는 22..
- 핫스팟 JVM에는 C1과 C2라는 두 JIT 컴파일러가 있다.
    - C1: 대충 최적화함 대신 빠름
    - C2: 열심히 최적화함 대신 느림
- 두 컴파일러 모두 호출 횟수에 따라 컴파일링이 트리거됨.
- 레벨 별 컴파일
    - 1: C1 프로파일링 없이 최적화 돌려버림
    - 2: C1 호출 카운터와 백엣지 카운터만 프로파일링 함
    - 3: C1 풀 프로파일링
    - 4: C2
- 컴파일 경로
    - 3-4: C1 풀 프로파일링하고 바로 C2로
    - 2-3-4: 단계적으로 프로파일링 올리다가 C2 -> 바쁜경우
    - 3-1 : 프로파일링 해봤는데 별거 없는 메서드인 경우
    - 4: C2로 직행
    - 단계별 컴파일은 성능 튜닝시 별로 조정할 일은 없다

## 9.4 코드 캐시
- JIT 컴파일드 코드가 저장되는 곳. VM 자체 네이티브 코드도 같이 있다.
- 역최적화 or 단계별 컴파일 시 or 클래스 언로딩시 빠짐
- 코드 캐시 사이즈는 VM스위치 건드리면 된다.

## 9.5 간단한 JIT 튜닝법
- 컴파일을 원하는 메서드에게 아낌없이 리소스를 베풀라
- 코드캐시 크기 - JIT 컴파일 메서드 개수 관계가 선형적으로 증가할때 까지 코드 캐시 크기를 늘린다.
- 주요 tx 상에 위치한 주요 메서드가 모드 컴파일되는지 확인 -> 안되면? 메서드 크기를 줄여야하나

## 9.6 마치며
- 성능 진짜 중요할때는 JIT도 잘 보세요~
    
