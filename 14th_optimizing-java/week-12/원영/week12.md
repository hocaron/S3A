# 12. 동시 성능 기법

## 12.1 병렬성이란?

- 태스크를 고루 분배한다고 가정하면 전체 태스크 소요 시간은 다음과 같음
    - S: 순차 실행 파트, T: 총 태스크 소요 시간, N: 프로세서 개수
    
    ```
    T(N) = S + (1/N) * (T - S)
    ```
    
    - 프로세서를 무한히 증가시켜도 총 소요 시간은 순차 작업 시간 이상 줄일 수 없음
- 상태를 공유하는 워크로드는 무조건 정교한 보호/제어 장치가 필요

### 12.1.1 자바 동시성 기초

- 카운터를 락으로 적절히 보호하지 않은 상채로 멀티스레드 환경에서 이 코드를 실행하면, 다른 스레드가 저장하기 이전에 로드 작업이 일어날 가능성이 있음
    - 즉, 다른 스레드가 수정한 결과가 소실될 수도 있음
    - 각 스레드는 메서드 개별 진입 시 각자 전용 평가 스택을 소유하므로 필드에 대한 작업 서로 간섭 가능성
- volatile을 추가해도 업데이트 소실 문제 발생 가능
- 자바 5 이전까지는 synchronized로 업데이트를 제어하여 해결 → 더 느려질 수 있음
- 처리율 향상은 ↔ 전체 목표(동시성 부여) : 복잡도에 대한 혜택 충분히 입증 필요

## 12.2 JMM의 이해

- Java 1.0 부터 있던 메모리 모델
- JMM 해결 과제
    - 두 코어가 같은 데이터를 액세스하면 어떻게 되는가?
    - 언제 두 코어가 같은 데이터를 바라본다고 장담할 수 있는가?
    - 메모리 캐시는 위 두 질문의 답에 어떤 영향을 미치는가?
- 순서에 관한 보장과 여러 스레드에 대한 업데이트 가시성 보장
- 종류
    - **강한 메모리 모델**: 전체 코어가 항상 같은 값을 바라 봄
    - **약한 메모리 모델**: 코어마다 다른 값을 바라볼 수 있고 그 시점을 제어하는 특별한 캐시 규칙 존재
- 강한 메모리 모델은 캐시 무효화 알림이 메모리 버스 잠식 = 전송률 급락 → 멀티코어 체제에 안 어울림
- JMM은 아주 약한 메모리 모델 → 하드웨어에 보장하는 내용이 없어서 이식 용이
- JMM의 애플리케이션 보호 기본 개념
    - Happens-Before (~보다 먼저 발생)
    - Sychronizes-With (~와 동기화) : 이벤트가 객체 뷰를 메인 메모리와 동기화시킴
    - As-If-Serial (순차적인 것처럼)
    - Release-Before-Acquire (획득하기 전에 해제): 획득전에 다른 스레드가 락 해제
- 자바 Synchronized 키워드 의미: 모니터를 장악한 스레드의 로컬 뷰가 메인 메모리와 동기화 됨
    - 동기화 메서드, 동기화 블록: 스레드가 반드시 동기를 맞춰야 할 접점에 해당하며, 다른 것전에 반드시 완료되어야 할 코드 블록을 정의해 놓은 것

## 12.3 동시성 라이브러리 구축

- JMM은 성공적이지만 이해와 응용이 어려움
- 자바 5부터는 고급 동시성 라이브러리와 툴은 자바 클래스 라이브러리의 일부로 표준화하려는 움직임
- `java.util.concurrent` : 패키지는 멀티스레드 애플리케이션을 자바로 더 쉽게 개발
- 하드웨어에 CAS(Compare and Swap) 기능이 구현되어 있음

### 12.3.1 Unsafe

- `sun.misc.Unsafe` 는 내부 구현 클래스로 CAS 하드웨어 액세스 가능
- 특징
    - 객체는 할당하지만 생성자는 실행하지 않습니다.
    - 원메모리에 액세스하고 포인터 수준의 연산을 수행합니다.
    - 프로세서별 하드웨어 특성(CAS)를 이용합니다.
- 활용
    - 신속한 역직렬화
    - 스레드에 안전한 네이티브 메모리 액세스
    - 아토믹 메모리 연산
    - 효율적인 객체/메모리 레이아웃
    - 커스텀 메모리 펜스
    - 네이티브 코드와의 신속한 상호작용
    - JNI에 관한 다중 운영체제 대체물
    - 배열 원소에 volatile 하게 액세스
- 주요 기능: 메모리 직접 접근, 스레드 제어, 클래스 로딩, 메모리 할당 등
- 일반적인 Java 개발에서는 사용되지 않으며, 주로 JVM 내부 구현이나 고성능 라이브러리 개발에 이용
- 표준은 아니지만 사실상 표준

### 12.3.2 아토믹스와 CAS

- 아토믹스: 값을 더하고 증감하는 복합 연산을 하며 get()으로 계산한 결괏값을 돌려받음
- 아토믹 변수는 volatile 확장판이지만 더 유연해서 상태 의존적 업데이트 수행 가능
- 예시 해설) Unsafe에서 내부적으로 루프를 이요해 CAS 작업을 반복적으로 재시도 → 이를 고려하여 루프로 증분 연산을 하는 등의 작업 불필요

### 12.3.3 락과 스핀락

- 스핀락 구현 핵심 개념
    - ‘테스트하고 세팅’하는 작업은 반드시 아토믹해야 함
    - 스핀락에 경합이 발생하면 대기 중인 프로세서는 빽빽한 루프를 실행하게 됨

## 12.4 동시 라이브러리 정리

- 이전 내용은 저수준 기법
- 아래는 이를 활용한 표준 라이브러리

### 12.4.1 java.util.concurrent

- `java.util.concurrent.locks.Lock` 으로 많을 일 가능
- `lock()`, `newCondition()`. `tryLock()`, `unlock()`  메서드로 제어
- 여러 종류의 락을 생성할 수 있고, 여러 메서드에 걸쳐 락을 걸어놓는 것도 가능

### 12.4.2  읽기/쓰기 락

- 어느 한 읽기 스레드 때문에 나머지 읽기 스레드를 블로킹하느라 시간 낭비 가능성
- ReentrantReadWriteLock 클래스의 ReadLock과 WriteLock을 활용하면 여러 스레드가 읽기 작업을 하는 도중에도 다른 쓰레드 블로킹 X, 쓰기에서만 블로킹

### 12.4.3 세마포어

- 풀 스레드나 DB 접속 객체 등 여러 리소스의 액세스를 허용하는 독탁한 기술 제공
- 정해진 수량의 퍼밋으로 액세스 제어
- `acquire()`(퍼밋 추가), `release()`(퍼밋 반납) 등의 메서드로 구현

### 12.4.4 동시 컬렉션

- 자바 동시 컬렉션은 조금씩 보완되어 있음
- 예시) Map 구현체는 버킷 또는 세그먼트로 분할된 구조로 실질적 성능 개선
    - 여러 쓰레드가 읽는 동안, 쓰기가 필요한 경우 한 세그먼트만 락을 거는 행위 가능

### 12.4.5 래치와 배리어

- 스레트 세트의 실행을 제어하는 유용한 기법
- 래치: 하나 이상의 스레드가 특정 조건을 기다리도록 하는 동기화 도구
- 배리어: 여러 스레드가 특정 지점에서 모두 도착할 때까지 기다리도록 하는 동기화 도구

## 12.5 실행자와 태스크 추상화

- 일반적으로 저수준의 스레드 문제를 직접 처리하는 것 보다는 `java.util.concurrent` 패키지에서 적절한 추상화 동시 프로그래밍 지원 기능 추천

### 12.5.1 비동기 실행이란?

- 자바에서는 Callable  인터페이스로 태스크 추상화 가능
- ExecutorService: 관리되는 스레드 풀에서 태스크 실행 메커니즘을 규정한 인터페이스
- Executors: 상황에 맞는 ExecutorService를 생성하는 팩토리 메서드를 포함

### 12.5.2 ExecutorService 선택하기

- 잘 선택하면 비동기 프로세스를 적절히 잘 제어할 수 있고, 풀 스레드 개수를 정확히 잘 정하면 성능이 뚜렷이 향상
- 코어의 수 대비 풀 스레드 수를 지표로 이용
- 동시 실행 스레드 개수 >프로세서 개수? 문제 발생

### 12.5.3 포크/조인

- ForkJoinPool라는 새로운 ExecutorService 구현체에 기반
- 분할 정복 알고리즘(Divide and Conquer)을 효율적으로 실행할 수 있도록 설계된 스레드 풀

## 12.6 최신 자바 동시성

- 최신 자바는 CPU 리소스를 효율적으로 사용하는 문제가 더욱 중요하게 부각
- 현대 자바는 언어 및 표준 라이브러리에 내장된 추상화를 이용해 성능을 크게 높일 수 있는 환경을 제공

### 12.6.1 스트림과 병렬 스트림

- 자바 8의 가장 큰 변경 사항: 람다/스트림 함수형 프로그래밍
- 병렬 스트림(parallelStream())을 이용하면 병렬로 데이터를 작업 후 그 결과를 재조합 가능

### 12.6.2 락-프리 기법 (?)

- 블로킹이 처리율에 악영향을 미치고, 성능을 저하시킬 수 있다는 전제하에서 시작
- 대가: CPU 코어를 차지하는 것은 사용률, 전력 소비 측면에서 비용이 듬

### 12.6.3 액터 기반 기법

- 태스크를 스레드 하나보다 더 작게 나타내려는 다양한 접근 방식이 고안
- 액터는 그 자체로 고유한 상태와 로직 포함. 동시에 다른 액터와 소통하는 메일박스 체계를 갖춘, 작고 독립적인 처리 단위
- 액터는 병렬 시스템 내부에서 하나의 네트워크를 형성하고 그 속에서 각자 나름대로 작업을 수행함으로써 하부 동시 모델을 완전히 추상화한 모습을 바라 봄 = 액터들끼리 비동기적으로 메시지를 주고 받음
- 공유 메모리 문제 해소
- 모든 기능을 대체할 수는 없음

## 12.7 마치며

- 동시성 기반의 설계 방식으로 전환할 때 고려 사항
    - 순서대로 죽 처리하는 서능을 정확히 측정할 수 있어야 한다.
    - 변경을 적용한 다음 진짜 성능이 향상됐는지 테스트
    - 성능 테스트는 재실행하기 쉬워야 한다. 특히, 시스템이 처리하는 데이터 크기가 달라질 가능성이 큰 경우
- 추천 목표
    - 동시 컬렉션을 이용해 스레드 핫 성능을 높인다.
    - 하부 자료 구조를 최대한 활용할 수 있는 형태로 액세스를 설계한다.
    - 애플리케이션 전반에 걸쳐 락킹을 줄인다.
    - 가급적 스레드를 직접 처리하지 않도록 태스크/비동기를 적절히 추상화한다.
