# 가비지 수집 기초

## 6.0 Intro
- 신세대 프로그래밍 언어에서도 메모리 관리는 컴파일러나 런타임의 영역이라 보는 시각이 지배적
- 가비지 수집은 프로그래머가 아닌 런타임이 대신 객체를 추적하면서 적절히 제거하는 것
- GC는 두 가지 원칙 절대 준수 필요
    - 알고리즘은 반드시 모든 가비지를 수집해야한다.
    - 살아있는 객체는 절대로 수집해서는 안된다.

## 6.1 마크 앤 스위프
- 마크 앤 스위프 알고리즘은 객체의 포인터를 포함하는 할당리스트를 사용한다.
- 동작 원리
    - 할당 리스트의 마크비트를 지운다 -> 초기화
    - GC 루트로 부터 연결되어 있는 객체는 마크 비트를 세팅한다.
    - 마크 비트가 세팅되지 않은 객체를 찾아 프리 리스트에 되돌리고, 할당 리스트에서 객체를 삭제한다.
    - DFS 방식으로 순회
- 가비지 수집 용어
    - STW : Stop the world, 모든 애플리케이션 스레드가 중단되는 것
    - 동시: GC 스레드와 애플리케이션 실행이 동시(병행) 실행되는 것, 100퍼센트 동시 실행을 보장하는 건 없다. 어렵고 비싼 작업
    - 병렬: GC 병렬 처리
    - 정확: 힙 상태에 대한 충분한 타입 정보(크기)를 가지고 있는 것
    - 보수: 보수적인 스킴은 정확한 스킴의 정보가 없다.
    - 이동: 객체는 메모리 여기저기를 오갈 수 있는 것
    - 압착: 메모리 컴팩션
    - 방출: 살아남은 객체를 다를 메모리 영역으로 이동시키는 것

## 6.2 핫스팟 런타임 개요
- 핫스팟은 런타임에 oop 라는 구조체로 자바 객체를 나타낸다.
- oop 는 포인터라고 보면 됨
- instance oop
    - 인스턴스를 가리키는 포인터
    - Mark + Klass로 시작한다. Mark는 인스턴스 메타데이터, Klass는 클래스 메타데이터
    - Java 8부터는 Klass가 자바 힙의 주 영역 밖으로 나가서, Klass는 객체 헤더가 필요 없다.(intance oop 와 달리)
- compressed oop
    - 32기가 이상 쓰면 꺼짐.
    - 어차피 byte단위이므로 oop에 byte 단위로 넣어서 압축
- 핫스팟 객체 헤더 구성
    - Mark
    - Klass
    - 배열일 경우 length
    - 32비트 여백
- 자바 레퍼런스의 실체
    - 레퍼런스는 instance oop를 가리킨다.
    - 자바 값은 기본형 값 or intanceOop
    - 그러므로 레퍼런스는 포인터
- GC 루트 및 아레나
    - GC 루트는 메모리의 고정점. 메모리 풀 외부에서 내부를 가리키는 포인터
        - 스택프레임, JNI, 레지스터, 코드 루트(JVM 코드캐시에서), 전역 객체, 로드된 클래스의 메타데이터
    - 핫스팟 GC는 아레나 라는 메모리 영역에서 동작
    - 핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않는다.(중요)
    - 측정값으로 GC 서스시스템이 어떤 성능 문제를 일으키고 있는지 파악할 수 있음

## 6.3 할당과 수명
- 할당률 : 초당 어느정도의 객체가 할당되는지? -> 쉽게 측정 가능
- 객체 수명 -> 쉽게 측정 불가능
- GC 이론은 대부분 객체는 단명한다는 것.
    - 객체 수명은 이원적 분포를 따른다
    - 거의 대부분 객체는 단명하지만, 나머지 객체는 기대 수명이 훨씬 길다.
- GC는 단명 객체를 빠르게 수집해야하면, 장수 객체와 단명 객체를 분리하는게 효율적이다.
- 영 GC가 돌때마다 n번 이상 살아님은 객체는 테뉴어드로 승격된다.
- 카드 테이블로 늙은 객체가 젊은 객체를 참조 유무를 그룹핑해서 관리한다.
    - 카드 테이블의 원소는 올드 공간의 512 바이트를 가리킨다.
    - 해당 영역에 변경이 생기면 해당 엔트리를 더티마킹한다.

## 6.4 핫스팟의 가비지 수집
- JVM은 에덴을 여러 버퍼로 나누어 각 스레드가 새 객체를 할당하는 구역으로 활용되게끔한다. 이를 TLAB 라고 함
- TLAB로 인해 스레드 할당 복잡도는 O(1)
- 반구형 방출 수집기
    - 두개의 서바이버를 사용
    - GC 때마다 객체들이 다른 서바이버에 압축됨
    - 왔다 갔다..

## 6.5 병렬 수집기
- 자바 8 이전까지 JVM 디폴트 GC는 병렬 수집기. 처리율에 최적화되어있음
- 영, 풀 GC 모두 풀 STW 를 일으킨다.
- JVM이 새 TLAB를 할당할 수 없을 때 영 세대 수집이 발생
- GC 루트와 올드 세대에서 출발하는 GC루트를 식별하기 위한 카드테이블을 병렬 마킹의 시작점으로 삼음
- 싹 마크앤스윕함
- 올드 세대 병렬 수집은 하나의 연속된 메모리 공간에서 압착
- 병렬 수집기는 풀STW 가 발생, (영세대는 거의 죽으므로 STW 시간이 짧음 -> GC 루트로부터 금방 순회하므로)
- GC 튜닝 함부로 하지 마라

## 6.6 할당의 역할
- GC를 시계열 분석하는건 별로 의미가 없다. 규칙성이 없어서
- 객체 수명은 불확정적이므로 할당률이 높으면 테뉴어드로 곧장 승격될 확률이 높음
- 이를 조기승격이라고 함

## 6.7 마치며
- 나는 json 상하차 땔깜이라는것을 실감함.