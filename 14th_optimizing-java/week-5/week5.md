# 마이크로벤치마킹과 통계

## INTRO
- 목표: 마이크로벤치마킹이 무엇인지 설명해주겠다.
- 리처드파인만: 절대로 스스로를 속이면 안된다~ -> 인지 편향에 빠지지 말라
- JMH 사용법 간략하게 다루겠음

## 5.1 자바 성능 측정 기초
- 사실상 JMH 소개하기 위한 빌드업
- 마이크로벤치마킹 하면서 빠지기 쉬운 함정을 쭉 소개
- 자바 런타임의 정교함 문제 -> 동적인 블랙박스
- 그 누구도 온전한 전체일 뿐 섬이 아닙니다(존 던) -> JVM을 설명하는 가장 적절한 말인듯
- 예시1 숫자 정렬 예시
    - 코드: 1000개의 랜덤한 숫자 어레이를 만든다 -> 15만번 복사떠서 복사뜬걸 정렬
    - 15만번 정렬 수행 시간의 평균값 산출
- 예시 1의 함정
    - 웜업을 고려하지 않음
        - 어느 순간 JIT 컴파일 되어서 초기 수행은 느리지만 이후 수행은 빨리질 수 있음
        - 웜업을 고려할려면 시간 측정하지 않은 상태로 벤치마크 대상 코드를 여러번 수행해서 웜업시켜야한다.
    - GC 발생할 수 있음
        - GC 발생은 불확정적이기 때문에 통제할 수 없음
        - 힙 크기와 반복 수에 따라에따라 GC가 발생할 수도, 안할 수도 있기 때문에 GC 시간을 고려해서 파라미터 잡아야함
        - -verbose:gc 옵션으로 가비지 수집로그를 남겨서 참고하자
    - 랜덤한 숫자가 담긴 어레이를 카피떠서 정렬하는데, 정렬한 결과를 사용하지 않으므로 컴파일러가 삭제해버릴 수도 있음
        - 정작 벤치마크하려는 sort 메서드는 수행조차 안됨
    - 시스템의 전원관리 기능이 동작하거나 하드웨어에서 경합조건이 발생할 수도 있다.
    - 단순하게 정렬 알고리즘 성능을 테스트할려고 해도 이정도로 골치아픔..
- 해결방안
    - 시스템 전체를 벤치마킹한다. -> 큰수의 법칙
    - 그래도 벤치마킹할려면.... 위와 같은 함정을 잘 피하도록 설계된 JMH를 쓰자!!!

## 5.2 JMH 소개
- 앞서본 마이크로벤치마킹의 어려움을 짜잔 해결한게 JMH
- 저자의 충격 실화를 얘기하면서 마이크로벤치마킹한 동료의 사례 소개
    - 가급적 마이크로벤치마킹은 하지 말지어다.... -> 파인만의 말을 되새기자.
- 그래도 마이크로벤치마킹을 해야할 때
    - 범용 라이브러리 개발해야할때 -> 레디스 라이브러리 같은거 보면 성능순으로 줄세워서 좋은거 쓰니까...
        - 특수한 케이스: 이클립스 컬렉션즈 -> GS Collection
    - OpenJDK 같은 자바 플랫폼 구현체 개발할 때 -> 혹시나 이런거 개발하시게 된다면 저를 잊지말아주세요
    - 저지연 거래 개발해야할 때... -> 증권사 케이스...?
- 괴츠한 사람이 파인만이 한 말이랑 같은 말을 또함
- 다음과 같은 기준을 충족하면 마이크로벤치마킹이 의미있다캄
    - 저지연
    - 객체 할당률 낮아야함
    - CPU Burst?
    - 실행 시간의 메서드 분포를 알야아함 -> 최적화 대상 메서드가 분명해야 한다는 뜻인것 같음
- JMH 진짜 소개 시작
- JMH 는 JVM 을 빌드한 사람들이 직접 만든 프레임워크! 무려 오리지널
- 벤치마크 툴은 동적이어야함.
    - 리플렉션을 써서 작성한 벤치마크를 싱행하는 우회방법도 있지만 -> 프로덕션 코드 안에 벤치마킹 코드를 넣는게 아니라
    - 정확성을 위해 벤치마킹 라이브러리에서 직접 호출겠다는 의미
- 벤치마킹을 위해 벤치마크 대상 코드를 여러번 실행하는데 JVM이 루프 최적화 안하도록 잘 만들었다함.
- 벤치마크 실행은 그레이들이나 메이븐으로 쓱삭해서 프로젝트 만들면 된다.
- 블랙홀 기능을 이용해 삭제 대상이 되지 않도록 만들었다.
    - 죽은 코드 제거하지 못하게
    - 반복되는 계산을 상수로 치환하지 못하게
    - CPU 캐시 영향 적도록
    - 쓰기 장벽으로부터 보호한다.
        - OUTPUT 스트림 포화? 이런 얘기같은데
    - consume 메서드 보면 재밌음
- JMH를 쓰더라도 GC 수행같은 노이즈를 조심하자.

## 5.3 JVM 성능 통계
- 랜덤오차: 말그대로 자연적으로 랜덤하게 일어나는 오차 -> 정밀도
- 계통오차: 뭔지는 모르지만 존재하는 요인에 일어나는 오차 -> 정확도
    - 부하테스트 서버의 네트워크 지연시간
- 허위상관: 출산률과 황새 개체수의 관계
- 위와 같은 여러 계통오차나 요인들이 섞여있다보니까 JVM 성능은 비정규 통계학을 따른다.

## 5.5 마치며
- 유스케이스를 확실히 모른느 상태에서 마이크로벤치마킹하지 마세요
- 그래도 해야한다면 JMH 쓰자
- 함께 의논하자 -> 인지편향을 피하자
- 진짜 인지 편향 피하자...



