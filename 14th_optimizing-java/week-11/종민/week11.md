# 11. 자바 언어의 성능 향상 기법
네트워크 연결, I/O, DB 등의 애플리케이션 외부 요인 다음으로 병목 가능성 있는 부분이 코드 설계
성능에 민감할 경우 기본 원칙: 데이터를 어떻게 저장할지가 중요
데이터를 저장할 때 어떤 옵션을 사용 가능할 수 있을지 이해하려면 컬렉션 API가 지원하는 자료구조랑 구현 세부를 알고 있어야 함

도메인 객체가 무엇인지, 내부에서 수명이 어떠한지 아는 것은 성능에 큰 영향을 끼친다. 
내부에서 어떻게 사용하는지에 따라 가비지 수집에도 영향을 미침.
오버헤드가 가중되어 jvm이 런타임에 관리해야하는 상황으로 이어질 수도있음

### 11.1 컬렉션 최적화
- 순차 컨테이너: 수치 인덱스로 표기한 특정 위치에 객체릂 저장
- 연관 컨테이너: 객체 자체를 이용해 컬렉션 내부에 저장할 위치를 결정

컨테이너에서 메서드가 정확히 작동하려면 호환성과 동등성 개념을 지니고 있어야 함(hashcode, equals 필수 구현)
참조형 필드는 힙에 레퍼런스로 저장된다. 컨테이너에 저장되는 것은 객체 자신이 아니라 객체를 가리키는 레퍼런스이다. 그래서 c/cpp에서 배열잉나 벡터를 사용하는것만큼 성능을 얻을 수는 없음
컬렉션 API: 타입별로 해당 컨테이너가 준수해야 할 작업을 구체적으로 명시한 인터페이스 모음
깨알상식: 스택은 잘못 설계되었다(https://stackoverflow.com/questions/37314298/why-stack-extends-vector-in-jdk)
- 스택대신 덱을 쓰자

### 11.2 List 최적화
- ArrayList, LinkedList 두가지로 나뉨
- Stack Vector는 안쓰임. Vector는 쓸데없이 synchronized 되어 있어서 성능만 구림. 하위호환성 위해 남겨둠

### 11.2.1 ArrayList
- 고정 크기 배열에 기반한 리스트
- 크기만큼 원소를 추가하다가 꽉차면 새로 할당한 다음 기존 값을 복사
- 처음에 빈 배열로 시작하고 원소가 추가될 때 10인 배열을 할당함. 초기 용량값을 전달하면 조정 안해도 됨

### 11.2.2 LinkedList
- 동적으로 증가하는 리스트. 더블링크드리스트로 되어있어서 더하는 작업은 항상 O(1)

### 11.2.3 ArrayList vs LinkedList
- 리스트 끝에 삽입하는 작업은 둘다 일정한 시간이 소요
- arrayList는 특정 인덱스에 삽입하려면 한칸씩 우측으로 이동해야하지만 링크드리스트는 찾는 시간이 있지만 삽입은 간단히 끝남. 삭제도 마찬가지
- 리스트를 랜덤 액세스하는경우는 ArrayList.
- 꼭 필요한 경우 아니면 ArrayList를 권장
- 크기는 미리 설정하는것이 좋다

### 11.3 Map 최적화
### 11.3.1 HashMap
- 버킷 엔트리를 리스트에 저장. 값을 찾으려면 키 해시값을 계산하고 equals로 리스트에서 해당 키를 찾는다
- 같은 키를 넣으면 hashmap에있던 키를 치환
- 최근 버전에서 개선된 점: indexFor 메서드를 키 객체의 hashcode 메서드를 사용하는 코드로 교체하고 마스크를 적용해 상위 비트를 아랫쪽 해시 부분에 분산
```
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
- initialCapacity, loadFactor는 성능에 큰 영향을 미침. 
- 용량 디폴트는 16, loadFactor는 버킷 용량을 자동 증가시키는 한계치. 기본은 0.75라서 75%가 차면 버킷을 2배 늘림
- 0.75 정도면 공간과 접근 시간 균형이 맞음. 최대 원소 개수를 load factor로 나눈 값을 initial capacity로 설정하면 재해시가 발생하지 않음
- 버킷 원소를 Linked List로 구현하면 원소 찾으려고 리스트를 찾는 비용이 듦
- 하나의 노드에 일정 개수 TREEIFY_THRESHOLD 이상이 되면 TreeNode로 바꿔버림
- TreeNode는 공간을 2배 더 차지. 원래 고루 분포 잘되는걸 쓰면 쓸 이유없음

LinkedHashMap
- HashMap의 서브클래스로 이중 연결 리스트를 사용해 원소의 삽입 순서를 관리
- LinkedHashMap의 기본 관리 모드는 삽입 순서이지만 액세스 순서로 바꿀 수 있음. 
- 순서가 중요한 코드에서 많이 쓰임
- 그러나 Map을 사용할때는 삽입/접근 순서가 중요하지 않음

### 11.3.2 TreeMap
- 레드블랙트리를 구현한 Map
- 트리 균형이 한쪽으로 치우치는 현상을 방지
- 정렬된 상태로 Map을 유지해야 하거나 정렬된 데이터를 조회해야 하는 범위 검색이 필요한 경우

## 11.4 Set 최적화
- Set은 중복을 허용하지 않음
- HashSet은 HashMap으로 구현되어있음
- PRESENT라는 객체는 처음하나 만들어두고 사용
- map에 key: 값, value: PRESENT를 넣음
- HashSet은 원소 순서는 기본적으로 유지하지 않음
- TreeSet은 TreeMap을 사용해서 Comparator에 정의된 대로 정렬된 키 순서를 유지

## 11.5 도메인 객체
- 어플리케이션에 유의미한 비즈니스 컨셉을 나타낸 코드
- 도메인 객체는 타입 간에 연관되어 있음(order에는 여러 orderItem이 매핑)
- 일반적으로는 코어 jdk에 있는 자료구조가 jmap 결과 상위권에 있어야 하는데 도메인 객체가 상위 30위권에 들면 메모리 누수가 발생
- "전체 세대 효과" : 수집되어야 할 때 수집되지 않으면 여러 사이클을 끝내고 별의별 세대 카운트를 가진채 테뉴어드까지 살아남음
- 단명 도메인 객체 역시 부유 가비지 문제를 일으키는 원인이 될 수 있음

## 11.6 종료화 안하기
- finalize 메서드(RAII 패턴)
- close를 하는걸 까먹는다..

### 11.6.2 왜 종료화로 문제를 해결하지 않을까?
- Object 의 finalize는 처음부터 있었음
- 어떤 객체가 더 이상 자신을 참조하지 않는다고 판단하면 finalize 메서드를 호출. 서브클래스는 finalize 메서드를 오버라이드해서 시스템 리소스를 처분
- 가비지 수집 중 즉시 회수되지 않고 큐로 이동해서 종료화 스레드가 큐를 비우고 finalize 메서드를 실행
- finalize가 종료되면 다음 사이클에 수집될 준비를 마침(한사이클 더 보존)
- 종료화 스레드 실행 중 예외가 발생하면 무시되어 실행되지 않음
- finalize는 언제 실행될지 알 길이 없고 실행될지 여부도 알 수 없음.(deprecate)

### 11.6.3 try-with-resources
- 원래는 try finally로 닫았음. 여러 리소스가 개입되면 복잡해짐
- try-with-resources 생성자를 이용하면 try 블록이 끝날때 close가 자동호출(AutoCloseable 인터페이스를 구현해야함)


## 11.7 메서드 핸들
- invokedynamic은 호출부에서 실행할 메서드를 유연하게 결정할 수 있게 됨. (어느 메서드를 호출할 지 런타임 전까지 결정되지 않음)
- 호출부가 인터프리터에 이르면 부스트스랩메서드 BSM이 호출되고 호출되었어야 할 실제 메서드를 가리키는 객체를 반환
- 메서드핸들: invokedynamic 호출부에 의해 호출되는 메서드를 나타낸 객체
- 하부 메서드를 실행할 수 있는 메서드가 매서드 핸들 객체 내부에 내장되어있음(invoke)
- 리플렉션은 invokedynamic과 더불어 사하기 불편
  - "invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;" 
  -  Obejct 인수와 Object를 반환하므로, 컴파일 타임에는 이 메서드가 어떻게 호출될지 전혀 가늠할 길이 없다.
- MethodHandles.lookup(): 룩업 컨텍스트 생성, 컨텍스트 객체를 생성한 시점에 접근 가능한 메서드 및 필드를 기록한 상태 정보가 있다. 
- findVirtual(): 컨텍스트를 생성한 시점부터 보이는 모든 메서드의 핸들을 가져올 수 있다 -> hasCode() 메서드를 룩업. 
- invoke(): 리플렉션처럼 invoke() 호출이 모든 인수를 두루 받아들이는 만능 호출 대신, 런타임에 호출돼야 할 예상 시그니처를 기술한다. 
  - -> 실제로 바이트코드를 살펴보면, 호출 시그니처가 "invoke:(Ljava/lang/String;)I" 다.
- 프레임워크 개발자들이나 주로 이용한다